<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础-1</title>
    <url>/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<h1 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h1><p>Java是面向对象的语言，它与c++不同的是，其程序的基本单位就是类（class），并且Java可通过Java虚拟机（JVM）实现跨平台，即在多个操作系统上运行</p>
<p>在安装java环境时，需要安装两部分内容，即JDK和JRE：</p>
<p>JRE——java程序的运行环境，包括JVM和运行时所需要的的核心类库，只要安装JRE就能够运行Java程序</p>
<p>JDK——java程序的开发工具包，包含JRE和开发人员使用的工具，其中开发工具指编译工具（javac.exe）和运行工具（java.exe）</p>
<h2 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h2><p>切换盘符——盘符：</p>
<p>查看当前目录下所有文件——dir</p>
<p>进入指定文件夹——cd 文件夹名</p>
<p>多级进入——cd 文件夹与当前位置的相对路径</p>
<p>返回上级目录——cd ..</p>
<p>多级回退（直接回到根目录）——cd \</p>
<p>清空命令记录——cls</p>
<p>退出cmd——exit</p>
<p>使用过的命令间切换——上下箭头</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在未进行环境配置时，需要进入javac或java的路径下，才能够使用javac.exe和java.exe，为了方便使用，需要配置环境变量</p>
<p>1.下载并安装JDK，建议开发工具和JRE安装放置同一文件夹下</p>
<p>2.计算机-右键菜单-左侧高级系统设置-环境变量中，在下方系统变量内创建</p>
<p>JAVA_HOME——填写JDK文件夹内部绝对路径（如：D:/Java/Jdk）</p>
<p>CLASSPATH——填写下列内容（注：不能忘记开头的点和每个目录和目录下文件名后的分号）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure>
<p>找到系统变量的Path——新建以下内容（这里末尾没有分号）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure>
<p>以上Java环境变量配置完成，重新打开cmd（在配置完成之前打开的cmd窗口可能仍旧报错），并在cmd中输入java和javac出现对应命令使用方法说明则配置成功</p>
<h2 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的文件名必须为HelloWorld，与类名相同</p>
<p>在cmd中进入目标文件所在位置，并输入javac HelloWorld.java，即可编译得到同目录下后缀名为.class的同名文件，再输入java HelloWorld（这里没有后缀名），即可运行该程序</p>
<p>对以上Hello World的入口说明（即方法/函数创建）：</p>
<p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p>
<h2 id="标识符定义"><a href="#标识符定义" class="headerlink" title="标识符定义"></a>标识符定义</h2><p>【包含类名、变量名以及方法名】</p>
<ul>
<li>应以字母，$，或下划线开头，字符组合也只能在前三种的基础上添加数字</li>
<li>关键字不能用作标识符，且标识符区分大小写</li>
</ul>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">受保护的</td>
</tr>
<tr>
<td align="left">public</td>
<td align="left">公共的</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">类</td>
</tr>
<tr>
<td align="left">extends</td>
<td align="left">扩充,继承</td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">最终值,不可改变的</td>
</tr>
<tr>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">接口</td>
</tr>
<tr>
<td align="left">native</td>
<td align="left">本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">新,创建</td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态</td>
</tr>
<tr>
<td align="left">strictfp</td>
<td align="left">严格,精准</td>
</tr>
<tr>
<td align="left">synchronized</td>
<td align="left">线程,同步</td>
</tr>
<tr>
<td align="left">transient</td>
<td align="left">短暂</td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">易失</td>
</tr>
<tr>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">继续</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">运行</td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">否则</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">如果</td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">实例</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">返回</td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
</tr>
<tr>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
</tr>
<tr>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
</tr>
<tr>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="left">try</td>
<td align="left">捕获异常</td>
</tr>
<tr>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">字节型</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">字符型</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">长整型</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">短整型</td>
</tr>
<tr>
<td align="left">super</td>
<td align="left">父类，超类</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">本类</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">无返回值</td>
</tr>
<tr>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">空</td>
</tr>
</tbody></table>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/2.png" alt="2"></p>
<p>java的基本数据类型中新增了byte，short，long三种整数形式，分别占用1个字节，2个字节，8个字节，c++中的bool类型写作boolean，仍然只有true和false两个值，默认的整数为int类型，浮点数为double类型</p>
<p>在使用long类型时，为了防止整数过大，后面要加L，如：100000000L</p>
<p>在使用false类型时，为了防止类型不兼容，后面要加F，如3.14F</p>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul>
<li>大小写敏感：Java和c#一样区分大小写，使用时必须确保大小写完全一致</li>
<li>类名：类名首字母应该大写，由多个单词组成时，每个单词首字母大写</li>
<li>方法名：方法名以小写字母开头，由多个单词组成时，后面的每个单词首字母大写</li>
<li>源文件名：源文件名必须和类名相同，文件名后缀为.java</li>
<li>主方法入口:（类似c#中的main函数）程序由<strong>public static void main(String[] args)</strong> 开始执行</li>
</ul>
<h2 id="字符和字符串的“-”操作"><a href="#字符和字符串的“-”操作" class="headerlink" title="字符和字符串的“+”操作"></a>字符和字符串的“+”操作</h2><p><strong>字符的“+”操作是字符对应的编码进行加减</strong></p>
<p><strong>字符串的“+”操作是前后两者的拼接，如果有连续“+”操作，从左到右依次进行“+”操作</strong></p>
<p>例如：</p>
<p>“字符串”+10——输出得到——字符串10</p>
<p>“字符串”+10+20——输出得到——字符串1020</p>
<p>10+20+“字符串”——输出得到——30字符串</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="基本逻辑运算符"><a href="#基本逻辑运算符" class="headerlink" title="基本逻辑运算符"></a>基本逻辑运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>前后同时满足为true，否则为false</td>
</tr>
<tr>
<td>|</td>
<td>前后同时不满足为false，否则为true</td>
</tr>
<tr>
<td>^</td>
<td>前后关系式的值不相等时为true，相等时为false</td>
</tr>
<tr>
<td>!</td>
<td>结果和关系式正好相反</td>
</tr>
</tbody></table>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与&amp;相同，但有短路效果，即前者为false时整个表达式为false，且不执行后者</td>
</tr>
<tr>
<td>||</td>
<td>与|相同，但有短路效果，即前者为true时整个表达式为true，且不执行后者</td>
</tr>
</tbody></table>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>关系表达式？表达式1：表达式2</p>
<ol>
<li>计算关系表达式的值</li>
<li>如果为true，则表达式1的值为该语句的值</li>
<li>如果为false，则表达式2的值为该语句的值</li>
</ol>
<h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><h3 id="用Scanner输入"><a href="#用Scanner输入" class="headerlink" title="用Scanner输入"></a>用Scanner输入</h3><ol>
<li>导入scanner包：import java.util.Scanner；</li>
<li>创建对象：Scanner 变量名1=new Scanner（System.in）；</li>
<li>接受数据：int 变量名2=变量名1.nextInt（）；</li>
</ol>
<p>Scanner从键盘接受不同类型数据的方法：</p>
<table>
<thead>
<tr>
<th>接收数据</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>int类型</td>
<td>nextInt()</td>
</tr>
<tr>
<td>long类型</td>
<td>nextLong()</td>
</tr>
<tr>
<td>float类型</td>
<td>nextFloat()</td>
</tr>
<tr>
<td>double类型</td>
<td>nextDouble()</td>
</tr>
<tr>
<td>String类型</td>
<td>nextLine()/next()</td>
</tr>
<tr>
<td>boolean类型</td>
<td>nextBoolean()</td>
</tr>
</tbody></table>
<p>上表中没有接收字符数据的方法，要想接受字符数据可以采用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">String str=sc.next();</span><br><span class="line"><span class="keyword">char</span> ch=str.charAt(<span class="number">0</span>);</span><br><span class="line">System.out.println(ch);</span><br></pre></td></tr></table></figure>
<h3 id="用System-in输入"><a href="#用System-in输入" class="headerlink" title="用System.in输入"></a>用System.in输入</h3><p>1.导包：import java.io.*；</p>
<p>2.构造 BufferedReader类对象，它附属于标准输入流System.in：BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</p>
<p>3.添加抛出声明或用try/catch包围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String str=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        str=br.readLine();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(str.equals(<span class="string">&quot;END&quot;</span>))<span class="keyword">break</span>;</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

<ol>
<li>read方法：读取单个字符。 返回：作为一个整数（其范围从 0 到 65535 (0x00-0xffff)）读入的字符，如果已到达流末尾，则返回 -1 </li>
<li>readLine方法：读取一个文本行。通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行。 返回：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</li>
</ol>
</p></div>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><table>
<thead>
<tr>
<th>Java</th>
<th>c++</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>System.out.println(“x = “ +x);</td>
<td>cout&lt;&lt;”x = “&lt;&lt;x&lt;&lt;endl;</td>
<td>输出变量x的值并换行</td>
</tr>
<tr>
<td>System.out.print(“x = “ +x);</td>
<td>cout&lt;&lt;”x = “&lt;&lt;x;</td>
<td>输出变量x的值，不换行</td>
</tr>
<tr>
<td>System.out.printf(“x = %d”,x);</td>
<td>printf(“x = %d”,x);</td>
<td>以格式化文本和参数列表输出，不换行</td>
</tr>
</tbody></table>
<h3 id="random的使用"><a href="#random的使用" class="headerlink" title="random的使用"></a>random的使用</h3><p>导入包：import java.util.Random；</p>
<p>创建对象：Random 变量名=new Random（）；</p>
<p>获取随机数：int number=r.nextInt（范围上限）；——获得的随机数在0~上限之间，包括0，不包括上限</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h2><ul>
<li>数据类型[ ] 变量名——int[ ] arr 【常用】</li>
<li>数据类型 变量名[ ]——int arr[ ]</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Java中数组必须先初始化才能使用，分动态初始化和静态初始化</p>
<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>初始化时只指定数组长度，由系统为数组分配初始值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[ ] 变量名 =<span class="keyword">new</span> 数据类型[数组长度];</span><br><span class="line">如：<span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>初始化时指定每个数组元素的初始值，由系统决定数组长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[ ] 变量名 =<span class="keyword">new</span> 数据类型[ ]&#123;数据<span class="number">1</span>,数据<span class="number">2</span>,数据<span class="number">3</span>,……&#125;;</span><br><span class="line">如：<span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">简化写作：数据类型[ ] 变量名=&#123;数据<span class="number">1</span>,数据<span class="number">2</span>,数据<span class="number">3</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问权限 关键字 返回类型 方法名(参数表)&#123;方法体&#125;</span><br><span class="line">如：<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中public为访问权限修饰符，如下：</p>
<table>
<thead>
<tr>
<th>访问权限</th>
<th>类</th>
<th>包</th>
<th>子类</th>
<th>其他包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>对任何人都是可用的</td>
</tr>
<tr>
<td>protect</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>×</td>
<td>继承的类可以访问以及和private一样的权限</td>
</tr>
<tr>
<td>default</td>
<td>∨</td>
<td>∨</td>
<td>×</td>
<td>×</td>
<td>包访问权限，即在整个包内均可被访问</td>
</tr>
<tr>
<td>private</td>
<td>∨</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>除类型创建者和类型的内部方法之外的任何人都不能访问的元素</td>
</tr>
</tbody></table>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>方法重载指同一个类中，定义的多个方法之间的关系，需要满足下列条件：</p>
<ul>
<li>多个方法在同一个类中</li>
<li>多个方法具有相同的方法名</li>
<li>多个方法的参数不同，即参数类型不同或参数数量不同</li>
</ul>
<p>方法重载的特点：</p>
<ul>
<li>重载仅对应方法的定义，和方法调用无关</li>
<li>重载仅针对同一个类中方法的名称和参数进行识别，和返回值无关，即返回值不同是不构成重载的</li>
</ul>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-4</title>
    <url>/2021/08/19/Java%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<h1 id="API（应用程序编程接口）"><a href="#API（应用程序编程接口）" class="headerlink" title="API（应用程序编程接口）"></a>API（应用程序编程接口）</h1><p>API是一些预先定义好的接口（如函数，HTTP接口）或指软件系统不同组成部分衔接的约定。用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节</p>
<p><strong>工具类的设计思想：</strong></p>
<ul>
<li>构造方法用private修饰（防止外界创建对象）</li>
<li>成员用public static修饰（强制用类名访问）</li>
</ul>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math包含执行基本数字运算的方法，成员均为静态，即可以通过类名调用,常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static int abs(int a)</td>
<td>返回参数的绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>返回大于或等于参数的最小double值，等于一个整数</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>返回小于或等于参数的最大double值，等于一个整数</td>
</tr>
<tr>
<td>public static int round(float a)</td>
<td>按照四舍五入返回最接近参数的int</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>返回两个int值中较大值</td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td>返回两个int值中较小值</td>
</tr>
<tr>
<td>public static double pow(double a,double b)</td>
<td>返回a的b次幂的值</td>
</tr>
<tr>
<td>public static double random()</td>
<td>返回值为double的正值，[0.0,1.0)</td>
</tr>
</tbody></table>
<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System包含几个有用的类字段和方法，不能被实例化，常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static void exit(int status)</td>
<td>终止当前运行的Java虚拟机，非零表示异常终止</td>
</tr>
<tr>
<td>public static long currentTimeMillis()</td>
<td>返回当前时间（以毫秒为单位）</td>
</tr>
</tbody></table>
<p>其中currentTimeMillis()方法可通过记录开始和结束时间相减，计算程序运行时间</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object是类层次结构的根，每个类都可以将Object作为超类（父类），所有类都直接或者间接的继承自该类</p>
<p>构造方法：public Object()</p>
<p>常用方法如下：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String toString()</td>
<td>用于返回一个简明扼要的字符串来描述该对象，默认为“包名+类名+@+存储地址”，推荐子类重写</td>
</tr>
<tr>
<td>public boolean equals（Object obj）</td>
<td>比较对象是否相等，默认比较地址，重写可以比较内容</td>
</tr>
</tbody></table>
<p><strong>IDEA编译器中可用Alt+Insert自动生成子类的重写方法</strong></p>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays类包含用于操作数组的各种方法</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public static String toString(int[] a)</td>
<td>返回指定数组的内容的字符串表示形式</td>
</tr>
<tr>
<td>public static void sort(int[] a)</td>
<td>按照数字顺序排列指定的数组</td>
</tr>
</tbody></table>
<h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据，常用的操作之一是用于基本数据类型与字符串之间的转换</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><ul>
<li><p>装箱：把基本数据类型转换为对应的包装类类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=Integer.valueOf(<span class="number">100</span>);<span class="comment">//装箱</span></span><br><span class="line">Integer ii=<span class="number">100</span>;<span class="comment">//自动装箱，自动转换成上一行代码</span></span><br></pre></td></tr></table></figure></li>
<li><p>拆箱：把包装类类型转换为对应的基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="number">100</span>;</span><br><span class="line">i=i.intValue()+<span class="number">200</span>;<span class="comment">//先拆箱，再自动装箱</span></span><br><span class="line">i+=<span class="number">200</span>;<span class="comment">//自动拆箱，自动装箱</span></span><br></pre></td></tr></table></figure>
<p>注：在使用包装类类型的时候，如果做操作，最好先判断不为null，推荐只要是对象，在使用前就必须进行不为null的判断</p>
</li>
</ul>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date代表了一个特定的时间，精确到毫秒</p>
<table>
<thead>
<tr>
<th>构造方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Date()</td>
<td>分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</td>
</tr>
<tr>
<td>public Date(long date)</td>
<td>分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-3</title>
    <url>/2021/08/09/Java%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<h1 id="包（Package）"><a href="#包（Package）" class="headerlink" title="包（Package）"></a>包（Package）</h1><p>包是为了java程序编写时对类分类管理而创建的文件夹</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">package</span> 包名;(多级包用.隔开)</span><br><span class="line">如：<span class="keyword">package</span> JavaProject.first;</span><br><span class="line">实际上是创建了JavaProject文件夹，并在文件夹下创建first文件夹</span><br></pre></td></tr></table></figure>
<p>在编译带包的java文件时，可以手动创建包并将编译好的class文件放入包中，或者是通过命令“javac -d .文件名.java”在文件所在目录下自动创建包并完成编译，执行时需要带包执行，即“java JavaProject.first.文件名”</p>
<h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>使用不同包下的类时，需要使用类的全路径，为了简化带包的操作，java提供了导包的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">import</span> 包名;</span><br><span class="line">如：<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">即导入java/util文件夹下的Scanner文件夹内所有类</span><br></pre></td></tr></table></figure>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table>
<thead>
<tr>
<th>访问权限</th>
<th>类</th>
<th>包</th>
<th>子类</th>
<th>其他包</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>对任何人都是可用的</td>
</tr>
<tr>
<td>protect</td>
<td>∨</td>
<td>∨</td>
<td>∨</td>
<td>×</td>
<td>继承的类可以访问以及和private一样的权限</td>
</tr>
<tr>
<td>default</td>
<td>∨</td>
<td>∨</td>
<td>×</td>
<td>×</td>
<td>包访问权限，即在整个包内均可被访问</td>
</tr>
<tr>
<td>private</td>
<td>∨</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>除类型创建者和类型的内部方法之外的任何人都不能访问的元素</td>
</tr>
</tbody></table>
<h3 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final（最终态）：可以修饰成员方法，成员变量，类</p>
<ul>
<li>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong></li>
<li>修饰变量：表明该变量时常量，<strong>不能再次被赋值</strong></li>
<li>修饰类：表明该类时最终类，<strong>不能被继承</strong></li>
<li>修饰局部变量：当变量是<strong>基本类型</strong>时，<strong>数据值不能改变</strong>，当变量时<strong>引用类型</strong>时，地址值不能改变，但<strong>数据值可以改变</strong></li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static（静态）：可以修饰成员方法和成员变量</p>
<p>static修饰的特点：</p>
<ul>
<li>被类的所有对象共享</li>
<li>可以通过对象名和类名调用，推荐类名调用</li>
</ul>
<p>static访问的特点：静态成员方法只能访问静态成员</p>
<h1 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h1><p>集合类可以提供一种存储空间可变的存储模型，存储的数据容量可以发生改变，较常用的有ArrayList</p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList&lt; E&gt;：位于util包下，实现可调整大小的数组，其中&lt; E&gt;是一种特殊的数据类型，泛型，可用引用数据类型替换</p>
<h3 id="构造方法和添加方法"><a href="#构造方法和添加方法" class="headerlink" title="构造方法和添加方法"></a>构造方法和添加方法</h3><ul>
<li>public ArrayList()：创建一个空的集合对象</li>
<li>public boolean add(E e)：将指定的元素追加到此集合的末尾</li>
<li>public void add(int index,E element)：在此集合的指定位置插入指定的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建ArrayList：</span><br><span class="line">    ArrayList&lt;数据类型&gt; 变量名=<span class="keyword">new</span> ArrayList&lt;数据类型&gt;();</span><br><span class="line">例如：ArrayList&lt;String&gt; array=<span class="keyword">new</span> ArrayList&lt;数据类型&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>public boolean remove(Object o)：删除指定的元素，返回删除是否成功</li>
<li>public E remove(int index)：删除指定索引处的元素，返回被删除的元素</li>
<li>public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</li>
<li>public E get(int index)：返回指定索引处的元素</li>
<li>public int size()：返回集合中的元素的个数</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string类在java.lang下，所以使用不需要导入包</p>
<p><strong>字符串的特点：</strong></p>
<ul>
<li>字符串不可变，值在创建后不能被更改</li>
<li>虽然String值不可变，但是可以被共享</li>
<li>字符串效果上相当于字符数组（char[]），但底层原理是字节数组（byte[]）【JDK8及以前是字符数组，JDK9及以后是字节数组】</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String（）</td>
<td>创建一个空白字符串对象，不含有任何内容</td>
</tr>
<tr>
<td>public String（char[] chs）</td>
<td>根据字符数组的内容，创建字符串对象</td>
</tr>
<tr>
<td>public String（byte[] bys）</td>
<td>根据字节数组的内容，创建字符串对象</td>
</tr>
<tr>
<td>String s=“abc”；</td>
<td>直接赋值的方式创建字符串对象，内容就是abc</td>
</tr>
</tbody></table>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>通过new创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同</li>
<li>以“ ”方式给出的字符串，只要字符序列相同，无论在程序代码中出现几次，都只会创建一个String对象，并在字符串池中维护</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>使用==比较时：</p>
<ul>
<li>基本类型：比较的是数据值是否相同</li>
<li>引用类型：比较的是地址值是否相同</li>
</ul>
<p>字符串本身是对象，比较内容是否相同，需要通过方法实现：<strong>equals（）</strong></p>
<p>public boolean equals（Object anObeject）：将此字符串和指定对象进行比较，由于比较的是字符串对象，所以参数直接传递一个字符串</p>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>public char charAt(int index)：返回字符串指定索引处的char值</li>
<li>public int length()：返回字符串长度</li>
</ol>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder是一个可变的字符串类，在拼接字符串时不会新建一个String对象，避免浪费空间</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容</li>
<li>public StringBuilder(String str)：根据字符串的内容来创建可变字符串对象</li>
</ul>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>public StringBuilder append（任意类型）：添加数据，并返回对象本身【可链式编程】</li>
<li>public StringBuilder reverse()：返回相反的字符序列</li>
</ul>
<h3 id="和String的互相转换"><a href="#和String的互相转换" class="headerlink" title="和String的互相转换"></a>和String的互相转换</h3><ol>
<li><strong>StringBuilder转换为String</strong>：public String toString()</li>
<li><strong>String转换为StringBuilder</strong>：public StringBuilder(String s)</li>
</ol>
<h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><p>一种公共的规范标准，java中的接口更多体现在堆行为的抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口的定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;&#125;</span><br><span class="line">类实现接口：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特点：</strong></p>
<ul>
<li>接口不能实例化——但可以通过实现类对象实例化</li>
<li>接口的实现类要么重写接口中所有抽象方法，要么还是抽象类</li>
</ul>
<div class="tip warning"><p>

</p><p>方法的形参和返回值是接口名时，实际需要和返回的是该接口的实现类对象</p>
<p></p></div>

<h2 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h2><ul>
<li><p>成员变量：</p>
<p>只能是常量</p>
<p>默认的修饰符为<strong>public static final</strong></p>
</li>
<li><p>构造方法：</p>
<p>接口没有构造方法，因为接口主要对行为进行抽象，没有具体存在</p>
<p><strong>一个类如果没有父类，默认继承自Object类</strong></p>
</li>
<li><p>成员方法：</p>
<p>只能是抽象方法</p>
<p>默认修饰符为<strong>public abstract</strong></p>
</li>
</ul>
<h2 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h2><p>类和接口可以是实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名 <span class="title">implement</span> 接口1名,接口2名……</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>接口和接口可以是继承关系，可以单继承，也可以多继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 接口1名,接口2名……</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul>
<li><p>成员区别</p>
<table>
<thead>
<tr>
<th></th>
<th>允许具有的成员</th>
</tr>
</thead>
<tbody><tr>
<td>抽象类</td>
<td>变量，常量，构造方法，抽象方法和非抽象方法</td>
</tr>
<tr>
<td>接口</td>
<td>常量，抽象方法</td>
</tr>
</tbody></table>
</li>
<li><p>关系区别</p>
<table>
<thead>
<tr>
<th></th>
<th>允许的关系</th>
</tr>
</thead>
<tbody><tr>
<td>类与类</td>
<td>继承，单继承</td>
</tr>
<tr>
<td>类与接口</td>
<td>实现，可以单实现也可以多实现</td>
</tr>
<tr>
<td>接口与接口</td>
<td>继承，单继承，多继承</td>
</tr>
</tbody></table>
</li>
<li><p>设计理念区别</p>
<table>
<thead>
<tr>
<th></th>
<th>设计理念</th>
</tr>
</thead>
<tbody><tr>
<td>抽象类</td>
<td>对类抽象，包括属性，行为</td>
</tr>
<tr>
<td>接口</td>
<td>对行为抽象，主要是行为</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类：在一个类中定义一个类，如在类A中定义一个类B，则类B是类A的内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问特点：</p>
<ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建内部类的对象</li>
</ul>
<p>按照内部类在类中定义的位置不同，可以分为两种：</p>
<ul>
<li>在类的成员位置：成员内部类</li>
<li>在类的局部位置：局部内部类</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">非私有时可用以下格式在类外创建内部类对象：</span><br><span class="line">    外部类名.内部类名 对象名=外部类对象.内部类对象;</span><br><span class="line">例如：</span><br><span class="line">    Outer.Inner oi=<span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">当内部类私有时，则在外部类中写入公开方法，在类内创建内部类对象：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="comment">//此处省略内部类内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Inner i=<span class="keyword">new</span> Inner();</span><br><span class="line">            <span class="comment">//i即为创建的内部类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="comment">//此处省略内部类内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        Inner i=<span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="comment">//i即为创建的内部类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，局部内部类Inner定义在方法InnerMethod中，使用内部类时需要直接在方法中创建内部类对象并调用内部类的方法，如果只创建内部类无法调用内部类的成员方法</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类的前提：存在一个类或接口，可以是具体类或抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    <span class="keyword">new</span> 类名或接口名()&#123;</span><br><span class="line">    重写方法;</span><br><span class="line">	&#125;;</span><br><span class="line">例如：</span><br><span class="line">    <span class="keyword">new</span> Inner()&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//被重写的方法</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>匿名内部类本质上是一个继承了该类或实现了该接口的子类匿名对象,所以调用匿名内部类的方法时可以写作如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        new Inner()&#123;</span></span><br><span class="line"><span class="comment">        	@Override</span></span><br><span class="line"><span class="comment">            public void show()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;匿名内部类&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        以上只创建了匿名内部类，没有调用方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        new Inner()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void show()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;匿名内部类&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;.show();</span></span><br><span class="line"><span class="comment">        匿名内部类本质是一个匿名对象，所以直接可以通过对象调用方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Inner i=<span class="keyword">new</span> Inner()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i.show();</span><br><span class="line">        <span class="comment">//这个匿名的对象本身继承了该类或实现了该接口，故而可以将其赋值给其父类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用匿名内部类可以简化操作，免去重新创建一个文件书写使用次数不多的类，而是将该类作为一个匿名内部类包含在同一个文件里，形如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();		<span class="comment">//A为B的接口操作类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bc();		<span class="comment">//Bc为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bd();		<span class="comment">//Bd为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Be();		<span class="comment">//Be为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bf();		<span class="comment">//Bf为B子类</span></span><br><span class="line"><span class="comment">//此处省略多个B的子类</span></span><br><span class="line">a.method(b);		<span class="comment">//method方法的参数为B类对象</span></span><br><span class="line"><span class="comment">//以上需要创建A接口类，B类，Bc类，Bd类，Be类，Bf类……等B的子类，但这些B的子类使用次数不多，甚至是一次性时，就会造成这些子类本身没什么用，而文件数量又过多</span></span><br><span class="line"></span><br><span class="line">a.method(<span class="keyword">new</span> B()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//此处省略对B函数的重写</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用匿名内部类作为参数时，也实现了子类对父类函数的重写，虽然代码量差不多，但是免去了创建无用的子类文件</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础-2</title>
    <url>/2021/07/30/Java%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类的定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量的定义</span></span><br><span class="line">    <span class="comment">//成员方法的定义（没有static关键字）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量的定义</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="comment">//成员方法的定义（没有static关键字）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendPassage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建对象：类名 对象=<span class="keyword">new</span> 类名();</span><br><span class="line">例如：Phone p=<span class="keyword">new</span> Phone();</span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

</p><p>在c++中，不重载&lt;&lt;运算符时直接输出对象会报错，但java中可以直接输出对象，得到的是对象的地址，在编译器中实际输出应该为对象的包名.类名@对象的具体地址。</p>
<p></p></div>



<h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><table>
<thead>
<tr>
<th>区别</th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中位置不同</td>
<td>类中方法外</td>
<td>方法内或声明上</td>
</tr>
<tr>
<td>内存中位置不同</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期不同</td>
<td>随对象存在和消失</td>
<td>随方法调用存在和消失</td>
</tr>
<tr>
<td>初始化值不同</td>
<td>有默认初始值</td>
<td>没有默认的初始化值，必须先定义，赋值，才能够使用</td>
</tr>
</tbody></table>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>针对不想在类外直接访问的变量或方法，可以通过将public关键字替换为private（变量省略关键字时默认是public，需要在数据类型前面添加private关键字），体现类的封装。</p>
<p><strong>封装的好处：</strong></p>
<ul>
<li>通过方法来控制成员变量的操作，提高代码的安全性</li>
<li>把代码用方法进行封装，提高了代码的复用性</li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>java中的this关键字和c++的this指针是同一个作用，用于解决局部变量隐藏成员变量，书写格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.变量名</span><br><span class="line">例如：<span class="keyword">this</span>.name</span><br></pre></td></tr></table></figure>
<p>this修饰的变量用于指代成员变量：</p>
<ul>
<li>方法的形参如果和成员变量同名，不带this修饰的变量指的是形参而不是成员变量</li>
<li>方法的形参没有和成员变量同名，不带this修饰的变量指的是成员变量</li>
</ul>
<p><strong>this代表所在类的对象引用，方法被哪个对象引用，this就代表哪个对象</strong></p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"><span class="comment">//构造方法写在类内</span></span><br><span class="line">	修饰符 类名（参数）&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和c++一样，当代码给出了任意构造方法后，系统将不再自动提供默认的无参构造</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象三大特征之一，可以使子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名</span>&#123;&#125;</span><br><span class="line">如：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">表示子类Student继承自父类Person</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：提高代码的复用性，提高代码的维护性</li>
<li>弊端：让类和类产生了关系，父类改变时子类不得不改变</li>
</ul>
<p><strong>继承中变量的访问特点：</strong></p>
<p>在子类方法中访问一个变量：</p>
<ol>
<li>在子类局部范围找</li>
<li>在子类成员范围找</li>
<li>在父类成员范围找</li>
<li>否则报错（不考虑父类的父类的继承）</li>
</ol>
<p><strong>继承中构造方法的访问特点：</strong></p>
<p>子类中所有的构造方法默认都会访问父类中无参的构造方法，理由如下：</p>
<ul>
<li>子类会继承父类中的数据，可能还会使用父类的数据，所以要先初始化父类数据</li>
<li>每一个子类构造方法的第一条语句默认都是：super（）</li>
</ul>
<p>如果父类中没有无参构造方法，只有带参构造方法：</p>
<ul>
<li>通过使用super关键字去显示的调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法（推荐）</li>
</ul>
<p><strong>继承中成员方法的访问特点：</strong></p>
<p>通过子类对象访问一个方法：</p>
<ul>
<li>子类成员范围找</li>
<li>父类成员范围找</li>
<li>否则报错（不考虑父类的父类的继承）</li>
</ul>
<h3 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h3><ul>
<li>java中类只支持单继承，不支持多继承</li>
<li>java中类支持多层继承，但变量和成员方法不考虑父类的父类</li>
</ul>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类中出现了和父类中一样的方法声明，但功能子类需要具有特有的内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类的特有内容</p>
<p>注意事项：</p>
<p>私有方法是不能被重写的（类似c++父类私有函数在子类不可见）</p>
<p>子类方法访问权限不能更低（public&gt;默认&gt;私有）</p>
<div class="tip warning"><p>

</p><p>@Override是一个方法重写的注解，可以帮助检查重写方法的方法声明的正确性</p>
<p></p></div>

<h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字的用法和this关键字的用法相似</p>
<ul>
<li><strong>this：</strong>代表本类对象的引用</li>
<li><strong>super：</strong>代表父类存储空间的标识（可以理解为父类对象引用）</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>访问成员变量</th>
<th>访问构造方法</th>
<th>访问成员方法</th>
</tr>
</thead>
<tbody><tr>
<td>this</td>
<td>this.成员变量，访问本类成员变量</td>
<td>this（…），访问本类构造方法</td>
<td>this.成员方法（…），访问本类成员方法</td>
</tr>
<tr>
<td>super</td>
<td>super.成员变量，访问父类成员变量</td>
<td>super（…），访问父类构造方法</td>
<td>super.成员方法，访问父类成员方法</td>
</tr>
</tbody></table>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为具体类多态，抽象类多态，接口多态</p>
<h3 id="多态的前提和实现"><a href="#多态的前提和实现" class="headerlink" title="多态的前提和实现"></a>多态的前提和实现</h3><ul>
<li>有继承/实现关系</li>
<li>有方法重写</li>
<li>有父（类/接口）引用指向（子/实现）类对象</li>
</ul>
<h3 id="成员的访问特点"><a href="#成员的访问特点" class="headerlink" title="成员的访问特点"></a>成员的访问特点</h3><p>成员变量使用父类成员变量，成员方法使用子类重写的父类成员方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure>
<p>对于Animal类中不存在，但Cat类中存在的成员变量是无法使用的，因为创建的变量a是Animal类；但在Cat类中重写了Animal类的成员方法后，使用该成员方法时，将会调用Cat类重写之后的成员方法。</p>
<p>两者存在区别的原因是由于成员方法有重写而成员变量没有重写，对于Animal类和Cat类继承下来的同一个方法入口构成了类似重载的关系</p>
<h3 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h3><p>好处：提高了程序的扩展性——定义方法的时候，使用父类作为参数，在使用的时候，可以使用具体的子类型传参</p>
<p>弊端：不能使用子类的特有功能</p>
<h3 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h3><ol>
<li>向上转型——Animal a=new Cat();<ul>
<li>从子到父</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
<li>向下转型——Cat c=(Cat)a;<ul>
<li>从父到子</li>
<li>父类引用转为子类对象</li>
</ul>
</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>一个没有方法体的方法该定义为抽象方法，类中如果有抽象方法，该类必须定义为抽象类</p>
<p>java中抽象使用abstract关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//含有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法必须位于抽象类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><ul>
<li>抽象类和抽象方法必须使用abstract修饰</li>
<li>抽象类中不一定有抽象方法，但有抽象方法的一定是抽象类</li>
<li>抽象类不能实例化，即不能创建对象，它只能通过子类对象实例化</li>
<li>抽象类的子类要么重写抽象类中所有抽象方法，要么是抽象类</li>
</ul>
<h3 id="抽象类的成员特点"><a href="#抽象类的成员特点" class="headerlink" title="抽象类的成员特点"></a>抽象类的成员特点</h3><ul>
<li>成员变量：可以是变量也可以是常量</li>
<li>构造方法：有构造方法，但不能实例化，构造方法用于子类访问父类数据的初始化</li>
<li>成员方法：可以有抽象方法，限定子类必须具有某些方法，也可以有非抽象方法，用于提高代码复用性</li>
</ul>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-4</title>
    <url>/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/</url>
    <content><![CDATA[<h1 id="AI（未完待续）"><a href="#AI（未完待续）" class="headerlink" title="AI（未完待续）"></a>AI（未完待续）</h1><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><h3 id="AI控制器"><a href="#AI控制器" class="headerlink" title="AI控制器"></a>AI控制器</h3><p>用于控制非玩家角色行动，UE4中的AI具有感知系统，即视听等感知组件</p>
<h3 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h3><p>在对应黑板上录入的变量都会作为行为树的全局变量，其中的变量称作键，通过细节面板可以命名及指定键的类型</p>
<h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h3><p>决定AI行为走向和思维模式的流程树，创建后有默认根节点，决定AI思维关系的主要是以下节点（来自官方文档）</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/25.png" alt="25"></p>
<p>可以理解为，选择器会从它的子树中选择能够执行的子树执行，直到子树执行结束，则回到选择器重新选择；序列则从左到右依次执行每个子树，直到遇到执行失败的节点则停止；简单平行的两个连接将并行处理，依据设置可以决定在主任务完成后结束或是等待支线任务完成才结束。</p>
<p>在节点上右击可添加对节点的装饰器，即需要满足装饰器的条件，才能够执行该节点</p>
<p>对于装饰器中的“观察者中止”一项，官方文档的说明如下：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/33.png" alt="33"></p>
<p>此项针对的是装饰器修饰的节点A是否优先执行，若装饰器满足条件，选择self项时，即使A自身和A的子树在执行，两者也会中止执行，优先执行A节点；选择lower priority时，只有节点A右边的所有节点会中止执行，优先执行A节点及子树；选择both时，则同时中止A的子树和A右面的所有节点，优先执行A节点</p>
<h2 id="寻路导航创建"><a href="#寻路导航创建" class="headerlink" title="寻路导航创建"></a>寻路导航创建</h2><p>所有AI寻路功能都需要创建寻路导航，可在主面板左上角的“放置actor”面板中找到“导航网格体边界体积”，放入场景中</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/1.png" alt="1"></p>
<p>调整体积大小，将需要建构导航的场景放入该体积</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/2.png" alt="2"></p>
<p>点击构造后生成类似如图的绿色地面区域，这片区域为AI导航有效的区域</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/3.png" alt="3"></p>
<h2 id="实例：实现敌对NPC追踪角色移动"><a href="#实例：实现敌对NPC追踪角色移动" class="headerlink" title="实例：实现敌对NPC追踪角色移动"></a>实例：实现敌对NPC追踪角色移动</h2><p>思路：使用AI控制器沿创建好的导航移动敌对NPC，目标为玩家控制的角色，并循环操作</p>
<p>关卡蓝图：实现进入该关卡时，所有敌方npc无条件执行“移动”节点，即无条件自动追逐玩家</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/8.png" alt="8"></p>
<p>敌对NPC角色蓝图：实现敌对NPC追逐玩家的效果，即动态追踪玩家并移动到玩家当前的位置</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/4.png" alt="4"></p>
<h2 id="实例：实现敌对NPC的巡逻"><a href="#实例：实现敌对NPC的巡逻" class="headerlink" title="实例：实现敌对NPC的巡逻"></a>实例：实现敌对NPC的巡逻</h2><p><strong>思路：</strong>通过行为树和黑板，使AI控制器控制敌对NPC完成”巡逻——发现敌人则追逐——丢失目标则继续巡逻“</p>
<p>【以下为UE5试用版界面，可能与UE4有些许不同】</p>
<p><strong>创造文件及名称：</strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/17.png" alt="17"></p>
<p><strong>巡逻AI控制器：</strong></p>
<p>要使AI控制器具有视野范围就必须先具有感知组件</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/35.png" alt="35"></p>
<p>感知组件的细节配置如下</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/36.png" alt="36"></p>
<p>控制器事件蓝图内容如下</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/18.png" alt="18"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/19.png" alt="19"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/20.png" alt="20"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/21.png" alt="21"></p>
<p><strong>EnemyCharacter:</strong></p>
<p>敌方NPC的角色蓝图，不需要写入额外的内容，一般只需要将移动组件的最大行走速度设置为比玩家角色稍慢即可，便于玩家角色能够甩开NPC的追逐</p>
<p><strong>EnemyBoard：</strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/23.png" alt="23"></p>
<p>其中只有TargetActor的键类型基类需要设为actor，其他两个键使用默认设置</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/24.png" alt="24"></p>
<p><strong>EnemyBehaviorTree：</strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/31.png" alt="31"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/26.png" alt="26"></p>
<p>其中，改变行走速度（ChangeSpeed）和改变巡逻点（ChangeFollowPoint）两者为自行编写的任务蓝图，创建空白蓝图方法如下：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/27.png" alt="27"></p>
<p>节点“发现敌人”的装饰器设置如下：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/32.png" alt="32"></p>
<p><strong>ChangeSpeed</strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/28.png" alt="28"></p>
<p><strong>ChangeFollowPoint</strong></p>
<p>该蓝图中用到的新建变量如下</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/30.png" alt="30"></p>
<p>蓝图具体内容如下</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/29.png" alt="29"></p>
<h2 id="实例：实现敌对NPC失去目标后尝试寻找玩家"><a href="#实例：实现敌对NPC失去目标后尝试寻找玩家" class="headerlink" title="实例：实现敌对NPC失去目标后尝试寻找玩家"></a>实例：实现敌对NPC失去目标后尝试寻找玩家</h2><p><strong>思路：</strong>在实现巡逻的基础上通过为敌对NPC增加EQS（环境查询系统），实现玩家在离开敌对NPC感知范围后，NPC仍然会试图搜寻玩家位置</p>
<p><strong>新创建的文件：</strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/37.png" alt="37"></p>
<p><strong>前置工作：</strong>在使用EQS之前，首先需要在项目设置中启用EQS</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/38.png" alt="38"></p>
<h2 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h2><div class="tip warning"><p>

</p><p>在运行场景时，可使用键盘上的引号键【‘】呼出AI面板，在AI面板下按小键盘的4键，可查看AI的感知范围</p>
<p></p></div>

<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/34.png" alt="34"></p>
<h1 id="动画序列与蓝图"><a href="#动画序列与蓝图" class="headerlink" title="动画序列与蓝图"></a>动画序列与蓝图</h1><h2 id="过场动画制作"><a href="#过场动画制作" class="headerlink" title="过场动画制作"></a>过场动画制作</h2><p>创建一个过场动画的关卡序列，命名并打开操作界面</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/9.png" alt="9"></p>
<p>新建一个相机剪切轨道，并且绑定用于拍摄过场动画的电影摄像机actor（或是直接在场景中选中指定相机，通过actor到sequencer直接添加），将相机移动到起始位置，添加变换轨道（或其他轨道）并在起始位置添加关键帧</p>
<p>制作动画时，其他actor也可添加移动轨道，详细在下一个子目录“动画轨道”中</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/10.png" alt="10"></p>
<p>多次移动相机到指定位置，并在轨道上添加相应的关键帧（场景中能够看到相机移动的轨迹呈现），最后调整动画结束的准线，结束修改并保存</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/12.png" alt="12"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/11.png" alt="11"></p>
<p>当拍摄多个动画后，可将需要拼接的动画放入一个新的关卡序列中，上下移动调整轨道，左右移动调整播放顺序，并将结束准线对齐</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/13.png" alt="13"></p>
<p>多段动画中间可建立渐变轨道的关键帧，实现切换的淡入淡出</p>
<h2 id="动画轨道"><a href="#动画轨道" class="headerlink" title="动画轨道"></a>动画轨道</h2><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/14.png" alt="14"></p>
<p>Actor到Sequencer：创建一个控制actor的轨道，在场景中选中的actor会优先显示在顶端**<em>（创建actor后一般自带一个控制actor移动的transfrom轨道，也可以自己添加变换轨道）**</em></p>
<p>添加文件夹：可为多个轨道分类，放置于不同的文件夹下（好像没什么用的样子）</p>
<p>音频轨道：可在动画播放同时添加音频资产的播放</p>
<p>事件轨道：分为触发器和中继器（后者不常用），触发器轨道中添加了关键帧后，右键新建末端可新建图表事件，当时间轴移动到指定位置执行该事件</p>
<p>相机剪切轨道：用于添加相机轨道，使用actor到sequencer添加时也会自动创建</p>
<p>镜头轨道：用于拼接多个镜头的轨道，也可以实现多个动画序列之间的拼接</p>
<p>时间膨胀轨道：用于设置播放倍率的关键帧，实现部分慢镜头和快进</p>
<p>渐变轨道：添加动画的黑幕（1为全黑，0为透明），多个关键帧可实现淡入淡出</p>
<p><strong><em>【注：如果在单独一个元件下添加轨道，则所有轨道都作为其子元件，该元件的组件也可以实现调用为子元件，同时，在单一元件下还能够创建可视性轨道，调整特定时间下的actor是否可见。</em></strong></p>
<p><strong><em>特别地，对于相机actor来说，需要先获取CameraComponent子元件才能够更改具体具体属性（如：曝光补偿等）】</em></strong></p>
<h2 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h2><p>【需要创建蓝图类-MatineeCameraShake文件】</p>
<h4 id="振荡设置"><a href="#振荡设置" class="headerlink" title="振荡设置"></a>振荡设置</h4><p>振荡时长：振荡的总时长</p>
<p>振荡混入时间：振荡开始的时间</p>
<p>振荡混出时间：振荡结束的时间</p>
<p>旋转振荡：实现镜头的各方位旋转振荡（如决定上下振荡或者左右振荡，或者两者混合等）</p>
<p>位置振荡：实现镜头的移动性振荡（如决定相机位置前后振荡等）</p>
<p>FOV振荡：实现镜头的缩放性振荡（相机位置不变，只是镜头缩放）</p>
<h4 id="具体蓝图使用"><a href="#具体蓝图使用" class="headerlink" title="具体蓝图使用"></a>具体蓝图使用</h4><ol>
<li><p>在需要使用的蓝图流程中加入以下结点</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/15.png" alt="15"></p>
</li>
</ol>
<ol start="2">
<li><p>在动画序列中相机组件下添加相机晃动子元件，可以拖拽缩放抖动条</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/16.png" alt="16"></p>
</li>
</ol>
<h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p>打开某个骨骼/网格体/动画序列/物理模型时，可在右上角看到动画蓝图标识</p>
<p><strong><em>【注：此处以第三人称游戏模板的小白人为例】</em></strong></p>
<p>打开默认的动画图表【AnimGraph】，找到默认状态机，双击打开</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/5.png" alt="5"></p>
<p>状态机内部蓝图：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-1.png" alt="6-1"></p>
<p>Entry为一个输入/起始点，Idle/Run节点为走或跑时，JumpStart、Loop、End分别为跳跃的开始，腾空，落地过程，四个节点分别播放不同的动画，双箭头为四个节点互相切换的条件（右键添加状态可添加节点，通过节点引线引出的新节点与原节点之间自带转换条件）</p>
<p>Idle/Run节点内部：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-2.png" alt="6-2"></p>
<p>此处混合空间播放器节点下方为一段动画，具有三个白色关键帧（第一个与绿色关键帧重合），由绿色关键帧的位置（speed的大小）决定播放的动画，而在动画播放时，绿色关键帧如果未到达下一个白色关键帧，将循环播放上一个白色关键帧的动画</p>
<p>JumpStart、Loop、End节点内部：</p>
<p><strong><em>【注：因为结构相同故而使用JumpStart作为范例】</em></strong></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-3.png" alt="6-3"></p>
<p>由Idle/Run节点到JumpStart与从JumpLoop到JumpEnd节点的切换条件：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-5.png" alt="6-5"></p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-6.png" alt="6-6"></p>
<p>前者：判断角色是否在空中，如果是，转换到下一个节点（即JumpStart节点）</p>
<p>后者：判断角色是否不在空中，如果是，转换到下一个节点（即JumpEnd节点）</p>
<p>由JumpStart到JumpLoop与由JumpEnd到Idle/Run节点的转换条件：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-4.png" alt="6-4"></p>
<p>判断前一个节点（JumpStart或JumpEnd）中动画资产播放的剩余时间是否小于0.1，如果是，则转换到下一个节点（JumpLoop或Idle/Run）</p>
<p>动画蓝图事件图表：</p>
<p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/7.png" alt="7"></p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>网页设计-5</title>
    <url>/2021/06/21/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-5/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript是一种web页面中的脚本编程语言，不需要编译，而是直接嵌入到html页面中，完成动态网页的交互并响应事件，能够实现页面加载完成或单击某个元素时调用指定的JavaScript，或者是读取和改变当前页面某个元素的内容，在提交数据前进行数据的检测，亦或是检测访问者的浏览器，创建cookies等。</p>
<h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>JavaScript插入到html文档中有两种方法：</p>
<p>1.直接在html中插入行内javascript</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">/*插入的JavaScript语句*/</span></span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.在html中导入一个javascript文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js文件路径&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript中基本的数据类型有以下几种：</p>
<p>数值型：可以有小数点也可以没有</p>
<p>字符串型：用引号引起来的文本</p>
<p>null类型：表示未赋值的项，只有null一种取值，引用一个没有定义的变量将会返回null</p>
<p>undefined类型：用于确定一个已经创建但没有初值的变量</p>
<p>string对象的属性与方法的使用：参考c++类的对象获取对象属性和调用类的成员函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串对象名.字符串属性名；</span><br><span class="line">字符串对象名.字符串方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure>
<p>math对象的属性与方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">math.属性名</span><br><span class="line">math.方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>网页设计</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-7</title>
    <url>/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/</url>
    <content><![CDATA[<h1 id="图（多对多关系）"><a href="#图（多对多关系）" class="headerlink" title="图（多对多关系）"></a>图（多对多关系）</h1><h2 id="定义及名词解释"><a href="#定义及名词解释" class="headerlink" title="定义及名词解释"></a>定义及名词解释</h2><ul>
<li><strong>图：</strong>顶点的有穷非空集合和边的集合，常用G表示一个图，V表示顶点集合，E是边的集合，其中图至少有一个顶点，且顶点数量为有限个，边的集合可以为空</li>
<li><strong>有向图和无向图：</strong>图按有无方向可以分为无向图和有向图，无向图称顶点和边，有向图中称顶点和弧，箭头指向的一方为弧头</li>
<li><strong>稀疏图和稠密图：</strong>图按边和弧的多少分稀疏图和稠密图</li>
<li><strong>完全图和简单图：</strong>任意两个顶点间都存在边叫完全图，无重复边或顶点到自身的边叫简单图</li>
<li><strong>度、出度、入度：</strong>图中顶点有邻接点、依附的概念，无向图顶点边数叫度，有向图顶点分出度和入度</li>
<li><strong>网：</strong>当图的边或弧带有权值，则称其为网</li>
<li><strong>环/回路和简单路径：</strong>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复的叫简单路径</li>
<li><strong>连通图：</strong>若任意两顶点都是连通的，则图就是连通图，有向图称为强连通图</li>
<li><strong>连通分量：</strong>图中有子图，若子图达到极大连通则就是连通分量，有向图中称为强连通分量</li>
<li><strong>生成森林和有向树：</strong>无向图中连通且n个顶点n-1条边称为生成树，有向图中一顶点入度为0其余顶点入度为1的叫有向树，一个有向图由若干棵有向树构成生成森林</li>
</ul>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>可表示为一个二维数组，如图所示</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/1.jpg" alt="1"></p>
<ol>
<li><p>当图为无向图时，默认为双向，即整个矩阵沿对角线对称</p>
</li>
<li><p>当图为有向图时，由a指向b的边将在矩阵中以array【a】【b】=1的方式表示</p>
</li>
<li><p>当图不带权值时，1表示两点连通，0表示不连通</p>
</li>
<li><p>当图带权值时，连通时矩阵中的值为两点间的权值，点和它自己标为0，不连通的两点标为无穷</p>
</li>
</ol>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>以一维数组存储顶点值，并各自作为头结点，连接其邻接元素的链表，如图所示</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/2.jpg" alt="2"></p>
<p>其中链表结点的顺序是不固定的，不一定要按顺序排列，而链表部分中，结点的adjvex区域存储的是头结点元素的邻接元素的下标，而不是具体元素的值</p>
<h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/3.jpg" alt="3"></p>
<p>十字链表是有向图的链式存储，结合了有向图的邻接表和逆邻接表</p>
<p>一维数组存储了顶点的值，并作为后续链表的头结点，出弧指针域指向邻接元素（如上图的v0的出弧指针域指向存有弧尾0，弧头1的结点），而入弧指针域指向有弧指向头结点的元素（如上图中的v0的入弧指针域指向存有弧尾2，弧头0的结点）</p>
<p>在非头结点的结点内部，存有弧头和弧尾元素的下标，以及指向弧头相同的其他结点和弧尾相同的其他结点的指针</p>
<h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/4.gif" alt="4"></p>
<p>邻接多重表是针对无向图和无向网的，可看作是邻接表和十字链表的结合</p>
<p>以一维数组存储了顶点的值，并作为后续链表的头结点，非头结点的结点中包括用于标记是否被操作过的标志域(mark)，存储图中边两端的顶点下标的数据域（ivex和jvex，顺序不分），以及指向同一个ivex和同一个jvex的其他结点的指针域（ilink和jlink，顺序不分），除此之外，有时还多设一个用于存储边的权值的数据域</p>
<p>由于邻接多重表的空间利用率过低，最好还是使用邻接表和邻接矩阵</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历类似于树的先序遍历，大致思路以下图为例</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/5.png" alt="5"></p>
<ol>
<li>任意取一个未被遍历过的顶点（如v1），标记为已访问</li>
<li>遍历v1的邻接点（如v2），并标记为已访问，逐步向下，遍历v2的邻接点，即v4，然后访问v8，再访问v5，都标记为已访问</li>
<li>当遍历v5的邻接点时，v2和v8都已经被标记为已访问，故而回退到v8，同理回退到v4，v2，最后到v1</li>
<li>在v1处找到未访问的顶点v3，故而停止回退，继续遍历v3的邻接点v6，然后v7</li>
<li>遍历v7的邻接点都已经被访问，于是回退到v6，v3，最后回到v1</li>
<li>判断是否所有顶点都被访问，如果还有未被访问的，继续按照以上方法访问，否则结束遍历</li>
</ol>
<p><strong>深度优先遍历总的来说是个不断回溯的过程</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//标记为true</span></span><br><span class="line">    visitVex( G,  v); <span class="comment">//访问第v 个顶点</span></span><br><span class="line">    <span class="comment">//从该顶点的第一个边开始，一直到最后一个边，对处于边另一端的顶点调用DFS函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstAdjVex(G,v); w&gt;=<span class="number">0</span>; w = NextAdjVex(G,v,w))&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位false，证明未被访问，调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位为false，则调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            DFS( G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    DFSTraverse(G);<span class="comment">//深度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历类似于树的层次遍历，即从某一个顶点开始，遍历其所有邻接点，然后再顺序遍历这些邻接点的所有邻接点，直到所有邻接的顶点被访问后，判断图中是否还有未被访问的结点，若有则重复以上过程</p>
<p>广度优先遍历的实现借助了队列的结构，实现代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作顶点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue ** Q)</span></span>&#123;</span><br><span class="line">    (*Q)=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    (*Q)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点元素v进队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Queue **Q,VertexType v)</span></span>&#123;</span><br><span class="line">    Queue * element=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    element-&gt;data=v;</span><br><span class="line">    Queue * temp=(*Q);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头元素出队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue **Q,<span class="keyword">int</span> *u)</span></span>&#123;</span><br><span class="line">    (*u)=(*Q)-&gt;next-&gt;data;</span><br><span class="line">    (*Q)-&gt;next=(*Q)-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue *Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    Queue * Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            visited[v]=<span class="literal">true</span>;</span><br><span class="line">            visitVex(G, v);</span><br><span class="line">            EnQueue(&amp;Q, G.vexs[v]);</span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">                <span class="keyword">int</span> u;</span><br><span class="line">                DeQueue(&amp;Q, &amp;u);</span><br><span class="line">                u=LocateVex(&amp;G, u);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w=FirstAdjVex(G, u); w&gt;=<span class="number">0</span>; w=NextAdjVex(G, u, w)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                        visited[w]=<span class="literal">true</span>;</span><br><span class="line">                        visitVex(G, w);</span><br><span class="line">                        EnQueue(&amp;Q, G.vexs[w]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    BFSTraverse(G);<span class="comment">//广度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h3><p>普里姆算法（Prim算法）或称DJP算法，可在加权连通图里搜索最小生成树。由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.png" alt="6"></p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.jpg" alt="6"></p>
<h3 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h3><p>克鲁斯卡尔算法从边的角度求网的最小生成树，和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树</p>
<p>对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择</p>
<p>由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点：</p>
<ul>
<li>生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路</li>
<li>对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点</li>
</ul>
<p><strong>连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边</strong></p>
<p>所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。</p>
<div class="tip warning"><p>

</p><p>判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。</p>
<p></p></div>

<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/7.png" alt="7"></p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/8.png" alt="8"></p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/9.png" alt="9"></p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/10.png" alt="10"></p>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<p><strong>操作步骤</strong></p>
<ol>
<li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]</li>
<li>从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k</li>
<li>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离</li>
<li>重复步骤(2)和(3)，直到遍历完所有顶点</li>
</ol>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/11.jpg" alt="11"></p>
<h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法是一种在具有正或负边缘权重（但没有负环）的加权图中找到最短路径的算法，即支持负权值但不支持负权环。</p>
<p>相较而言，迪杰斯特拉计算的是单源最短路径，而弗洛伊德计算的是多源最短路径，其时间复杂度为O(n³)。虽然它不返回路径本身的细节，但是可以通过对算法的简单修改来重建路径，我们利用这个思想，通过递归的方式访问每条路径经过的中间节点，对最终的路径进行输出。</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/12.jpg" alt="12"></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对一个<strong>有向无环图</strong>进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。<br>在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列，由AOV网构造拓扑序列的过程叫做拓扑排序。<strong>AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。</strong></p>
<p>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止：</p>
<ol>
<li>选择一个入度为0的顶点并输出</li>
<li>从网中删除此顶点及所有出边</li>
</ol>
<p>循环结束后，若输出的顶点数小于网中的顶点数，则有回路，否则输出的顶点序列就是一种拓扑序列。</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/13.jpg" alt="13"></p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>在AOE网中，从始点到终点具有最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径，通过优化关键路径能够实现有效的程序优化，<strong>同拓扑排序一样，关键路径也不是唯一的</strong>。</p>
<p>由于AOE网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</p>
<p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/14.jpg" alt="14"></p>
<p>如图，由v1到v9即一条关键路径，其关键路径长度为29，当其他路线中边的权值相加相等时，图中也可能出现多条关键路径</p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-10:关联式容器STL set</title>
    <url>/2021/06/04/c++%E5%AD%A6%E4%B9%A0-14/</url>
    <content><![CDATA[<h1 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>对于set容器来说，只能存储键与值相等的数据，无法实现如map容器那样的存储，并且set容器的数据并没有强制性的const修饰，但c++标准也对此做出了限制以免用户修改set容器中的数据，由于这些限制，在修改其元素时，应先删除该元素，再插入修改后的元素，以免破坏set容器的有序性</p>
<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1</td>
</tr>
</tbody></table>
<h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>set 容器配置的迭代器类型为双向迭代器。即若 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符</p>
<p>且set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器，成员函数如下：</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td>
</tr>
</tbody></table>
<div class="tip warning"><p>
注：以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。

</p></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.insert(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.begin(); iter != myset.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>1、myset size = 0<br>2、myset size = 3<br>a<br>b<br>c</p>
<p></p></div>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-7:序列式容器STL list</title>
    <url>/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/</url>
    <content><![CDATA[<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>list容器，又称双向链表容器，底层实现为双向链表形式，元素可分散存储在内存空间中，前后顺序靠指针维系，每个元素都配备指向前驱和后继的两个指针，第一个元素前驱为NULL，最后一个元素后继为NULL</p>
<p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/1.jpg" alt="1"></p>
<p>list容器可以在序列已知的任何位置快速插入和删除元素，并且在list容器中移动元素的效率也比其他容器高，但它不能直接通过位置访问元素，而是需要顺序遍历前面的所有元素直到找到该位置</p>
<p>所以当需要对序列大量添加、删除元素，却不常直接访问元素数据时，list容器最为高效适用，其创建如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;	<span class="comment">//创建空list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//创建包含10个元素的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;	<span class="comment">//创建包含10个元素且初值为5的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value3</span><span class="params">(value1)</span></span>;	<span class="comment">//拷贝创建一个和value1一样的list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;	<span class="comment">//拷贝普通数组创建list 容器</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt;arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values(arr.begin()+<span class="number">2</span>, arr.end());	<span class="comment">//拷贝其它容器，创建list 容器</span></span><br></pre></td></tr></table></figure>


<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前容器实际包含的元素个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素，该函数和 push_front() 的功能相同，但效率更高</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素，该函数和 push_back() 的功能相同，但效率更高</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素，该函数和 insert() 功能相同，但效率更高</td>
</tr>
<tr>
<td>insert()</td>
<td>在容器中的指定位置插入元素</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序</td>
</tr>
</tbody></table>
<h2 id="list容器迭代器"><a href="#list容器迭代器" class="headerlink" title="list容器迭代器"></a>list容器迭代器</h2><p>list容器的迭代器相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p>
<p><strong>但list容器配备的迭代器类型为双向迭代器，不再是之前的随机访问迭代器</strong></p>
<p>这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1–、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：</p>
<ul>
<li>p1[i]：不能通过下标访问 list 容器中指定位置处的元素</li>
<li>双向迭代器不支持使用 -=、+=、+、- 运算符</li>
<li>双向迭代器不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li>
</ul>
<div class="tip warning"><p>

</p><p>list容器在插入insert（）、接合splice（）等操作时不会造成原有list迭代器失效，删除操作时也仅有指向被删除元素的迭代器失效，其他迭代器不受影响</p>
<p></p></div>

<h2 id="访问list容器"><a href="#访问list容器" class="headerlink" title="访问list容器"></a>访问list容器</h2><p>由于list容器不支持随机访问，未提供下标操作符[ ]和at（）成员函数，也没有data（）成员函数，只能使用front（）成员函数和back（）成员函数，用于返回list容器中第一个元素和最后一个元素的引用</p>
<p>如果想要访问list容器存储的其他元素，只能使用list容器的迭代器，例如:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于修改容器中指定元素的值，list模板类提供专门的成员函数assign（）：</p>
<ul>
<li>assign(count, value) ：其中count是值的个数，value是分配给元素的值</li>
<li>assign(begin，end)：其中begin为起始位置，end为结束位置，常作将元素从已有列表复制过来，并覆盖该列表原来的元素值</li>
</ul>
<p>除此之外，assign（）函数还可以实现不同容器之间，相容类型的赋值或者是对不能使用赋值符“=”进行赋值的数据类型赋值</p>
<h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>list容器中，通用的增添元素方法依旧适用，如：</p>
<ul>
<li>push_front()：向 list 容器首个元素前添加新元素</li>
<li>push_back()：向 list 容器最后一个元素后添加新元素</li>
<li>emplace_front()：在容器首个元素前直接生成新的元素</li>
<li>emplace_back()：在容器最后一个元素后直接生成新的元素</li>
<li>emplace()：在容器的指定位置直接生成新的元素</li>
<li>insert()：在指定位置插入新元素</li>
</ul>
<p>而除deque等容器增删元素的方法外，list容器还有一个成员函数splice（），用于将其他list容器存储的多个元素添加到当前list容器的指定位置</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void splice (iterator position, list&amp; x);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator i);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td>
</tr>
<tr>
<td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td>
<td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td>
</tr>
</tbody></table>
<div class="tip warning"><p>

</p><p>splice() 成员方法移动元素的方式，是将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中，也就是当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除，实现的过程相当于是“剪切”而不是“复制”</p>
<p></p></div>



<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>list容器中，通用的删除元素方法依旧适用，如：</p>
<ul>
<li>pop_front()    删除位于 list 容器头部的一个元素</li>
<li>pop_back()    删除位于 list 容器尾部的一个元素</li>
<li>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</li>
<li>clear()    删除 list 容器存储的所有元素</li>
</ul>
<p>而list容器中新增的方法成员函数有：</p>
<ul>
<li>remove(val)    删除容器中所有等于 val 的元素</li>
<li>remove_if()    删除容器中满足条件的元素</li>
<li>unique()    删除容器中相邻的重复元素，只保留一份</li>
</ul>
<p>其中unique（）可以直接无参使用，也可以自定义传入一个二元谓词函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span>	<span class="comment">//二元谓词函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(first) == <span class="keyword">int</span>(second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">4.6</span> &#125;;</span><br><span class="line">    <span class="comment">//删除相邻重复的元素，仅保留一份</span></span><br><span class="line">    mylist.unique();<span class="comment">//&#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//demo 为二元谓词函数，是自定义的去重规则</span></span><br><span class="line">    mylist.unique(demo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>
1 1.2 3 4 4.5 4.6
1 3 4

</p></div>
<div class="tip warning"><p>

</p><p>谓词函数是一个判断式，一个返回bool值的函数或者仿函数。几元就是函数有几个参数，至于定义和使用，函数定义和一般的函数定义一样，仿函数就是写个类，然后重载operator()。可以在需要返回bool值的函数作参数的函数里使用。</p>
<p></p></div>

<p>此外，将自定义的谓词函数传给remove_if()成员函数，list容器中能使函数成立的元素都会被删除：</p>
<p>remove_if(begin,end,op)：其中begin是起始位置，end为结束位置，op为传入的回调函数，如果返回true，则将当前指向的参数移到尾部（故而需要和erase一起使用才能真正删除元素），其返回值为被移动区域的首个元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">15</span>, <span class="number">36</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 mylist 容器中能够使表达式成立的所有元素</span></span><br><span class="line">    mylist.remove_if([](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> (value &lt; <span class="number">10</span>); &#125;); <span class="comment">//&#123;15 36 17 20 39&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>
15 36 17 20 39
</p></div>

<div class="tip warning"><p>

</p><p>回调函数就是一个被作为参数传递的函数。上述代码中，mylist.remove_if( [ ] (int value) {return (value &lt; 10); });相当于前两个参数默认使用了mylist的begin和end位置，回调函数的参数是int类型的value，当value&lt;10时，回调函数将返回这个表达式的值（false/true）</p>
<p></p></div>



<h2 id="更加高效的list——forward-list"><a href="#更加高效的list——forward-list" class="headerlink" title="更加高效的list——forward_list"></a>更加高效的list——forward_list</h2><p>forward_list是c++11标准新添加的一类容器，底层实现和list一样采用链表，但采用的是单链表（相邻元素间只有从前驱指向后驱的指针），list采用的是双链表（相邻元素间有从前向后的指针，也有从后向前的指针）</p>
<p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/2.gif" alt="2"></p>
<p>相较list，forward_list同样擅长在序列的任何位置进行插入或删除，而不擅长随机访问元素，而且由于指针从前驱指向后驱，所以配备的迭代器也只有前向迭代器，而不是双向迭代器</p>
<p>使用forward_list的意义主要是效率高，且在存储相同个数元素时单链表所用空间更少，空间利用率更高，对于某些操作的执行效率也更高，故当list和forward_list都能完成时，应该首选forward_list容器</p>
<p>以下为forward_list的成员函数：</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>before_begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td>
</tr>
<tr>
<td>begin()</td>
<td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td>
</tr>
<tr>
<td>end()</td>
<td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td>
</tr>
<tr>
<td>cbefore_begin()</td>
<td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换容器中原有内容。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>insert_after()</td>
<td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td>
</tr>
<tr>
<td>erase_after()</td>
<td>删除容器中某个指定位置或区域内的所有元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>resize()</td>
<td>调整容器的大小。</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器存储的所有元素。</td>
</tr>
<tr>
<td>splice_after()</td>
<td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序</td>
</tr>
</tbody></table>
<p>如上，forward_list容器迭代器的移动除了使用++运算符单步移动之外，还能使用advance()函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.begin();</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，在forward_list容器中是没有提供size（）函数的，想要获取forward_list容器中的存储元素的个数，可以使用头文件&lt; iterator &gt;中的distance（）函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = distance(begin(my_words),end(my_words));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">list的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul>
<li>list&lt;数据类型&gt; 容器名：创建空list容器</li>
<li>list&lt;数据类型&gt; 容器名(n, a)：创建包含n个元素，初值为a的容器（a可省略）</li>
<li>list&lt;数据类型&gt; 容器名(另一个容器名)：拷贝另一个容器创建list</li>
<li>list&lt;数据类型&gt; 容器名(begin迭代器, end迭代器)：拷贝区间内元素创建list</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul>
<li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li>
<li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li>
<li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li>
<li>不能通过下标访问 list 容器中指定位置处的元素</li>
<li>不支持使用 -=、+=、+、- 运算符</li>
<li>不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul>
<li>front（）和back（）函数——返回容器中第一个和最后一个元素的引用</li>
<li>因为存储空间不连续不能使用指针，而只能使用list的迭代器访问</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>添加元素：</p>
<ul>
<li>push_front()：向 list 容器首个元素前添加新元素</li>
<li>push_back()：向 list 容器最后一个元素后添加新元素</li>
<li>emplace_front()：在容器首个元素前直接生成新的元素</li>
<li>emplace_back()：在容器最后一个元素后直接生成新的元素</li>
<li>emplace()：在容器的指定位置直接生成新的元素</li>
<li>insert()：在指定位置插入新元素</li>
<li>splice()：将其他 list 容器存储的多个元素剪切到当前 list 容器的指定位置处</li>
</ul>
<p>删除元素：</p>
<ul>
<li><p>pop_front()    删除位于 list 容器头部的一个元素</p>
</li>
<li><p>pop_back()    删除位于 list 容器尾部的一个元素</p>
</li>
<li><p>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</p>
</li>
<li><p>clear()    删除 list 容器存储的所有元素</p>
</li>
<li><p>remove(val)    删除容器中所有等于 val 的元素</p>
</li>
<li><p>remove_if()    删除容器中满足条件的元素</p>
</li>
<li><p>unique()    删除容器中相邻的重复元素，只保留一份，可以直接无参使用，也可以自定义传入一个二元谓词函数</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.push_back(<span class="number">3.1</span>);</span><br><span class="line">    values.push_back(<span class="number">2.2</span>);</span><br><span class="line">    values.push_back(<span class="number">2.9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.sort();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>values size：3<br>2.2 2.9 3.1</p>
<p></p></div>

<br>

<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//使用begin()/end()迭代器函数对输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::reverse_iterator it = values.rbegin(); it != values.rend();++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p><a href="http://c.biancheng.net/">http://c.biancheng.net</a><br>ten.gnehcnaib.c//:ptth</p>
<p></p></div>

<br>

<br>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 2 个 list 容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ++mylist1.begin(); <span class="comment">//指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    mylist1.splice(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(), mylist1.end());<span class="comment">//mylist1:</span></span><br><span class="line">                                                                             <span class="comment">//mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mylist2 容器中存储的数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.begin(); iter != mylist2.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>mylist1 包含 0个元素<br>mylist2 包含 7个元素<br>mylist2:1 10 20 30 3 4 2</p>
<p></p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-9:关联式容器STL multimap</title>
    <url>/2021/06/03/c++%E5%AD%A6%E4%B9%A0-13/</url>
    <content><![CDATA[<h1 id="multimap容器"><a href="#multimap容器" class="headerlink" title="multimap容器"></a>multimap容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对</p>
<p>同map一样，multimap定义时一样有四个参数值，键的类型，值的类型，排序规则，分配器对象的类型</p>
<p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p>
<ol>
<li>通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">&quot;1a&quot;</span>,<span class="string">&quot;a1&quot;</span>&#125;,&#123;<span class="string">&quot;2b&quot;</span>,<span class="string">&quot;b2&quot;</span>&#125;,&#123;<span class="string">&quot;3c&quot;</span>,<span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>&#123;key, value&#125;</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p>
<p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(mymultimap);</span><br></pre></td></tr></table></figure>
<p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p>
<p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multimap&lt;string, string&gt; dismultimap() &#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;tempmultimap&#123; </span><br><span class="line">        &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(dismultimap());</span><br></pre></td></tr></table></figure>
<p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数</p>
<blockquote>
<p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致</p>
</blockquote>
<ol start="4">
<li>multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(++mymultimap.begin(), mymultimap.end());</span><br></pre></td></tr></table></figure>
<p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器</p>
<ol start="5">
<li>前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>mymultimap 容器中键值对的存储顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a,1&gt;</span><br><span class="line">&lt;b,2&gt;</span><br></pre></td></tr></table></figure>

<p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>,greater&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>其内部键值对的存储顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b,2&gt;</span><br><span class="line">&lt;a,1&gt;</span><br></pre></td></tr></table></figure>


<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 multimap 容器中存有键值对的个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td>
</tr>
<tr>
<td>insert()</td>
<td>向 multimap 容器中插入键值对</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回</td>
</tr>
</tbody></table>
<p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个<br>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到</p>
<p>值得一提的是，对multimap容器提供的所有函数，map容器都提供，并且其用法相同，所以具体用法直接参见map容器的成员函数说明即可</p>
<p>点击链接跳转：<a href="https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/">https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</a></p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.count(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.begin(); iter != mymultimap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>



</p><p>4<br>2<br>a 10<br>b 20<br>b 15<br>c 30</p>
<p></p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-8:关联式容器STL map</title>
    <url>/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</url>
    <content><![CDATA[<h1 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>map容器是关联式容器的一种，存储的全都是pair对象，即用pair类模板创建的键值对，其中各个键值对的键和值可以是任何数据类型，包括基本数据类型或结构体或自定义的类，通常来说，map容器中各个键值对都选用string字符串作为键的类型</p>
<p><strong>map容器会根据键的大小将元素按既定顺序排列</strong>，默认使用less&lt; T &gt;排序规则，会根据键的大小对所有键值作升序排序，但也可以手动指定或自定义这种排序规则</p>
<p><strong>对于map容器中的键值对来说，键的值不可以重复也不能修改</strong>，即每个键都是独一无二的对应一个元素，且类型使用const修饰</p>
<p>map容器定义在头文件&lt; map &gt;中，其容器模板有键类型、值类型、排序规则、分配器对象的类型，以上4个参数，其中后两者都有默认值，最后一个参数几乎不会用到</p>
<p>其中，已有可供修改的排序规则包括：greater&lt; T&gt;【降序】、less&lt; T &gt;【升序】</p>
<p>map容器常见创建方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line"><span class="comment">//创建空的map容器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; map2&#123;&#123;<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>&#125;,&#123;<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//创建map容器并初始化存入两个键值对</span></span><br><span class="line">map&lt;string,int&gt; map3(map1);</span><br><span class="line"><span class="comment">//复制创建map3</span></span><br><span class="line">map&lt;string,int&gt; map4()	//将临时map对象传递给需要初始化的map容器</span><br><span class="line">&#123;</span><br><span class="line">	map&lt;string,int&gt; map5(map2);</span><br><span class="line">	<span class="keyword">return</span>  map4;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string,int&gt; map6(++map2.begin(),map2.end());</span><br><span class="line"><span class="comment">//取已建map容器中指定区域内的键值对，创建并初始化新的map容器</span></span><br></pre></td></tr></table></figure>


<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回最后一个元素+1位置的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 map 容器中存有键值对的个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td>
</tr>
<tr>
<td>operator[]</td>
<td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值</td>
</tr>
<tr>
<td>at(key)</td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常</td>
</tr>
<tr>
<td>insert()</td>
<td>向 map 容器中插入键值对</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1</td>
</tr>
</tbody></table>
<br>

<br>

<h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>map 容器配备的是双向迭代器（bidirectional iterator），也就是map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td>
</tr>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td>
</tr>
</tbody></table>
<p>其中lower_bound(key)和upper_bound(key)更加多用于multimap容器，在map容器中很少用到</p>
<p>equal_range(key)可以看做是lower_bound(key)和upper_bound(key)的结合，返回一个pair对象，两个元素都是迭代器类型，其中pair.first是lower_bound(key)的返回值，pair.second是upper_bound(key)的返回值，其本身表示键值对中键的值都为key的一个范围</p>
<div class="tip warning"><p>

</p><p>由于map容器中键值对的键都是唯一的，所以调用equal_range(key)函数时，其范围内也最多只有一个键值对</p>
<p></p></div>



<h3 id="按键索值"><a href="#按键索值" class="headerlink" title="按键索值"></a>按键索值</h3><p>map类模板对[]运算符进行了重载，可以借助类似数组下标的方式直接访问数组中元素，通过指定的键可以得到其对应的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; map1&#123;<span class="number">1</span>,<span class="string">&quot;first&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;second&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;third&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> value=map1[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//此时value的值等于second</span></span><br></pre></td></tr></table></figure>
<p>当无法在已有map容器的元素中找到对应键时，会向map容器中添加一个符合要求的新键值对，其对应值默认为0</p>
<p>map容器也提供at()成员函数，通过输入键查找对应的值，但如果查找失败不会创建新键值对，而是抛出out_of_range异常</p>
<p>同样，使用find()函数也可以间接的实现这个功能，但返回的是一个迭代器，指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>同上，[]运算符在没有查找到对应键时会添加键值对，配合map容器本身的排序功能便可以实现插入</p>
<p>除此之外，insert()成员函数专门用于向map中插入键值对数据</p>
<div class="tip warning"><p>

</p><p>注：这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整</p>
<p></p></div>

<p>insert()既可以不指定插入位置，直接将键值对添加到map容器中，又可以向map容器的指定位置插入键值对</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不指定位置</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const value_type&amp;val);</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_interator position,<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator position,p&amp;&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入其他map容器中指定区域的所有键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="comment">//其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性插入多个键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，不指定位置时，val是键值对类型的变量，该方法会返回一个pair对象，pair.first代表迭代器，pair.second为bool型变量：</p>
<ul>
<li>如果成功插入val，返回的pair对象中的迭代器指向val，bool为true</li>
<li>如果插入失败，返回的pair对象中的迭代器指向和val的键相同的键值对p，bool为false</li>
</ul>
<p>指定位置时，val依旧是键值对类型变量，而insert()的返回值将会是迭代器而不再是pair对象：</p>
<ul>
<li>如果插入成功，insert()返回一个指向map容器中已插入键值对的迭代器</li>
<li>如果插入失败，insert()返回一个map容器中指向和val的键相同的键值对</li>
</ul>
<div class="tip warning"><p>

</p><p>以上除指定位置的差别外，语法格式区别在于传参方式不同，局部和全局变量都采用普通引用传参，对于临时的键值对变量则以右值引用方式传参</p>
<p>而即使指定位置，insert()插入之后map容器依旧会对自己进行排序，决定插入位置的不是insert()传入的迭代器，而是新键值对中的键的值</p>
<p></p></div>

<p>除了 insert() ，map 类模板还提供 emplace() 和 emplace_hint() ，它们也可以完成向 map 容器中插入键值对的操作，且效率还比 insert() 高</p>
<p>其中，emplace() 方法的语法格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure>
<p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p>
<ul>
<li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li>
<li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li>
</ul>
<p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p>
<ol>
<li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li>
<li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li>
</ol>
<p><strong>和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置</strong></p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>map容器删除数据的函数只有如下两个：</p>
<ul>
<li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li>
<li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li>
</ul>
<p>用法可参照前面的其他容器的用法，此处不详细说明</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">map的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul>
<li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名；</p>
<p>——创建空的map容器</p>
</li>
<li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名{以{“键”,”值”}的格式列举键值对}；</p>
<p>——创建map容器并初始化存入键值对</p>
</li>
<li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一个容器名)；</p>
<p>——复制创建map容器</p>
</li>
<li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(函数参数表){函数体部分，需要返回一个map对象}</p>
<p>——将函数中的临时map对象传递给需要初始化的map容器</p>
</li>
<li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一容器的初始位置,另一容器的末位置)；</p>
<p>——取已建map容器中指定区域内的键值对，创建并初始化新的map容器</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul>
<li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li>
<li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li>
<li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li>
<li>只能进行 ++p、p++、–p、p–、*p 操作</li>
<li>只能使用 == 或者 != 运算符进行比较</li>
<li>lower_bound(key)——返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器</li>
<li>upper_bound(key) ——返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器</li>
<li>equal_range(key)——返回键值对可以看做是&lt;lower_bound(key),upper_bound(key) &gt;</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul>
<li>以[]运算符访问已知键对应的值，如果查找失败则插入为新元素，值默认为0</li>
<li>使用at()函数访问，查找失败返回out_of_range错误</li>
<li>使用find()函数，返回一个迭代器指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>插入元素：</p>
<ul>
<li><p>不指定位置：</p>
<p>pair&lt;iterator,bool&gt; insert(const value_type&amp;val);<br>——引用传递一个键值对</p>
<p>template&lt; class p &gt;<br>pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p>
</li>
<li><p>指定位置</p>
<p>iterator insert(const_interator position,const value_type&amp;val);<br>——引用传递一个键值对</p>
<p>template&lt; class p &gt;<br>  iterator insert(const_iterator position,p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p>
</li>
<li><p>插入其他map容器中指定区域的所有键值对<br>template &lt; class InputIterator &gt;<br>  void insert (InputIterator first, InputIterator last);<br>——其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</p>
</li>
<li><p>——一次性插入多个键值对<br>void insert ({val1, val2, …});</p>
</li>
</ul>
<p>删除元素：</p>
<ul>
<li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li>
<li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>





<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.insert(STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-3&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>ret.iter = &lt;{2,2-2}, 1&gt;<br>ret.iter = &lt;{1,1-2}, 1&gt;<br>ret.iter = &lt;{2,2-2}, 0&gt;</p>
<p></p></div>





<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.insert(it, STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2-3&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>2 2-2<br>1 1-2<br>2 2-2</p>
<p></p></div>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap&#123; &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3-2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++mymap.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = mymap.end();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.insert(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.begin(); iter != copymap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>3 3-2<br>2 2-2</p>
<p></p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-1</title>
    <url>/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/</url>
    <content><![CDATA[<h1 id="快捷键节点"><a href="#快捷键节点" class="headerlink" title="快捷键节点"></a>快捷键节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/1.png" alt="1"></p>
<p>节点名：延迟</p>
<p>呼出方式：（快捷键）D+left</p>
<p>具体作用：实现程序暂停，延迟一段时间继续执行后续节点</p>
<p>接口：Duration——延迟时长，单位为秒</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/2.png" alt="2"></p>
<p>节点名：分支</p>
<p>呼出方式：（快捷键）B+left</p>
<p>具体作用：实现程序因布尔值变化而条件分歧</p>
<p>接口：Condition——决定选择支的布尔值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/3.png" alt="3"></p>
<p>节点名：序列</p>
<p>呼出方式：（快捷键）S+left</p>
<p>具体作用：使多个分支同时进行</p>
<p>接口：Then——同时进行的分支接口</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/4.png" alt="4"></p>
<p>节点名：For each loop</p>
<p>呼出方式：（快捷键）F+left</p>
<p>具体作用：根据数组元素的个数执行循环</p>
<p>接口：array——需要遍历的数组</p>
<p>Loop body——循环体</p>
<p>Array Element——当前数组元素的值</p>
<p>Array Index——当前数组元素的下标</p>
<p>Completed——循环出口</p>
<h1 id="普通节点"><a href="#普通节点" class="headerlink" title="普通节点"></a>普通节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/46.png" alt="46"></p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/47.png" alt="47"></p>
<p>节点名：以函数名设置/清除定时器</p>
<p>呼出方式：右键查询（使用节点名或timer）</p>
<p>具体作用：在【Time】指定的时间间隔后执行【Function Name】指定的函数</p>
<p>接口：Object——函数所在的actor</p>
<p>Function Name——要执行的函数的名称</p>
<p>Time——停顿的时间</p>
<p>Looping——是否循环执行</p>
<p>注：delay（延迟）不可被中止，而timer（定时器）可随时被中止，例如呼吸回血的机制，就应该用timer而不是delay</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/5.png" alt="5"></p>
<p>节点名：获取类的所有actor</p>
<p>呼出方式：右键查询（使用节点名或get all actor）</p>
<p>具体作用：获取场景中所有某类的实例</p>
<p>接口：Actor Class——需要获取的类</p>
<p>Out Actors——选中类的所有actor的数组</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/6.png" alt="6"></p>
<p>节点名：自定义事件（事件名称）</p>
<p>呼出方式：右键查询（使用节点名或custom event）</p>
<p>具体作用：定义一个自定义事件</p>
<p>接口：无</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/11.png" alt="11"></p>
<p>节点名：（事件名称）</p>
<p>呼出方式：右键查询（使用节点名查找引用）</p>
<p>具体作用：引用一个在某蓝图中定义好的自定义事件</p>
<p>接口：无</p>
<h1 id="时间轴与变换节点"><a href="#时间轴与变换节点" class="headerlink" title="时间轴与变换节点"></a>时间轴与变换节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/10.png" alt="10"></p>
<p>节点名：时间轴</p>
<p>呼出方式：右键查询（使用节点名或timeline）</p>
<p>具体作用：创建时间轴（用于播放动画等）</p>
<p>接口：play——正放</p>
<p>play from start——从头正放</p>
<p>stop——暂停</p>
<p>Reverse——倒放</p>
<p>Reverse from End——从最后倒放</p>
<p>Set New Time——跳转到特定时间轴</p>
<p>New Time——设定跳转到的特定时间轴（需要Set New Time启用）</p>
<p>Update——在时间轴移动时不断执行</p>
<p>Finished——时间轴结束后执行（无论正放倒放）</p>
<p>Direction——为时间轴进行方向，可在update或finished后接入switch判断正放倒放</p>
<p>*创建时间轴和圆滑曲线化：</p>
<p>通常使用浮点型轨道（f+），键入轨道名称后会出现相应接口，返回时间轴窗口创建关键帧，在两个不同关键帧间会形成对应时间和值的变化直线（折线），最后修改时间轴总长度等于有效变化直线的时间，若同时将两个或以上的关键帧插值改为“用户”型，可通过调整其切线使整个变化折线变为曲线，更加圆滑的完成值的变化</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/12.png" alt="12"></p>
<p>节点名：拆分变换</p>
<p>呼出方式：右键查找（使用节点名或break）</p>
<p>具体作用：将一个变换过程拆分成L、R、S三者</p>
<p>接口：In Transform——需要拆分的变换</p>
<p>Location——位置变化量</p>
<p>Rotation——旋转变化量</p>
<p>Scale——缩放变化量</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/13.png" alt="13"></p>
<p>节点名：创建变换</p>
<p>呼出方式：右键查找（使用节点名或make）</p>
<p>具体作用：合并L、R、S三者为一个变换过程</p>
<p>接口：Location——位置变化量</p>
<p>Rotation——旋转变化量</p>
<p>Scale——缩放变化量</p>
<p>Return value——变换的返回值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/15.png" alt="15"></p>
<p>节点名：插值</p>
<p>呼出方式：右键查找（使用节点名或lerp）</p>
<p>具体作用：取出某个值随时间变化中特定比例处的值</p>
<p>接口：A——变化开始时值的初始量</p>
<p>B——变化结束时值的终点量</p>
<p>Alpha——变化量占A，B差值的比例（只能为0~1）</p>
<p>Return Value——返回初始值加变化量的结果</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/16.png" alt="16"></p>
<p>节点名：插值（向量）</p>
<p>呼出方式：右键查找（使用节点名或lerp）</p>
<p>具体作用：取出某个向量随时间变化中特定比例处的值</p>
<p>接口：A——变化开始时向量的初始值</p>
<p>B——变化结束时向量的终点值</p>
<p>Alpha——变化量占A，B差值的比例（只能为0~1）</p>
<p>Return Value——返回初始值加变化量的结果</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/14.png" alt="14"></p>
<p>节点名：已限制映射范围</p>
<p>呼出方式：右键查找（使用节点名或Clamp）</p>
<p>具体作用：将基准值实现In A~In B的变化，并且按In和Out的A、B比例缩放</p>
<p>接口：Value——输入的基准值</p>
<p>In Range A——输入的初始比例</p>
<p>In Range B——输入的终点比例</p>
<p>Out Range A——输出的初始比例</p>
<p>Out Range B——输出的终点比例</p>
<p>Return Value——返回变化且缩放后的值</p>
<p>注：上文所提到的普通插值可视作In A=0.0，In B=1.0的该节点</p>
<h1 id="运算节点"><a href="#运算节点" class="headerlink" title="运算节点"></a>运算节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/17.png" alt="17"></p>
<p>节点名：限制（浮点）</p>
<p>呼出方式：右键查找（使用节点名或clamp）</p>
<p>具体作用：将数据限制在范围内，范围外的数小于min的输出min，大于max输出max</p>
<p>接口：Value——输入值</p>
<p>Min——范围的最小值</p>
<p>Max——范围的最大值</p>
<p>Return Value——数据限制后的返回值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/18.png" alt="18"></p>
<p>节点名：截断</p>
<p>呼出方式：右键查找（使用节点名）/将浮点数据直接接入整数接口</p>
<p>具体作用：将数据向0舍入，截断小数部分</p>
<p>注：1.6舍入为1，但-1.6舍入为-1</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/19.png" alt="19"></p>
<p>节点名：底部</p>
<p>呼出方式：右键查找（使用节点名或floor）</p>
<p>具体作用：将数据向负无穷舍入，下舍到前一个整数</p>
<p>注：1.6舍入为1，但-1.6舍入为-2</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/20.png" alt="20"></p>
<p>节点名：顶部</p>
<p>呼出方式：右键查找（使用节点名）</p>
<p>具体作用：将数据向正无穷/向上舍入到下一个整数</p>
<p>注：1.6舍入为2，而-1.6舍入为-1</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/21.png" alt="21"></p>
<p>节点名：舍入</p>
<p>呼出方式：右键查找（使用节点名或round）</p>
<p>具体作用：将数据舍入到最近的整数</p>
<p>注：1.6舍入为2，而-1.6舍入为-2</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/22.png" alt="22"></p>
<p>节点名：（dot）</p>
<p>呼出方式：右键查找（点乘积）</p>
<p>具体作用：计算向量点乘</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/23.png" alt="23"></p>
<p>节点名：（cross）</p>
<p>呼出方式：右键查找（叉乘积）</p>
<p>具体作用：计算向量叉乘</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/24.png" alt="24"></p>
<p>节点名：范围内随机浮点（其他数据类型也可）</p>
<p>呼出方式：右键查找（使用节点名或random float）</p>
<p>具体作用：生成随机浮点数</p>
<p>接口：min——最小值</p>
<p>max——最大值</p>
<p>return value——范围内的随机数</p>
<h1 id="选择节点"><a href="#选择节点" class="headerlink" title="选择节点"></a>选择节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/7.png" alt="7"></p>
<p>节点名：切换整型</p>
<p>呼出方式：右键查询（使用节点名或switch）</p>
<p>具体作用：利用整数切换引脚流程</p>
<p>接口：Selection——作为切换标准的整型</p>
<p>Default——不满足其他引脚时的默认执行引脚</p>
<p>注：除切换为整型以外，其他类型的数据也可使用switch查找对应类型的切换</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/9.png" alt="9"></p>
<p>节点名：开启字符串【翻译可能有误】</p>
<p>呼出方式：右键查询（使用节点名或switch）</p>
<p>具体作用：输入指定字符串选择完全相同的引脚执行</p>
<p>接口：Selection——输入作为判断依据的字符</p>
<p>Default——不满足其他引脚时的默认执行引脚</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/8.png" alt="8"></p>
<p>节点名：选择</p>
<p>呼出方式：右键查询（使用节点名或select）</p>
<p>具体作用：通过输入的内容得到已设定的返回值</p>
<p>接口：Option 0，Option 1——设置给出的index值得到的返回值</p>
<p>Index——可以接入任何类型的通配符</p>
<p>Return value——返回值的出口</p>
<h1 id="控制器节点"><a href="#控制器节点" class="headerlink" title="控制器节点"></a>控制器节点</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/26.png" alt="26"></p>
<p>节点名：设置仅输入模式游戏</p>
<p>呼出方式：右键查询（使用节点名或input only）</p>
<p>具体作用：设置鼠标的输入模式，将光标锁定在游戏界面中心</p>
<p>接口：Player Controller——接玩家控制器</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/25.png" alt="25"></p>
<p>节点名：设置仅输入模式UI</p>
<p>呼出方式：右键查询（使用节点名或input only）</p>
<p>具体作用：设置鼠标的输入模式，将光标锁定在某个UI上</p>
<p>接口：Player Controller——接玩家控制器</p>
<p>In Widget to Focus——将光标锁定在该接口指定的UI上</p>
<p>In Mouse Lock Mode——设置系统光标状态</p>
<p>注：In Mouse Lock Mode接口分不锁定、捕获时锁定、固定锁定、锁定为全屏；捕获时锁定指运行窗口在最前端时将系统光标锁定在程序窗口内，直到win键强行解锁；固定锁定指一直将系统光标锁定在程序窗口内，直到win键强行解锁；锁定为全屏指仅全屏时锁定光标。</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/31.png" alt="31"></p>
<p>节点名：获取玩家控制器/角色/pawn</p>
<p>呼出方式：右键查询（使用节点名或蓝色引脚牵出搜索get player）</p>
<p>具体作用：得到一个玩家控制器的返回值</p>
<p>接口：Player Index——玩家控制器的序号</p>
<p>Return Value——返回玩家控制器</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/33.png" alt="33"></p>
<p>节点名：（set）</p>
<p>呼出方式：右键查询（show mouse）[需要取消情境关联]</p>
<p>具体作用：设置鼠标的显示</p>
<p>接口：Show Mouse Cursor——是否显示鼠标</p>
<p>目标——接玩家控制器</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/32.png" alt="32"></p>
<p>节点名：生成Actor</p>
<p>呼出方式：右键查询（使用节点名或create）</p>
<p>具体作用：凭空创建一个actor</p>
<p>接口：Class——生成的actor类型</p>
<p>Spawn Transform——指定actor初始变换（生成位置、缩放、旋转度）</p>
<p>Collision Handing Override——判断生成的条件（和碰撞体积有关）</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/27.png" alt="27"></p>
<p>节点名：销毁Actor</p>
<p>呼出方式：右键查询（使用节点名或destroy）</p>
<p>具体作用：销毁目标Actor</p>
<p>接口：目标——被销毁的对象</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/30.png" alt="30"></p>
<p>节点名：构建</p>
<p>呼出方式：右键查询（使用节点名或create）</p>
<p>具体作用：创建一个UI</p>
<p>接口：Class——UI的类型</p>
<p>Owning Player——指定UI属于哪一个玩家</p>
<p>Return Value——生成的UI</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/29.png" alt="29"></p>
<p>节点名：添加到视口</p>
<p>呼出方式：右键查询（使用节点名或牵引构建ui的返回值引脚，输入add to）</p>
<p>具体作用：让创建的UI显示到用户界面</p>
<p>接口：目标——接已创建的UI</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/28.png" alt="28"></p>
<p>节点名：从父项中移除</p>
<p>呼出方式：右键查询（使用节点名或remove from parent）</p>
<p>具体作用：移除目标控件</p>
<p>接口：目标——需要移除的控件</p>
<h1 id="数组节点"><a href="#数组节点" class="headerlink" title="数组节点"></a>数组节点</h1><p>创建数组：在创建好的变量左侧图标上右键，能够创建一个同类型变量的数组</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/34.png" alt="34"></p>
<p>节点名：获取数组元素（上为复制，下为引用）</p>
<p>呼出方式：右键查询（使用节点名或数组引线查询get）</p>
<p>具体作用：获取数组中指定下标的元素</p>
<p>接口：（数组接口）——该元素所在数组</p>
<p>（整数型接口）——需要获取的数组元素下标</p>
<p>（右值）——返回值（复制返回值，引用返回地址）</p>
<p>注：该节点分为复制和引用两种方式，同c/c++中函数的传值和引用传址，复制会生成副本，引起的变化不改变数组本身，而引用则可以改变数组内元素的值，但操作不当易使数据受损</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/35.png" alt="35"></p>
<p>节点名：创建数组</p>
<p>呼出方式：右键查询（使用节点名或从set左值牵引查询make）</p>
<p>具体作用：创建一个数组</p>
<p>接口：左侧——设置序号下的数组值</p>
<p>右侧——得到数组变量</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/36.png" alt="36"></p>
<p>节点名：（set）</p>
<p>呼出方式：有引出变量的情况下，输入set查询</p>
<p>具体作用：设置数组</p>
<p>接口：左侧——被设置的对象变量数组</p>
<p>右侧——接已经创建的数组</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/37.png" alt="37"></p>
<p>节点名：设置阵列元素</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询set）</p>
<p>具体作用：设置数组单个元素的值</p>
<p>接口：Target Array——接该元素所在数组</p>
<p>Index——指定的数组元素的序号</p>
<p>Item——为该数组元素所赋的值</p>
<p>Size to Fit——当index大于数组大小时，数组将扩展</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/38.png" alt="38"></p>
<p>节点名：查找项目</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：查找与给定值相等的数组下标</p>
<p>接口：左侧——数组与需要查找的给定值</p>
<p>右侧——数组序号返回值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/39.png" alt="39"></p>
<p>节点名：为有效索引</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：判断能否查找到指定元素</p>
<p>接口：左侧——数组与需要查找的给定值</p>
<p>右侧——能否找到的bool值返回</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/40.png" alt="40"></p>
<p>节点名：添加</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：在数组最后添加一个元素</p>
<p>接口：左侧——数组与需要添加的值</p>
<p>右侧——数组序号返回值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/41.png" alt="41"></p>
<p>节点名：插入</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：在指定下标处插入一个元素，其他元素自动后移</p>
<p>接口：左侧——数组与需要查找的给定值，以及需要插入的位置序号</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/42.png" alt="42"></p>
<p>节点名：长度</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：返回数组长度</p>
<p>接口：左侧——数组</p>
<p>右侧——数组长度返回值</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/43.png" alt="43"></p>
<p>节点名：清空</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：清空整个数组</p>
<p>接口：左侧——需要清空的数组</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/44.png" alt="44"></p>
<p>节点名：移除项目</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：移除等于这个值的元素</p>
<p>接口：左侧——数组与需要移除的给定值</p>
<p>右侧——返回是否成功移除</p>
<p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/45.png" alt="45"></p>
<p>节点名：移除索引</p>
<p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p>
<p>具体作用：移除这个下标的元素</p>
<p>接口：左侧——数组和元素下标</p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-溶解特效</title>
    <url>/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h1 id="溶解特效制作"><a href="#溶解特效制作" class="headerlink" title="溶解特效制作"></a>溶解特效制作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文中可以学到4个之前暂时跳过的全新知识点</p>
<ul>
<li>材质参数集资产<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/1.png" alt="1"></li>
<li>材质中的”已遮罩”混合模式<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/2.png" alt="2"></li>
<li>材质中的if节点以及过场动画中的”材质参数轨道”<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/3.png" alt="3"> </li>
</ul>
<p>总之都是干货啦，开始吧~</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>首先，先准备好溶解特效的蒙版贴图</p>
<div class="snote download yellow"><a href="https://docs.unrealengine.com/Images/AnimatingObjects/Sequencer/HowTo/TracksMaterialParameter/T_Dissolve.png">点此获取样例蒙版贴图</a></div>



<p>将贴图导入后，新建一个材质参数集资产并起名为”溶解参数集”</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/4.png" alt="4"></p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/5.png" alt="5"></p>
<p>打开参数集，添加一个标量参数，起名为“Alpha”，意为不透明度，1为正常，0为完全溶解消失。<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/6.png" alt="6"></p>
<div class="tip warning"><p>

</p><p>材质参数集的作用就是可以在游戏运行时改变材质中的一些数值，可以产生材质的动态变化。</p>
<p></p></div>

<p>随后打开要被做成溶解特效的材质，以金币材质为例,</p>
<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/7.png" alt="7" style="zoom:50%;">

<p>看上去相当复杂，但不用管，只需稍加改造即可。</p>
<p>首先去细节面板，将混合模式改为“已遮罩”</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/8.png" alt="8"></p>
<table>
<thead>
<tr>
<th align="center">混合模式</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">不透明</td>
<td align="center">普通不透明的材质</td>
</tr>
<tr>
<td align="center">已遮罩</td>
<td align="center">相当于材质只覆盖了表面的一层，可以修改局部的不透明度</td>
</tr>
<tr>
<td align="center">半透明</td>
<td align="center">常用于玻璃水面等材质，可以有折射特效，但只能对整体进行不透明度的修改</td>
</tr>
</tbody></table>
<p>然后将“溶解参数集”拖入，参数名选择Alpha</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/10.png" alt="10"></p>
<p>将贴图拖入，并建一个if节点，按如下摆放并与“不透明蒙版”相连</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/9.png" alt="9"></p>
<div class="tip warning"><p>

</p><p>解释：贴图是一张黑白图，黑白图的RGB为同一个数，而不透明蒙版中输入0为全透明，1为完全不透明，因此可在运行时调整Alpha（从0到1），使贴图蒙版中红色（因是黑白图，所以取哪个都是一样，因为要浮点与浮点才能比较，所以只能取其中一个值，而不能取RGB，因为RGB是向量Vector类型的变量）大于等于那个值的部分显示（蒙版输入1）小于那个值的部分消失（蒙版输入0）。TexCoord之前有提过，按T加左键，用于缩放贴图的密度，UV数字越大密度越高，案例中将U和V都设置成了4。</p>
<p></p></div>



<p>if节点的作用：</p>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">输入一个浮点值</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">输入一个浮点值</td>
</tr>
<tr>
<td align="center">A&gt;B</td>
<td align="center">A&gt;B时输出的内容（不一定只能是浮点，可为任意类型）</td>
</tr>
<tr>
<td align="center">A==B</td>
<td align="center">A=B时输出的内容（不一定只能是浮点，可为任意类型）</td>
</tr>
<tr>
<td align="center">A&lt;B</td>
<td align="center">A&lt;B时输出的内容（不一定只能是浮点，可为任意类型）</td>
</tr>
</tbody></table>
<p>到此就建立完毕了，所有套用了这个材质或者所有以这个材质为父类建立的材质实例的物体都会应用溶解的效果</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="过场动画中的使用"><a href="#过场动画中的使用" class="headerlink" title="过场动画中的使用"></a>过场动画中的使用</h3><p>建立一个过场动画，添加一条材质参数集轨道，选择之前建立的“溶解参数集”</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/11.png" alt="11"></p>
<p>随后添加一个Alpha轨道</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/12.png" alt="12"></p>
<p>添加一些关键帧（如图分别为0，1，0）</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/13.png" alt="13"></p>
<p>拖动时间轴可以看到物体溶解然后复原</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/14.png" alt="14"></p>
<h3 id="蓝图中的使用"><a href="#蓝图中的使用" class="headerlink" title="蓝图中的使用"></a>蓝图中的使用</h3><p>在蓝图中调用这个节点“设置标量参数值”，Collection输入创建的参数集，Parameter Name输入要改变的参数，Parameter Value输入值</p>
<p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/15.png" alt="15"></p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-6</title>
    <url>/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/</url>
    <content><![CDATA[<h1 id="脚步声与相机晃动"><a href="#脚步声与相机晃动" class="headerlink" title="脚步声与相机晃动"></a>脚步声与相机晃动</h1><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>实现角色在默认地板、木质地板和金属地板上的不同脚步声以及行走时的相机晃动</p>
<h2 id="函数写入位置"><a href="#函数写入位置" class="headerlink" title="函数写入位置"></a>函数写入位置</h2><p>全局函数库、玩家角色蓝图</p>
<h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h3><p>创建相机晃动（下图为参考数值），需要勾上单一实例，保证每次使用只晃动一次</p>
<p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/1.png" alt="1"></p>
<h3 id="脚步声"><a href="#脚步声" class="headerlink" title="脚步声"></a>脚步声</h3><ol>
<li><p>导入材质、脚步声</p>
</li>
<li><p>创建物理材质，表面类型需要在项目设置中先添加再修改，以下为项目设置界面</p>
<p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/3.png" alt="3"></p>
</li>
<li><p>以其中一个音频为基础创建cue，并添加随机节点，实现多个同类音频随机播放（毕竟脚步声不可能每一步都是同一个声音），如图示例</p>
<p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/2.png" alt="2"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-5</title>
    <url>/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/</url>
    <content><![CDATA[<h1 id="虚幻文件夹结构"><a href="#虚幻文件夹结构" class="headerlink" title="虚幻文件夹结构"></a>虚幻文件夹结构</h1><h2 id="本地工程文件夹"><a href="#本地工程文件夹" class="headerlink" title="本地工程文件夹"></a>本地工程文件夹</h2><p>惯例为【Config】、【Content】、【DerivedDataCache】、【Intermediate】、【Saved】、【Script】六个文件夹，和一个后缀名为.uproject的文件（该文件为工程本体，在引擎中打开工程使用该文件）</p>
<h3 id="【Config】"><a href="#【Config】" class="headerlink" title="【Config】"></a>【Config】</h3><h3 id="【Content】"><a href="#【Content】" class="headerlink" title="【Content】"></a>【Content】</h3><h3 id="【DerivedDataCache】"><a href="#【DerivedDataCache】" class="headerlink" title="【DerivedDataCache】"></a>【DerivedDataCache】</h3><h3 id="【Intermediate】"><a href="#【Intermediate】" class="headerlink" title="【Intermediate】"></a>【Intermediate】</h3><h3 id="【Saved】"><a href="#【Saved】" class="headerlink" title="【Saved】"></a>【Saved】</h3><h3 id="【Script】"><a href="#【Script】" class="headerlink" title="【Script】"></a>【Script】</h3><h2 id="导入素材文件夹"><a href="#导入素材文件夹" class="headerlink" title="导入素材文件夹"></a>导入素材文件夹</h2><p>惯例为【Animations】、【Materials】、【Meshes】、【Map（Scenes）】、【Textures】五个文件夹，有时也有会将【Materials】、【Textures】、【Meshes】放在一个【character】文件夹下的构成</p>
<h3 id="【Animations】"><a href="#【Animations】" class="headerlink" title="【Animations】"></a>【Animations】</h3><p>【Animations】为该素材包内包括的动画序列，根据固定的骨骼执行，执行动画的网格体可以替换预览并实际替换使用</p>
<h3 id="【Materials】"><a href="#【Materials】" class="headerlink" title="【Materials】"></a>【Materials】</h3><p>【Materials】为该素材包内所用到的所有材质，一般通过【材质】蓝图修改或直接使用</p>
<h3 id="【Meshes】"><a href="#【Meshes】" class="headerlink" title="【Meshes】"></a>【Meshes】</h3><p>【Meshes】为该素材包内用到的所有骨架模型（骨骼网格体）、物理模型（物理资产）、骨骼，骨架模型是没有碰撞体积的，而物理模型能够表现受力（例如场景中运行时会受重力，和玩家角色重叠时会发生移动）</p>
<h3 id="【Map（scenes）】"><a href="#【Map（scenes）】" class="headerlink" title="【Map（scenes）】"></a>【Map（scenes）】</h3><p>【Map（Scenes）】为该素材包的场景地图，一般会有一个Overview场景，用于预览所有模型，动画，地形等该素材包的素材</p>
<h3 id="【Textures】"><a href="#【Textures】" class="headerlink" title="【Textures】"></a>【Textures】</h3><p>【Textures】为该素材包的所有贴图，包括材质贴图，法线贴图，场景贴花等，通常在【材质】蓝图中找到需要更改的属性，再对应的更改贴图以达到更改材质的效果</p>
<p><br><br></p>
<h1 id="Android端配置"><a href="#Android端配置" class="headerlink" title="Android端配置"></a>Android端配置</h1><p>Android端使用的虚幻引擎版本为4.22.3,下载时需要勾选以下内容</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/1.png" alt="1"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/2.png" alt="2"></p>
<p>具体使用时，创建工程需要选中“移动设备/平板电脑”一项</p>
<h2 id="项目设置修改"><a href="#项目设置修改" class="headerlink" title="项目设置修改"></a>项目设置修改</h2><p>为了顺利打包成apk格式，需要工程的项目设置提前修改，具体修改项如下：</p>
<br>

<h3 id="Android项"><a href="#Android项" class="headerlink" title="Android项"></a>Android项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-1.png" alt="3-1"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-2.png" alt="3-2"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-3.png" alt="3-3"></p>
<p>其中修改project为工程名时，不需要保留括号，必须为英文，且不能有特殊符号</p>
<br>

<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-4.png" alt="3-4"></p>
<p>此处填入手机上app显示的名字，可以为中文</p>
<br>

<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-5.png" alt="3-5"></p>
<p>此处勾选，引擎打包后生成出来为单独的一个apk格式文件</p>
<br>

<p>icons项为图标，悬停可以显示图片大小，此处不作说明</p>
<br>

<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-6.png" alt="3-6"></p>
<p>app默认开始时有淡入淡出显示logo的界面，不需要的话，可以取消勾选</p>
<br>

<h3 id="Android-SDK项"><a href="#Android-SDK项" class="headerlink" title="Android SDK项"></a>Android SDK项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-7.png" alt="3-7"></p>
<p>此处是Android应用需要的编译环境配置，路径应为全英文路径，以免报错（本文“附加内容”中提供下载地址）</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-8.png" alt="3-8"></p>
<br>

<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-9.png" alt="3-9"></p>
<h3 id="Rendering项"><a href="#Rendering项" class="headerlink" title="Rendering项"></a>Rendering项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-10.png" alt="3-10"></p>
<p>以下配置是给一个简单手机应用的配置，所以均为最低画质</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-11.png" alt="3-11"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-12.png" alt="3-12"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-13.png" alt="3-13"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-14.png" alt="3-14"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-15.png" alt="3-15"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-16.png" alt="3-16"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-17.png" alt="3-17"></p>
<h3 id="Packaging项"><a href="#Packaging项" class="headerlink" title="Packaging项"></a>Packaging项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-1.png" alt="4-1"></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-2.png" alt="4-2"></p>
<p>其中，以下路径为打包项目的输出位置：</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-4.png" alt="4-4"></p>
<p><br><br></p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-3.png" alt="4-3"></p>
<br>

<p>以下修改需要展开隐藏项</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-5.png" alt="4-5"></p>
<h2 id="编译打包"><a href="#编译打包" class="headerlink" title="编译打包"></a>编译打包</h2><p>完成以上配置后，即可运行完成编译，进行打包</p>
<p>注：在尝试打包之前记得先保存默认地图，如果文件夹空置的话会报错（报错信息有“gradle\rungradle.bat :app:assembleDebug”字样）</p>
<p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-6.png" alt="4-6"></p>
<h1 id="附带内容"><a href="#附带内容" class="headerlink" title="附带内容"></a>附带内容</h1><p>此处提供相关文件下载，度盘提取码：wing</p>
<div class="btns rounded grid5">
            <a href="https://pan.baidu.com/s/1D90KkjFeJfrMZAsXmpNxcw" title="Android SDK"><i class="fa fa-download"></i>Android SDK</a>
          </div>

]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-3</title>
    <url>/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/</url>
    <content><![CDATA[<h1 id="基础功能实现"><a href="#基础功能实现" class="headerlink" title="基础功能实现"></a>基础功能实现</h1><h2 id="人物操作功能"><a href="#人物操作功能" class="headerlink" title="人物操作功能"></a>人物操作功能</h2><h3 id="疾跑"><a href="#疾跑" class="headerlink" title="疾跑"></a>疾跑</h3><p>思路:在按下对应键（暂定shift）时，更改人物行走最大速度</p>
<p>玩家角色蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/1.png" alt="1"></p>
<h3 id="射击（创建发射物）"><a href="#射击（创建发射物）" class="headerlink" title="射击（创建发射物）"></a>射击（创建发射物）</h3><p>思路：在按下对应键（暂定鼠标左键）时，生成一个发射物</p>
<p>玩家角色蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/2.png" alt="2"></p>
<h3 id="过肩视角"><a href="#过肩视角" class="headerlink" title="过肩视角"></a>过肩视角</h3><p>思路：在按下对应键时（暂定鼠标右键），让视角缓缓变成过肩视角</p>
<p>玩家角色蓝图：（时间轴具体操作参考之前的节点介绍）</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/3.png" alt="3"></p>
<h3 id="★线检★"><a href="#★线检★" class="headerlink" title="★线检★"></a>★线检★</h3><p><strong><em>【注：案例的线检中“线”的长度为1000单位】</em></strong></p>
<p>思路：在actor正前方的创造一根不可见的线检测前方的物体，输出被检测到的物体，以便实现判断交互</p>
<p>玩家角色蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/4.png" alt="4"></p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p><strong><em>【注：案例中的”医疗包”为触碰即获得并消失，“门”为被线检到（最大距离为线的长度），并且按下F键时，实现“开门”，物体2为人物处于更小的范围或其他范围内，并按下F键时，实现拾取】</em></strong></p>
<p>思路：</p>
<ol>
<li>利用使用线检和类型转换判断物体属于什么类型，或判断开始重叠，然后执行对应的操作</li>
<li>在按下对应键时（暂定F键），判断可交互性，并判断线检检测到的物体，执行对应的自定义事件</li>
<li>在要交互的物体蓝图中设置其交互时执行的具体操作，即定义自定义事件</li>
</ol>
<p>玩家角色蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/5.png" alt="5"></p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/6.png" alt="6"></p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/9.png" alt="9"></p>
<p>“医疗包”类actor蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/10.png" alt="10"></p>
<p>“门”类actor蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/7.png" alt="7"></p>
<p>“物品2”类actor蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/8.png" alt="8"></p>
<h2 id="界面HUD"><a href="#界面HUD" class="headerlink" title="界面HUD"></a>界面HUD</h2><h3 id="显示HUD"><a href="#显示HUD" class="headerlink" title="显示HUD"></a>显示HUD</h3><p>思路：创建HUD控件之后，显示到视口</p>
<p>玩家角色蓝图：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/11.png" alt="11"></p>
<h3 id="显示交互按钮及其名称"><a href="#显示交互按钮及其名称" class="headerlink" title="显示交互按钮及其名称"></a>显示交互按钮及其名称</h3><p>指定/创建绑定函数：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/14.png" alt="14"></p>
<p><strong><em>（注：在文本、百分比、可视性等多个数据都可以使用函数绑定返回值来实现动态显示）</em></strong></p>
<p>思路：</p>
<ol>
<li>判断当前物体类型，按钮子项的文本函数返回不同的文本</li>
<li>判断当前物体是否为可交互物，可交互显示按钮，不可交互隐藏按钮</li>
</ol>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/12.png" alt="12"></p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/13.png" alt="13"></p>
<h3 id="显示角色血条"><a href="#显示角色血条" class="headerlink" title="显示角色血条"></a>显示角色血条</h3><p>思路：HUD中创建一个进度条，进度-百分比使用函数绑定，读取玩家角色的变量HP并返回</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/15.png" alt="15"></p>
<h3 id="制作标题及设置页面控件"><a href="#制作标题及设置页面控件" class="headerlink" title="制作标题及设置页面控件"></a>制作标题及设置页面控件</h3><p>标题页面控件：</p>
<ul>
<li><strong>事件构造时——“显示光标”，并”设置输入模式仅UI“</strong></li>
<li>开始——点击button时，执行“打开关卡”节点</li>
<li>退出——点击button时，执行“退出游戏”节点</li>
<li>设置——点击button时，创建“设置页面控件”，并“添加到视口”，将原来的标题控件“从父项中移除”</li>
</ul>
<p>设置页面控件：</p>
<p><strong><em>注：虚幻本身具有调节各种画质的设置，仅需要调用这套设置即可</em></strong></p>
<p>组合框设置初始显示值（显示当前抗锯齿与视图距离为例）：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/17.png" alt="17"></p>
<p>组合框设置（后期处理质量设置为例）：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/18.png" alt="18"></p>
<p>滑条操作（分辨率缩放设置为例）：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/19.png" alt="19"></p>
<p>返回按钮：</p>
<p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/20.png" alt="20"></p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-2</title>
    <url>/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/</url>
    <content><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><p>普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可</p>
<h2 id="材质域（常用）"><a href="#材质域（常用）" class="headerlink" title="材质域（常用）"></a>材质域（常用）</h2><p>材质的类型一般由材质域区分（材质界面左下角中，细节页的材质栏）</p>
<ul>
<li><h3 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h3><p>普通的基本材质，如木质、铁质、玻璃等覆盖在表面的东西</p>
</li>
<li><h3 id="延迟贴花"><a href="#延迟贴花" class="headerlink" title="延迟贴花"></a>延迟贴花</h3><p>类似等同于喷漆，混合模式只能是半透明，如同投影一样覆盖在物体表面，本质是Actor组件，但可以作为只有一个贴花组件的Actor放入场景</p>
</li>
<li><h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用于UI显示，需要新建媒体播放器，使用媒体纹理生成材质，更改材质域为“用户界面”，在用户UI中添加图像时便可以使用该材质放入外观-笔刷中。</p>
<p>注：使用生成的材质时，需要在UI图表中添加默认值为该材质源媒体播放器的媒体播放器变量，并且事件构造中通过该变量添加对应播放器的“打开源”，如下图</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/8.png" alt="8"></p>
</li>
</ul>
<p>左二接口接入媒体播放器（仅作为媒介），而左三接口则接入具体的视频媒体</p>
<h2 id="混合模式（常用）"><a href="#混合模式（常用）" class="headerlink" title="混合模式（常用）"></a>混合模式（常用）</h2><ul>
<li><h3 id="不透明"><a href="#不透明" class="headerlink" title="不透明"></a>不透明</h3><p>整个材质完全不透光，一般作为底层材质</p>
</li>
<li><h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><p>材质呈现半透明，可以和下层叠加，一般是作为贴花使用</p>
</li>
</ul>
<h2 id="材质节点引脚（常用）"><a href="#材质节点引脚（常用）" class="headerlink" title="材质节点引脚（常用）"></a>材质节点引脚（常用）</h2><ul>
<li><h3 id="基础颜色"><a href="#基础颜色" class="headerlink" title="基础颜色"></a>基础颜色</h3><p>材质的基本图像，可以是纯色或贴图，是整个材质的主外观</p>
</li>
<li><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>一般叫做金属度，针对金属材质，设置金属的质感，反光光泽等</p>
</li>
<li><h3 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h3><p>基本用于非金属表面，一般输入一张比标准贴图亮的贴图，用于扩大光照面和暗面的对比，也可以直接输入一个具体的值，改变整体的反光强度，类似对比度</p>
</li>
<li><h3 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h3><p>决定材质的粗糙程度，0为完全光滑的镜面反射，1为完全粗糙的漫反射</p>
</li>
<li><h3 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h3><p>控制材质发光部位，设置自发光颜色或强度</p>
</li>
<li><h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>法线，输入一张法线贴图，用于记录材质不同位置的凹凸感</p>
</li>
<li><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>输入一个很小的数，影响折射率，可以实现透明玻璃之类的折射，<strong>但效果不怎么样</strong></p>
</li>
</ul>
<h2 id="材质快捷键节点"><a href="#材质快捷键节点" class="headerlink" title="材质快捷键节点"></a>材质快捷键节点</h2><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/1.png" alt="1"></p>
<p>快捷键：1+Left</p>
<p>具体作用：创建一个常数值</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/3.png" alt="3"></p>
<p>快捷键：3+Left</p>
<p>具体作用：创建一个常量颜色值</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/2.png" alt="2"></p>
<p>快捷键：s+Left</p>
<p>具体作用：创建一个变量数值</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/6.png" alt="6"></p>
<p>快捷键：V+Left</p>
<p>具体作用：创建一个颜色变量</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/5.png" alt="5"></p>
<p>快捷键：U+Left</p>
<p>具体作用：创建一个UV缩放节点，用于缩放贴图</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/4.png" alt="4"></p>
<p>快捷键：A+Left</p>
<p>具体作用：将两种颜色或贴图叠加在一起</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/7.png" alt="7"></p>
<p>快捷键：M+Left</p>
<p>具体作用：将两种颜色或贴图混合在一起，一般用选定颜色乘白色贴图进行染色</p>
<h2 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h2><p>由材质生成的材质实例将材质蓝图中的变量节点显示于右面接口，通过改变接口值来更加直观的实时改变材质的颜色等各种属性，能够实现一个材质创造一堆材质实例的操作</p>
<h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>同c的结构体变量类型相同，可以设置一个结构体变量中包含多个普通类型变量，并设置默认值，不能使用自身类型的变量嵌套</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/9.png"></p>
<p>在蓝图中使用时，通过make节点创建结构体并连接set对应的结构体变量，可初始化的设定其各个变量的值</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/11.png" alt="11"></p>
<p>使用break节点拆分结构体，可以得到其中指定的单个变量</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/10.png" alt="10"></p>
<h2 id="蓝图函数库"><a href="#蓝图函数库" class="headerlink" title="蓝图函数库"></a>蓝图函数库</h2><p>类似于头文件，但并不只是函数声明，而是完整的函数编辑，对于同一个文件，可以在左侧边栏里添加多个函数，而且所定义的所有函数均为全局函数</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/12.png" alt="12"></p>
<p>和c与c++的函数不同，虚幻引擎的函数可以有多个输入，多个输出</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/13.png" alt="13"></p>
<p>反应在引用该函数的蓝图上就是对应变量的接口</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/14.png" alt="14"></p>
<h2 id="蓝图宏库"><a href="#蓝图宏库" class="headerlink" title="蓝图宏库"></a>蓝图宏库</h2><p>类似于函数库，但创建与普通蓝图相似，用于创建自定义节点，通常选择创建actor或是object</p>
<p>默认的宏库中只有一个新建宏0和没有接口的输入输出节点，可选择输入输出节点后在右下角细节面板添加</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/15.png" alt="15"></p>
<p>不同于函数的是，设置宏的输入输出时，额外可以设置的还有执行引脚</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/22.png" alt="22"></p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/20.png" alt="20"></p>
<p>若在蓝图宏库中写入以上内容，则在其他蓝图中引用宏时能够得到下面节点</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/21.png" alt="21"></p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型会将数据定义成具体的内容，例如bool型中，0定义为了false，1定义为了true，创建面板如下，可通过右侧的“新”添加新的枚举值</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/16.png" alt="16"></p>
<p>在蓝图中设置枚举变量也和其他变量类型的操作相同</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/17.png" alt="17"></p>
<p>用switch连上枚举类型的话，可以用于判断枚举类型，切换流程</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/18.png" alt="18"></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>相当于编辑器里的Beginplay（事件开始运行），事件面板中的内容在编辑器中不会运行，只有测试时才会执行，但构造函数里的内容编辑器中也会执行，并且不断更新，只要改动就会产生实时变化。</p>
<p>简要来说，在蓝图中写入“设置actor位置”无法在场景中看到actor位置变化，但在选项卡中改动x，y，z数值却会直接改变actor位置，后者就属于构造函数中的内容</p>
<h2 id="媒体播放器"><a href="#媒体播放器" class="headerlink" title="媒体播放器"></a>媒体播放器</h2><p>媒体播放器仅仅是视频文件的播放载体，放入媒体播放器的文件仅仅是预览，具体文件播放的内容需要在蓝图或场景中设置（详细的使用在前面“材质-用户界面”有讲）</p>
<p><strong>注：UE4支持的视频文件格式应该是.avi，音频文件是.wav，导入时需要注意</strong></p>
<h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><p>如字面意思，用于体现物体物理状态的材质，主要是设定摩擦力</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/23.png" alt="23"></p>
<p>物理材质可以在材质面板中赋给某个特定的材质，改变使用这个材质的所有模型的物理材质，也可以在场景中赋予单个模型，后者为物理材质的重载，会针对选定模型覆盖原有的物理材质</p>
<h2 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="控件蓝图"><a href="#控件蓝图" class="headerlink" title="控件蓝图"></a>控件蓝图</h3><ul>
<li><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>默认新建的控件蓝图中会生成一个画布面板，可以通过多个面板与面板的排列或是互相之间的嵌套完成一整套hud或是UI的设置</p>
</li>
<li><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一般只使用可编辑文本和文本框，可编辑文本允许玩家/用户编辑，没有背景，而文本框是开发者设定的文字，显示上有背景；</p>
<p>其中没有备注的均为单行，不能换行，而标注了多行，也仅仅是多行文本框支持换行，并不意味着自动换行</p>
<p><strong>右侧的细节面板中（以文本框为例）</strong></p>
<p>【锚点栏】</p>
<p>1.锚点主要针对屏幕比例不同时，设定UI位置的参考系</p>
<p>2.大小到内容是使整个控件大小和内容（比如文字长度）相同</p>
<p>3.Zorder是上下层数，重叠时最上层数值最大</p>
<p>【内容栏】文本为固定出现的文本，而提示文本则是仅文本框为空才出现的内容</p>
<p>【外观栏】</p>
<p>1.支持更换文本框的背景图片，悬停为鼠标悬停，聚焦指鼠标点击</p>
<p>2.填充指缩进部分，数值越大，缩进越多</p>
<p>3.字体轮廓设置时可以选择对投影应用轮廓，让阴影部分也具有描边</p>
<p>4.删除线可导入图片作为删除线</p>
<p>5.阴影偏移能够设定阴影与文字的位置差，相当于调整投影的光的角度</p>
<p>【行为栏】</p>
<p>1.不勾选“已启用”则显示控件，但不能交互（未开放或不能按的按钮）</p>
<p>2.可视性：针对可见和占据空间及子项能否交互分类，详情鼠标悬停在选项上</p>
</li>
</ul>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>导入字体格式一般为otf，ttf也可行，对同种字体同时导入多个文件时，需要否定引擎导入时的新建（否则会每个文件导入一个字体资产），另外自行新建字体资产，分配字体族系</p>
<p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/24.png" alt="24"></p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>虚幻引擎</category>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>虚幻引擎</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-7:关联式容器STL pair</title>
    <url>/2021/05/21/c++%E5%AD%A6%E4%B9%A0-11/</url>
    <content><![CDATA[<h1 id="pair类模板"><a href="#pair类模板" class="headerlink" title="pair类模板"></a>pair类模板</h1><h2 id="键值对数据类型"><a href="#键值对数据类型" class="headerlink" title="键值对数据类型"></a>键值对数据类型</h2><p>关联式容器存储的是”键值对“形式的数据，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&quot;a&quot;,&quot;121&quot;&gt;</span><br><span class="line">&lt;&quot;b&quot;,&quot;144&quot;&gt;</span><br><span class="line">&lt;&quot;c&quot;,&quot;156&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>以上每行都表示一个键值对，其中第一个元素作为键，第二个元素作为值，由于键值对不是普通数据类型，c++STL标准库提供了pair类模板，用于将两个普通元素a和b，创建成一个新元素&lt;a,b&gt;</p>
<h2 id="pair对象构造"><a href="#pair对象构造" class="headerlink" title="pair对象构造"></a>pair对象构造</h2><p>pair类模板定义在&lt; utility &gt;头文件中，所以在使用该类模板之前，需要引入该头文件，且pair类模板提供了共五种构造函数，如下：</p>
<ul>
<li>默认构造函数，即创建空的 pair 对象：pair();</li>
<li>直接使用 2 个元素初始化成 pair 对象：pair (const first_type&amp; a, const second_type&amp; b);</li>
<li>拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象：template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</li>
<li>移动构造函数：template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</li>
<li>使用右值引用参数，创建 pair 对象：template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</li>
</ul>
<h3 id="关于右值引用"><a href="#关于右值引用" class="headerlink" title="关于右值引用"></a>关于右值引用</h3><p>注：对于右值引用，能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式为“右值”，一般来说，左值可以取地址，右值不可以。非const变量都是左值，函数调用的返回值若不是引用，则该函数调用就是右值，在不专门指出时，引用基本都是引用变量的，即左值引用。c++11中新增了一种右值引用，可以引用无名的临时变量，使用符号为“&amp;&amp;”</p>
<p>引入右值引用的主要目的是提高程序运行的效率。有些对象是无名临时变量，但在复制时却需要进行深复制，往往非常耗时。合理使用右值引用可以避免没有必要的深复制操作</p>
<h2 id="赋值和比较"><a href="#赋值和比较" class="headerlink" title="赋值和比较"></a>赋值和比较</h2><p>pair对象是允许手动赋值的，可用.first和.second分别访问pair对象的键和值，同样，也可以使用make_pair()函数，向其中传入两个参数代表对象的键和值</p>
<p>&lt; utility &gt;头文件中，除了提供创建pair对象的方法之外，还为pair对象重载了以下6种运算符：&lt;、&lt;=、&gt;、&gt;=、==、!=，其运算规则是先比较键的大小，如果键的大小相等，再比较值的大小，且对于比较的两个pair对象，其对应的键和值的类型应该相同，否则编译器将找不到合适的重载运算符</p>
<p>除此之外，当键和值的类型都相同时，可以使用swap()成员函数交换两个pair对象的的键值对，同其他容器中的swap()效果相同</p>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair2(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4(<span class="built_in">make_pair</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair5(<span class="built_in">string</span>(<span class="string">&quot;3&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;7&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>

</p><p>pair1: 0<br>pair2: 1 9<br>pair3: 1 9<br>pair4: 2 8<br>pair5: 3 7</p>
<p></p></div>

<br>

<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;1&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3(<span class="string">&quot;2&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>

</p><p>pair != pair2<br>pair2 != pair3</p>
<p></p></div>
<br>
<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.swap(pair2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>

</p><p>pair1: pair2 20<br>pair2: pair 10</p>
<p></p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-6</title>
    <url>/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</url>
    <content><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul>
<li>树：一个有限集，可以为空，非空时有且只有一个根结点，其余结点可以分为多个不相交的有限集（子树）</li>
<li>结点的度：结点的子树个数</li>
<li>树的度：树的所有结点中最大的度数</li>
<li>叶子结点：度为0的结点</li>
<li>父结点：有子树的结点是其子树的根节点的父结点</li>
<li>子结点/孩子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点</li>
<li>兄弟结点：具有同一个父结点的各结点彼此是兄弟结点</li>
<li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk。ni是ni+1的父结点。路径所包含边的个数为路径的长度</li>
<li>祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li>
<li>子孙结点：某一结点的子树中的所有结点是这个结点的子孙</li>
<li>结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li>
<li>树的深度：树中所有结点中的最大层次是这棵树的深度</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>二叉树：一个有穷的结点集合。这个集合可以为空；若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。</p>
<p><strong>二叉树的五种基本形态：</strong></p>
<p>斜二叉树：只有左子节点或只有右子节点的二叉树，度为1，只有左子节点或右子节点</p>
<p>满二叉树/ 完美二叉树：除最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树</p>
<p>完全二叉树：有n个结点的二叉树，对树中结点从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中的位置相同（能和满二叉树完全重叠，编号相同）</p>
<p><strong>按从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：（顺序存储）</strong></p>
<ul>
<li>根结点的序号为1</li>
<li>非根结点（序号i&gt;1）的父结点的序号是：i / 2</li>
<li>结点（序号为i）的左孩子结点的序号是：2 * i，若2*i &gt; n，则没有左孩子</li>
<li>结点（序号为i）的右孩子结点的序号是：2 * i + 1，若2*i+1 &gt; n，则没有右孩子</li>
</ul>
<p><strong>普遍规律：</strong></p>
<p>一个二叉树第i层的最大结点数为：2i-1，i≥1</p>
<p>深度为k的二叉树有最大结点总数为：2k-1，k≥1</p>
<p>对任何非空二叉树T，叶结点个数为n0，度为1的结点个数为n1，度为2的结点个数为n2，则二叉树的总边数：N=2*n2+n1，总结点数：N′=n0+n1+n2，总叶子结点数：n0=n2+1</p>
<p><strong>二叉树的三种遍历：</strong></p>
<p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/1.png" alt="1"></p>
<p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/2.png" alt="2"></p>
<p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/3.png" alt="3"></p>
<h3 id="二叉树操作"><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h3><h4 id="创建-初始化"><a href="#创建-初始化" class="headerlink" title="创建/初始化"></a>创建/初始化</h4><p>由于树的顺序表结构分配的空间通常只适用于完全二叉树，会造成普通二叉树的空间浪费，所以二叉树一般使用链式结构存储</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span>&#123;</span></span><br><span class="line">	Elemtype data;				<span class="comment">//二叉树的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">left</span>;</span>		<span class="comment">//二叉树的左指针，指向左子树</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">Right</span>;</span>		<span class="comment">//二叉树的右指针，指向右子树</span></span><br><span class="line">&#125;*BTree;</span><br></pre></td></tr></table></figure>
<p>由于二叉树用递归算法较快，涉及到的先序、中序、后序三种输入方式时，只需要调整根节点的输入顺序即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Create</span><span class="params">(BTree &amp;T)</span>			<span class="comment">//传入要操作的结点T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elemtype a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;					<span class="comment">//当输入为“#”时，判断二叉树创建完毕，结束递归</span></span><br><span class="line">    &#125;					 </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        T=<span class="keyword">new</span> BTnode;			<span class="comment">//创建一个新的二叉树结点</span></span><br><span class="line">        T-&gt;data=a;				<span class="comment">//设置数据域为输入值</span></span><br><span class="line">        Create(T-&gt;left);		<span class="comment">//递归创建T的左子树</span></span><br><span class="line">        Create(T-&gt;right);  		<span class="comment">//递归创建T的右子树</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>在创建的时候，相当于也就遍历了一次二叉树，故而除却赋值之外的结构都十分相似,而且由于二叉树已经建立，可以通过二叉树的结点指针是否为空判断遍历是否结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(BTree T)</span>			<span class="comment">//传入需要往下位置遍历的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)						<span class="comment">//如果T为空，则结束遍历</span></span><br><span class="line">	&#123;</span><br><span class="line">		Traverse(T-&gt;left);		<span class="comment">//递归遍历T的左子树</span></span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;T-&gt;data;			<span class="comment">//输出T结点的数据</span></span><br><span class="line">		Traverse(T-&gt;right);		<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="计算深度"><a href="#计算深度" class="headerlink" title="计算深度"></a>计算深度</h4><p>二叉树深度为左右子树中深度较大者加1，故而需要递归求取左右子树的深度，再比较后加1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(BTree T)</span>					<span class="comment">//传入需要往下求取深度的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;			<span class="comment">//当递归到叶子结点时，结束递归</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=depth(T-&gt;left);			<span class="comment">//将左子树的深度存入m</span></span><br><span class="line">        n=depth(T-&gt;right);			<span class="comment">//将右子树的深度存入n</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);		<span class="comment">//如果左子树深度大于右子树则返回m+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);			<span class="comment">//反之，返回n+1</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>线索二叉树将二叉树中空置的左右指针域利用起来，存储沿某种顺序遍历二叉树后继结点的地址，比二叉树多设置左右标志，当标志为1（true）时，表示有对应的子节点（左标志为1，左指针域存储左孩子的地址），否则对应指针域则存储某种顺序遍历二叉树时的下一个结点的地址</p>
<p><strong>其中，左指针域为线索时，指向前驱，右指针域为线索时指向后继</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> ltag,rtag;</span><br><span class="line">&#125;*DBTree;</span><br></pre></td></tr></table></figure>


<h4 id="二叉树中序线索化"><a href="#二叉树中序线索化" class="headerlink" title="二叉树中序线索化"></a>二叉树中序线索化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBTnode *p;							<span class="comment">//p为全局变量，是指向线索二叉树结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dchild</span><span class="params">(DBTree T)</span>				<span class="comment">//以T为根的子树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)							<span class="comment">//当T不为空时</span></span><br><span class="line">	&#123;</span><br><span class="line">		Dchild(T-&gt;left);			<span class="comment">//将左子树递归线索化</span></span><br><span class="line">		<span class="keyword">if</span>(!T-&gt;left)				<span class="comment">//如果左指针域为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			T-&gt;ltag=<span class="literal">false</span>;			<span class="comment">//则左标志为false，表示左指针域为线索指针域</span></span><br><span class="line">			T-&gt;left=p;				<span class="comment">//左指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> T-&gt;ltag=<span class="literal">true</span>;			<span class="comment">//否则左标志为true，表示左指针域指向左孩子</span></span><br><span class="line">		<span class="keyword">if</span>(!p-&gt;right)				<span class="comment">//如果p的右指针域为空</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;rtag=<span class="literal">false</span>;			<span class="comment">//则右标志为false，表示右指针域为线索指针域</span></span><br><span class="line">			p-&gt;right=p1;			<span class="comment">//右指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> p-&gt;rtag=<span class="literal">true</span>;			<span class="comment">//否则右标志为true，表示右指针域指向右孩子</span></span><br><span class="line">		p=T;						<span class="comment">//p指向子树的根节点处</span></span><br><span class="line">		Dchild(p-&gt;right);			<span class="comment">//将右子树递归线索化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DOchild</span><span class="params">(DBTree &amp;T,DBTree D)</span>	<span class="comment">//带头结点的二叉树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T=<span class="keyword">new</span> DBTnode;					<span class="comment">//创建头结点</span></span><br><span class="line">    T-&gt;Ltag=<span class="literal">true</span>;					<span class="comment">//若树非空，则头结点的左孩子为树根，左标志为true</span></span><br><span class="line">    T-&gt;rtag=<span class="literal">false</span>;					<span class="comment">//头结点没有右孩子，右标志为false</span></span><br><span class="line">    T-&gt;right=T;						<span class="comment">//初始化时，头结点的右指针域指向自己</span></span><br><span class="line">    <span class="keyword">if</span>(!T) T-&gt;left=T;				<span class="comment">//若树空，则头结点的左指针也指向自己</span></span><br><span class="line">    <span class="keyword">else</span> 							</span><br><span class="line">    &#123;</span><br><span class="line">    	T-&gt;left=D;					<span class="comment">//否则，头结点的左指针域指向原二叉树的根节点D</span></span><br><span class="line">        p=T;						<span class="comment">//p指向原二叉树根节点D的前驱</span></span><br><span class="line">        Dchild(D);					<span class="comment">//递归线索化二叉树D</span></span><br><span class="line">        p-&gt;right=T;					<span class="comment">//递归线索化后，p指向中序遍历的最后一个结点，右指针域指向头结点</span></span><br><span class="line">        p-&gt;rtag=<span class="literal">false</span>;				<span class="comment">//p指向结点的右标志为false，表示没有右孩子</span></span><br><span class="line">        T-&gt;right=p;					<span class="comment">//将头结点的右指针域指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="遍历中序线索二叉树-非递归"><a href="#遍历中序线索二叉树-非递归" class="headerlink" title="遍历中序线索二叉树(非递归)"></a>遍历中序线索二叉树(非递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OTraverse</span><span class="params">(DBTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p=T-&gt;left;						<span class="comment">//p指向头结点的左孩子，即二叉树的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)						<span class="comment">//当树空或遍历结束时，将有p==T，结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="literal">true</span>) 		<span class="comment">//当左标志为false时，即直到没有左孩子时结束循环</span></span><br><span class="line">            p=p-&gt;left;				<span class="comment">//p沿左子树向下遍历</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;				<span class="comment">//输出左子树为空的结点的值</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag==<span class="literal">false</span>&amp;&amp;p-&gt;right!=T)		<span class="comment">//当右标志为true，即有右孩子且p的后继不是头结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;right;				<span class="comment">//p沿右子树向下遍历</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;			<span class="comment">//沿右子树访问后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;right;					<span class="comment">//转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-5</title>
    <url>/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</url>
    <content><![CDATA[<h1 id="串类型"><a href="#串类型" class="headerlink" title="串类型"></a>串类型</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>串的存储结构可以使用顺序和链式结构，顺序结构中又分为定长和堆式存储结构，但由于链式不如顺序结构灵活，操作简单，故而此处只写入顺序结构</p>
<h3 id="顺序-定长存储"><a href="#顺序-定长存储" class="headerlink" title="顺序-定长存储"></a>顺序-定长存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> ch[maxsize+<span class="number">1</span>];		<span class="comment">//定义字符数组，串的最大长度为maxsize，多申请防止溢出的存储空间</span></span><br><span class="line">	<span class="keyword">int</span> length;				<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;Sstring;</span><br></pre></td></tr></table></figure>


<h3 id="顺序-堆式存储"><a href="#顺序-堆式存储" class="headerlink" title="顺序-堆式存储"></a>顺序-堆式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ch;				<span class="comment">//如果是非空串，则按串长分配存储区，否则ch指向NULL;</span></span><br><span class="line">	<span class="keyword">int</span> length;				<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>串的模式匹配用于在主串中寻找子串，如果匹配成功，则确定相匹配的子串中第一个字符在主串s中出现的位置</p>
<h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[i])	<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;		<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;		<span class="comment">//否则，i回到开始匹配的位置（执行for语句的i++后移到下一个位置</span></span><br><span class="line">            j=<span class="number">0</span>;			<span class="comment">//j被重置为0（然后执行for语句的j++后变为j=1）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.ch[i]==t.ch[i])	<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;		<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];		<span class="comment">//KMP相比BF算法节省时间的原因</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(Sstring t,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function">    <span class="comment">//求子串t的next函数值并且存进数组next</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i=<span class="number">1</span>,next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义i，j，以及next数组的第一个值</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;t.length;)				<span class="comment">//i不超过子串t长度时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||t.ch[i]==t.ch[j])		<span class="comment">//如果j为0或是前后两个字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(t.ch[i]!=t.ch[j])		<span class="comment">//如果前后两个字符不相同</span></span><br><span class="line">                next[i]=j;				<span class="comment">//令下次比较从j开始</span></span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];		</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组的顺序存储"><a href="#二维数组的顺序存储" class="headerlink" title="二维数组的顺序存储"></a>二维数组的顺序存储</h2><p>已知一维数组中a【i】的存储位置在a+i处，二维数组因主序不同分为两种存储结构（常用行序）</p>
<p>设每个数据元素占L个存储单元，则二维数组A[0…m-1,0…n-1]（下标从0开始，共有m行n列）中任一元素a【i】【j】的存储位置如下：</p>
<p><strong>行为主序的存储结构</strong>：</p>
<p>$$<br>LOC(i , j) = LOC(0 , 0) + (n * i + j) L<br>$$<br><strong>列为主序的存储结构：</strong><br>$$<br>LOC(i , j) = LOC(0 , 0) + (m * j + i) L<br>$$<br>其中，LOC(i,j)是a【i】【j】的存储位置</p>
<p>LOC（0，0）是a【0】【0】的存储位置，即二维数组A的起始存储位置、也称为基地址或基址</p>
<p><strong>故而总结可知：</strong><br>$$<br>LOC(i , j) = 基址 + (副序长度 * 主序标号 + 另一标号) * 数据所占存储单元<br>$$</p>
<h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>特点：在n*n的矩阵a中，1&lt;= i，j &lt;= n<br>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。</p>
<p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/1.png" alt="1"></p>
<p>上下三角中的元素均为：n(n+1) / 2<br>可以以行序为主序将元素存放在一个一维数组a[n(n+1) / 2]中，a[k]的位置可如下公式确定<br>$$<br>k=主序序号（主序序号-1）/2+副序序号-1，主序&gt;=副序<br>$$<br>注：上式的k从0开始计算</p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/2.png" alt="2"></p>
<h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-1.png" alt="3-1"></p>
<h3 id><a href="#" class="headerlink" title></a><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-2.png" alt="3-2"></h3><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/4.png" alt="4"></p>
<h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>一般记作LS（a1，a2，……，an），其中LS为广义表的名称，n为广义表的长度，其中的元素可以是单个数据（原子）也可以是广义表（子表），一般小写为原子，大写为子表</p>
<p><strong>广义表示例：</strong></p>
<ul>
<li>A=（）——空表，长度为0</li>
<li>B=（e）——只有一个原子，为e，长度为1</li>
<li>C=（a，（b，c，d））——有一个原子a和一个子表（b，c，d），共两个元素，长度为2</li>
<li>D=（A，B，C）——有三个子表，即三个元素，长度为3</li>
<li>E=（a，E）——一个递归的表，长度为2</li>
</ul>
<p>注：广义表A=（（））和广义表B=（）是不相同的，A为有一个空子表，长度为1的广义表，而B是一个空表，长度为0</p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-4</title>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</url>
    <content><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">	Elemtype *base;				&#x2F;&#x2F;储存空间的基址指针</span><br><span class="line">	int front;					&#x2F;&#x2F;定义一个头指针</span><br><span class="line">	int rear;					&#x2F;&#x2F;定义一个尾指针</span><br><span class="line">&#125;SQqueue;</span><br></pre></td></tr></table></figure>
<p><strong>注：此处front和rear指针仅仅设为了int类型，而并非真正的指针类型，所表述的是队头队尾元素所在的位置下标</strong></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool initqueue(SQqueue &amp;sq)</span><br><span class="line">&#123;</span><br><span class="line">	sq.base&#x3D;new Elemtype[MAXSIZE];			&#x2F;&#x2F;为队列分配空间</span><br><span class="line">	if(!sq.base) return false;				&#x2F;&#x2F;没能分配成功，返回失败</span><br><span class="line">	sq.front&#x3D;sq.rear&#x3D;0;						&#x2F;&#x2F;头尾指针置为零，队列为空</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int queuelength(SQqueue &amp;sq)</span><br><span class="line">&#123;</span><br><span class="line">	return (sq.rear-sq.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：在没有特殊注明的情况下，所说队列都为循环队列，front指向队头元素，rear指向队尾元素的后一个元素，为区分队空与队满，此处少用一个元素空间，即队列空间大小为m-1个元素时队满，故而当队列满足“rear=front“时队空，当队列满足”(rear+1)%MAXSIZE=front“时队满。</p>
<h2 id="入队（从队尾插入）"><a href="#入队（从队尾插入）" class="headerlink" title="入队（从队尾插入）"></a>入队（从队尾插入）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool enterqueue(SQqueue &amp;sq,Elemtype e)		  &#x2F;&#x2F;传址需要操作的表，传值入队元素</span><br><span class="line">&#123;</span><br><span class="line">	if((sq.rear+1)%MAXSIZE&#x3D;&#x3D;sq.front) return false;    &#x2F;&#x2F;判断队满时返回失败</span><br><span class="line">	sq.base[sq.rear]&#x3D;e;					 &#x2F;&#x2F;让队尾元素的后一个元素等于e</span><br><span class="line">	sq.rear&#x3D;(sq.rear+1)%MAXSIZE;		 &#x2F;&#x2F;队尾指针后移</span><br><span class="line">	return true；						&#x2F;&#x2F;返回成功入队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="出队（从队头删除）"><a href="#出队（从队头删除）" class="headerlink" title="出队（从队头删除）"></a>出队（从队头删除）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool deletequeue(SQqueue &amp;sq,Elemtype &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	if(sq.front&#x3D;&#x3D;sq.rear) return false;		&#x2F;&#x2F;若队空，则返回出队失败</span><br><span class="line">	e&#x3D;sq.base[sq.front];					&#x2F;&#x2F;用e获得出队的队头元素</span><br><span class="line">	sq.front&#x3D;(sq.front+1)%MAXSIZE;			&#x2F;&#x2F;队头指针后移</span><br><span class="line">	return true;							&#x2F;&#x2F;返回成功出队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Elemtype gethead(SQqueue &amp;sq)</span><br><span class="line">&#x2F;&#x2F;仅返回表的队头元素，不修改头指针</span><br><span class="line">&#123;</span><br><span class="line">	if(sq.front!&#x3D;sq.rear) 			&#x2F;&#x2F;判断队列非空</span><br><span class="line">	return 	sq.base[sq.front];		&#x2F;&#x2F;返回队头元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-4-队列操作-20-分"><a href="#R7-4-队列操作-20-分" class="headerlink" title="R7-4 队列操作 (20 分)"></a>R7-4 队列操作 (20 分)</h2><p>请实现一个MyQueue类，实现出队，入队，求队列长度.</p>
<p>实现入队函数 void push(int x); 实现出队函数 int pop(); 实现求队列长度函数 int size();</p>
<p>输入格式:<br>每个输入包含1个测试用例。每个测试用例第一行给出一个正整数 n (n &lt;= 10^6) ，接下去n行每行一个数字，表示一种操作： 1 x ： 表示从队尾插入x，0&lt;=x&lt;=2^31-1。 2 ： 表示队首元素出队。 3 ： 表示求队列长度。</p>
<p>输出格式:<br>对于操作2,若队列为空，则输出 “Invalid”,否则请输出队首元素。 对于操作3，请输出队列长度。 每个输出项最后换行。</p>
<p>输入样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 100</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">Invalid</span><br><span class="line">1</span><br><span class="line">100</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQueue &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.front=<span class="number">0</span>;</span><br><span class="line">    sq.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(SQueue &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sq.rear-sq.front+<span class="number">50</span>)%<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enter</span><span class="params">(SQueue &amp;sq,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((sq.rear+<span class="number">1</span>)%<span class="number">50</span>==sq.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.base[sq.rear]=a;</span><br><span class="line">    sq.rear=(sq.rear+<span class="number">1</span>)%<span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(SQueue &amp;sq,<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.front==sq.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	a=sq.base[sq.front];</span><br><span class="line">	sq.front=(sq.front+<span class="number">1</span>)%<span class="number">50</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQueue L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">int</span> n,i,j,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;j;</span><br><span class="line">        <span class="keyword">switch</span>(j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">                enter(L,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(out(L,k)) <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Invalid&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;length(L)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-3</title>
    <url>/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</url>
    <content><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>【Elemtype为数据类型】</p>
<p>顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相较普通顺序表简单。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Elemtype *base;					<span class="comment">//定义栈底指针</span></span><br><span class="line">	Elemtype *top;					<span class="comment">//定义栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> maxsize;					<span class="comment">//定义最大栈的最大容量</span></span><br><span class="line">&#125;SQstack;</span><br></pre></td></tr></table></figure>


<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initstack</span><span class="params">(SQstack &amp;sq)</span>			<span class="comment">//传址需要初始化的表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sq.base=<span class="keyword">new</span> Elemtype[MAXSIZE];</span><br><span class="line">	<span class="comment">//分配大小为MAXSIZE的空间，并返回首地址给表的栈底指针</span></span><br><span class="line">	<span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//若分配失败则返回</span></span><br><span class="line">	sq.top=sq.base;					<span class="comment">//栈顶指针等于栈底指针，表示空栈</span></span><br><span class="line">	sq.maxsize=MAXSIZE;				<span class="comment">//记录栈的最大容量为MAXSIZE</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;					<span class="comment">//返回创建成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="入栈（从栈顶插入）"><a href="#入栈（从栈顶插入）" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SQstack &amp;sq,Elemtype e)</span>		<span class="comment">//传址需要操作的栈，传值需要入栈的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq.top-sq.base&gt;=sq.maxsize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//若栈顶指针与栈底指针的差为最大空间（即栈满），返回入栈失败</span></span><br><span class="line">    *sq.top=e;</span><br><span class="line">	<span class="comment">//栈顶指针总是指在栈顶元素的下一个位置，故而直接赋值</span></span><br><span class="line">	sq.top++;							<span class="comment">//栈顶指针后移</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">//返回入栈成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="出栈（从栈顶删除）"><a href="#出栈（从栈顶删除）" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SQstack &amp;sq,Elemtype &amp;e)</span>			<span class="comment">//传址需要操作的表和出栈的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">//若栈顶指针与栈底指针相同（即栈空），则返回失败</span></span><br><span class="line">	sq.top--;</span><br><span class="line">	<span class="comment">//栈顶指针总是指在栈顶元素的下一个位置，故而栈顶指针后移</span></span><br><span class="line">	e=*sq.top;								<span class="comment">//将出栈的元素传给e</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取栈顶（取值）"><a href="#取栈顶（取值）" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">gettop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要操作的表，返回栈顶元素，该操作只取栈顶，不修改栈顶指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sq.top!=sq.base)			<span class="comment">//若该栈非空</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">return</span> *(sq.top<span class="number">-1</span>);			<span class="comment">//取栈顶指针的前一个位置，即栈顶元素向外传递</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>【Elemtype为数据类型】</p>
<p>在无法估计栈数据量时，通常采用链式栈，而且因为栈的主要操作是插入和删除，所以用链表的头部作栈顶更加方便。</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Elemtype data;			<span class="comment">//定义链表结点的数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span>		<span class="comment">//定义指向下一节点的指针域</span></span><br><span class="line">&#125;*Linkstack;</span><br></pre></td></tr></table></figure>


<h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initstack</span><span class="params">(Linkstack &amp;ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ls=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//由于栈不需要对栈顶以外的元素操作，故而不需要设置头结点来使表头操作与表中表尾一致</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">//返回初始化成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="入栈（从栈顶插入）-1"><a href="#入栈（从栈顶插入）-1" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Linkstack &amp;ls,Elemtype e)</span>		<span class="comment">//传址需要操作的表，传值需要插入的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Lnode *p;</span><br><span class="line">	p=<span class="keyword">new</span> Lnode;				<span class="comment">//重新分配一个结点空间，首地址赋给p</span></span><br><span class="line">	p-&gt;data=e;					<span class="comment">//新结点的数据域为e</span></span><br><span class="line">	p-&gt;next=ls;					<span class="comment">//新结点的指针域指向头指针ls，即将新结点作头插</span></span><br><span class="line">	ls=p;						<span class="comment">//头指针前移</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;				<span class="comment">//返回入栈成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="出栈（从栈顶删除）-1"><a href="#出栈（从栈顶删除）-1" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(Linkstack &amp;ls，Elemtype &amp;e)</span>   <span class="comment">//传址需要操作的表和出栈的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ls==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//栈空则返回删除失败</span></span><br><span class="line">	e=ls-&gt;data;						<span class="comment">//e接收出栈元素</span></span><br><span class="line">	Lnode *p=ls;					<span class="comment">//定义一个p指针指向原栈顶元素</span></span><br><span class="line">	ls=ls-&gt;next;					<span class="comment">//让头指针后移</span></span><br><span class="line">	<span class="keyword">delete</span> p;						<span class="comment">//删除p指向的结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;					<span class="comment">//返回删除完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取栈顶（取值）-1"><a href="#取栈顶（取值）-1" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">gettop</span><span class="params">(Linkstack &amp;ls)</span>	<span class="comment">//传址需要操作的表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)				<span class="comment">//栈非空</span></span><br><span class="line">	<span class="keyword">return</span> ls-&gt;data;			<span class="comment">//返回栈顶元素的值，栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-1-堆栈操作合法性-20-分"><a href="#R7-1-堆栈操作合法性-20-分" class="headerlink" title="R7-1 堆栈操作合法性 (20 分)"></a>R7-1 堆栈操作合法性 (20 分)</h2><p>假设以S和X分别表示入栈和出栈操作。如果根据一个仅由S和X构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入S和X序列，判断该序列是否合法。</p>
<p>输入格式:<br>输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由S和X构成的序列。序列保证不为空，且长度不超过100。</p>
<p>输出格式:<br>对每个序列，在一行中输出YES如果该序列是合法的堆栈操作序列，或NO如果不是。</p>
<p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 10</span><br><span class="line">SSSXXSXXSX</span><br><span class="line">SSSXXSXXS</span><br><span class="line">SSSSSSSSSSXSSXXXXXXXXXXX</span><br><span class="line">SSSXXSXXX</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[m];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=m;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=e;</span><br><span class="line">    sq.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    SQstack L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        init(L,m);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;str[j]!=<span class="string">&#x27;\0&#x27;</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]==<span class="string">&#x27;S&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                flag=push(L,str[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[j]==<span class="string">&#x27;X&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                flag=pop(L);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.base==L.top&amp;&amp;flag==<span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="R7-2-回文判断-20-分"><a href="#R7-2-回文判断-20-分" class="headerlink" title="R7-2 回文判断 (20 分)"></a>R7-2 回文判断 (20 分)</h2><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p>
<p>输入格式:<br>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p>
<p>输出格式:<br>若字符序列是回文，输出“YES”；否则，输出“NO”。</p>
<p>输入样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abdba</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=a;</span><br><span class="line">    sq.top++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gettop</span><span class="params">(SQstack &amp;sq,<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.base==sq.top) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a=*(sq.top<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQstack L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> i,n=<span class="number">0</span>,a;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    n=str.size();</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n/<span class="number">2</span>) push(L,str[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                gettop(L,a);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(str[i]==a) pop(L);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;(n<span class="number">-1</span>)/<span class="number">2</span>) push(L,str[i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    gettop(L,a);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(str[i]==a) pop(L);</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="R7-3-括号匹配-20-分"><a href="#R7-3-括号匹配-20-分" class="headerlink" title="R7-3 括号匹配 (20 分)"></a>R7-3 括号匹配 (20 分)</h2><p>检查一段C语言代码的小括号( )、 中括号 [ ] 和大括号{ } 是否匹配。</p>
<p>输入格式:<br>在一行中输入一段C语言代码，长度不超过1000个字符（行末以换行符结束）。</p>
<p>输出格式:<br>第一行输出左括号的数量和右括号的数量，中间以一个空格间隔。<br>若括号是匹配的，在第二行打印YES，否则打印NO。</p>
<p>输入样例1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;v; i++)&#123; visited[i] &#x3D; 0; for(int j&#x3D;0; j&lt;v; j++) scanf(&quot;%d&quot;,&amp;(g-&gt;Adj[i][j])); &#125;</span><br></pre></td></tr></table></figure>
<p>输出样例1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 8</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>
<p>输入样例2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;v; i++) a(i]&#x3D;0;</span><br></pre></td></tr></table></figure>
<p>输出样例2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=<span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=a;</span><br><span class="line">    sq.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gettop</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a=*(sq.top<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQstack L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">char</span> a=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i,left=<span class="number">0</span>,right=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span>||str[i]==<span class="string">&#x27;[&#x27;</span>||str[i]==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            push(L,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>||str[i]==<span class="string">&#x27;]&#x27;</span>||str[i]==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">            gettop(L,a);</span><br><span class="line">            <span class="keyword">if</span>((str[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;a==<span class="string">&#x27;(&#x27;</span>)||(str[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;a==<span class="string">&#x27;[&#x27;</span>)||(str[i]==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;a==<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pop(L);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.top!=L.base) flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>) flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;left&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;right&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-2</title>
    <url>/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
    <content><![CDATA[<h1 id="线性表-单链表"><a href="#线性表-单链表" class="headerlink" title="线性表-单链表"></a>线性表-单链表</h1><p>【Elemtype为数据类型】</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="链表结点结构体创建"><a href="#链表结点结构体创建" class="headerlink" title="链表结点结构体创建"></a>链表结点结构体创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LNode        &#x2F;&#x2F;创建结点类型</span><br><span class="line">&#123;</span><br><span class="line">	elemtype data;         &#x2F;&#x2F;结点中包含数据域</span><br><span class="line">	struct LNode *next;    &#x2F;&#x2F;结点中包含指向下一个结点的指针</span><br><span class="line">&#125;*Linklist                 &#x2F;&#x2F;将该类型定义为一个链表（常使用指针方式价）</span><br></pre></td></tr></table></figure>


<h3 id="尾插法创建"><a href="#尾插法创建" class="headerlink" title="尾插法创建"></a>尾插法创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要创建的表L，以及初始表长n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;		<span class="comment">//为L新分配一个地址</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;		<span class="comment">//将L的next设为空（前两步为初始化）</span></span><br><span class="line">    Lnode *E=L;			<span class="comment">//令新指针指向L指向的头结点</span></span><br><span class="line">    <span class="keyword">int</span> i,a;</span><br><span class="line">	Lnode *p;			<span class="comment">//定义另一个指向结点的指针p</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)	</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a;			<span class="comment">//输入数据a</span></span><br><span class="line">     p=<span class="keyword">new</span> Lnode;		<span class="comment">//令p指向新建结点</span></span><br><span class="line">     p-&gt;data=a;			<span class="comment">//将新建结点的数据域赋值为a</span></span><br><span class="line">     E-&gt;next=p;			<span class="comment">//令E的next指向p指向的结点</span></span><br><span class="line">     p-&gt;next=<span class="literal">NULL</span>;		<span class="comment">//p的next指向空</span></span><br><span class="line">     E=p;				<span class="comment">//指针E后移，指向p指向的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="头插法创建"><a href="#头插法创建" class="headerlink" title="头插法创建"></a>头插法创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void create(Linklist &amp;L，int n)</span><br><span class="line">&#x2F;&#x2F;传址需要创建的表L，以及初始表长n</span><br><span class="line">&#123;</span><br><span class="line">	L&#x3D;new LNode;</span><br><span class="line">	L-&gt;next&#x3D;NULL;</span><br><span class="line">    int i,a;</span><br><span class="line">	struct LNode *p;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    for(i&#x3D;1;a!&#x3D;-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    p&#x3D;new LNode;</span><br><span class="line">    p-&gt;data&#x3D;a;</span><br><span class="line">    p-&gt;next&#x3D;L-&gt;next;</span><br><span class="line">    L-&gt;next&#x3D;p;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>注：初始化应当在尾插和头插法前使用，或者不使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span>       <span class="comment">//传址创建的链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L=<span class="keyword">new</span> LNode;            <span class="comment">//新生成一个结点，让头指针指向头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;          <span class="comment">//为统一操作，头结点仅作为首元结点的前驱，数据域不放入数据，且指针域指向空</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">//返回值提示完成初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>单链表的取值需要顺序遍历，耗时较长，故而不适合频繁获取特定位置的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getelem</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i,elemtype &amp;e)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址数据所在的表，并且传值需要取值的元素序号i，将得到的值传给e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	LNode *p=L-&gt;next;               <span class="comment">//令p指向首元结点</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i&amp;&amp;p!=<span class="literal">NULL</span>;j++)       <span class="comment">//j作为计数器，确定遍历到的位置，当p指针指向空或j==i时结束循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;                  <span class="comment">//让p指向p的下一个结点，实现p后移</span></span><br><span class="line">	&#125;                               <span class="comment">//结束循环时，j==i，p指向的结点为第i-1个结点</span></span><br><span class="line"> 	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//如果p指针指向空，则返回取值失败</span></span><br><span class="line">	e=p-&gt;next-&gt;data;                <span class="comment">//否则，将p指向结点的下一个结点的数据域赋给e</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;                   <span class="comment">//返回取值完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>单链表的查找同顺序表一样，需要遍历整个表，比较每个数据域和待查找值，若相同则返回其序号，若始终不相同则返回查找失败</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Linklist &amp;L,LNode *&amp;p,elemtype a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要查找的表，查找成功时用于指向查找结果的指针p，同时传值需要查找的数据a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;p-&gt;next!=<span class="literal">NULL</span>;j++)      <span class="comment">//j作为计数器，确定遍历到的位置，当p指针指向为空时结束循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data==a) <span class="keyword">break</span>;       <span class="comment">//查找到与数据a相同的数据域，提前退出循环</span></span><br><span class="line">		p=p-&gt;next;                  <span class="comment">//p指针继续后移，继续遍历整个链表</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=a)   <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">	<span class="comment">//如果p指针已经指向尾结点，且尾结点数据域域不等于a，则查找失败</span></span><br><span class="line">	<span class="comment">//p指针直接能够返回需要查找的节点，不需要另外设置返回</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;                   <span class="comment">//返回查找成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时，需要先让新结点连接需要插入位置前驱的后一个结点，再让前驱的next指针指向新结点，否则会直接丢失后面数据的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i，elem e)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址链表，需要插入的位置i，需要插入的元素值e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	Lnode *p=L-&gt;next;                <span class="comment">//使p指针指向首元结点</span></span><br><span class="line">	Lnode *s=<span class="keyword">new</span> Lnode;              <span class="comment">//新建一个结点，并用s指针指向它</span></span><br><span class="line">	s-&gt;data=e;                       <span class="comment">//将新建结点的数据域赋为e</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>;j++)      </span><br><span class="line">	<span class="comment">//当j移动到需要插入位置的前驱时或者链表结束时结束循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;                   <span class="comment">//让p指向下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">//如果p指向不合法位置则返回插入失败</span></span><br><span class="line">	s-&gt;next=p-&gt;next;                 <span class="comment">//否则让s的next指针指向p的下一个结点</span></span><br><span class="line">	p-&gt;next=s;                       <span class="comment">//并让p的next指针指向s</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;                     <span class="comment">//返回成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	Lnode *p=L-&gt;next;                <span class="comment">//使p指向首元结点</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>)           </span><br><span class="line">	<span class="comment">//当j移动到需要删除位置的前驱或链表结束时结束循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;                  <span class="comment">//让p指向p的下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">//p指向不合法位置时，返回删除失败</span></span><br><span class="line">	p-&gt;next=p-&gt;next-&gt;next;          <span class="comment">//让p的next指针等于p下一个结点的next</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;                    <span class="comment">//返回删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-3-单链表的创建及遍历-20-分"><a href="#R7-3-单链表的创建及遍历-20-分" class="headerlink" title="R7-3 单链表的创建及遍历 (20 分)"></a>R7-3 单链表的创建及遍历 (20 分)</h3><p>读入n值及n个整数，建立单链表并遍历输出。</p>
<p>输入格式:<br>读入n及n个整数。</p>
<p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p>
<p>输入样例:<br>在这里给出一组输入。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10 5</span><br></pre></td></tr></table></figure>

<p>输出样例:<br>在这里给出相应的输出。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(<span class="built_in">list</span>,n);</span><br><span class="line">    putout(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="R7-1-两个有序链表序列的合并-20-分"><a href="#R7-1-两个有序链表序列的合并-20-分" class="headerlink" title="R7-1 两个有序链表序列的合并 (20 分)"></a>R7-1 两个有序链表序列的合并 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p>
<p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<p>输出格式:<br>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>
<p>输入样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;a!=<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addit</span><span class="params">(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p1</span>=</span>l1-&gt;next,*p2=l2-&gt;next, *p3;</span><br><span class="line">    l3=l1;</span><br><span class="line">    p3=l3;</span><br><span class="line">    <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">	        <span class="keyword">if</span>(p1-&gt;data&lt;=p2-&gt;data)</span><br><span class="line">	        &#123;</span><br><span class="line">	        	p3-&gt;next=p1;</span><br><span class="line">	        	p3=p1;</span><br><span class="line">	        	p1=p1-&gt;next;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">else</span> &#123;</span><br><span class="line">	            p3-&gt;next=p2;</span><br><span class="line">	            p3=p2;</span><br><span class="line">	        	p2=p2-&gt;next;</span><br><span class="line">	        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=p1?p1:p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">                <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NULL&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist L1,L2,L3;</span><br><span class="line">	create(L1);</span><br><span class="line">	create(L2);</span><br><span class="line">	init(L3);</span><br><span class="line">    addit(L1,L2,L3);</span><br><span class="line">    putout(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="R7-2-两个有序链表序列的交集-20-分"><a href="#R7-2-两个有序链表序列的交集-20-分" class="headerlink" title="R7-2 两个有序链表序列的交集 (20 分)"></a>R7-2 两个有序链表序列的交集 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p>
<p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p>
<p>输出格式:<br>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p>
<p>输入样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 5 -1</span><br><span class="line">2 4 5 8 10 -1</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">	    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;a!=<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;p-&gt;next!=<span class="literal">NULL</span>;j++)      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==a) <span class="keyword">break</span>;       </span><br><span class="line">        p=p-&gt;next;                 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=a)   <span class="keyword">return</span> <span class="literal">false</span>;              </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cutit</span><span class="params">(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p1</span>=</span>l1-&gt;next,*p2=l2-&gt;next,*p3=l3;</span><br><span class="line">    <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span>(p1-&gt;data&lt;p2-&gt;data)</span><br><span class="line">    	&#123;</span><br><span class="line">    		p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;data==p2-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			p3-&gt;next=p1;</span><br><span class="line">			p3=p3-&gt;next;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">			p2=p2-&gt;next;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)</span><br><span class="line">		&#123;</span><br><span class="line">			p2=p2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p3-&gt;next!=<span class="literal">NULL</span>) p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NULL&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist L1,L2,L3;</span><br><span class="line">	create(L1);</span><br><span class="line">	create(L2);</span><br><span class="line">	init(L3);</span><br><span class="line">    cutit(L1,L2,L3);</span><br><span class="line">    putout(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-1</title>
    <url>/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
    <content><![CDATA[<h1 id="线性表-顺序表"><a href="#线性表-顺序表" class="headerlink" title="线性表-顺序表"></a>线性表-顺序表</h1><h2 id="创建（初始化）"><a href="#创建（初始化）" class="headerlink" title="创建（初始化）"></a>创建（初始化）</h2><p>以数组的形式创建顺序表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct      &#x2F;&#x2F;理解为将定义的结构体改称为&#123;&#125;后的名字，如SQlist</span><br><span class="line">&#123;</span><br><span class="line">	Elemtype *elem； &#x2F;&#x2F;定义顺序表具有首元素地址</span><br><span class="line">	int length;     &#x2F;&#x2F;定义顺序表具有表长这一属性</span><br><span class="line">&#125;SQlist;</span><br></pre></td></tr></table></figure>
<p>初始化设置顺序表的最大存储空间，以及初始化其表长为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool initList(SQlist &amp;sq)     &#x2F;&#x2F;将需要初始化的表传址</span><br><span class="line">&#123;</span><br><span class="line">	sq.elem&#x3D;new maxsize;        &#x2F;&#x2F;为顺序表分配maxsize的空间作为最大上限</span><br><span class="line">	if(!sq.elem) return false;      &#x2F;&#x2F;如果空间分配失败，直接返回提示错误</span><br><span class="line">	sq.length&#x3D;0;                    &#x2F;&#x2F;如果分配空间成功，则继续初始化表长为0</span><br><span class="line">	return true;                    &#x2F;&#x2F;返回参数提示顺序表初始化成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>顺序表能够随机存取，故而方便存取指定位置的值，即可以随机存取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool getelem(SQlist &amp;sq,int i，elemtype &amp;a)  </span><br><span class="line">&#x2F;&#x2F;将需要初始化的表传址，并且传值需要获取的是第i个值，返回的值传给a</span><br><span class="line">&#123;</span><br><span class="line">	if(i&lt;1||i&gt;sq.length) return false;    &#x2F;&#x2F;如果i为非法位置，返回提示错误</span><br><span class="line">	a&#x3D;sq.elem[i];                 &#x2F;&#x2F;否则返回第i个元素给a</span><br><span class="line">	return true;                  &#x2F;&#x2F;返回提示执行正常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序表的查找就是顺序比较表内元素和待查找元素，相同查找成功，始终不同查找失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int find(SQlist &amp;sq,elemtype a)</span><br><span class="line">&#x2F;&#x2F;传址需要查找的表，并传值需要查找的数值a,返回查找到的序号为int类型</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i&#x3D;0;i&lt;sq.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	if(sq.elem[i]&#x3D;&#x3D;a) return i;</span><br><span class="line">	&#x2F;&#x2F;如果查找到了，返回该值在表中的序号，此处为数组下标，若返回第几个元素序号，则需要i+1</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;            &#x2F;&#x2F;查找失败，返回负数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>顺序表为紧邻的线性表，故而插入时需要向后移动较多元素，并且需要从最后一个元素开始向后移动，以免数据被覆盖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool insert(SQlist &amp;sq,elemtype a,int i)</span><br><span class="line">&#x2F;&#x2F;将元素a的值插入表中第i个位置，传址需要做插入的表，以及传值a，i</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	if(i&lt;1||i&gt;sq.length+1) return false;&#x2F;&#x2F;如果i值不合法，则不作插入</span><br><span class="line">	if(sq.length&#x3D;&#x3D;maxsize) return false;&#x2F;&#x2F;如果表长已经达到最大，则判断表满，不作插入</span><br><span class="line">	for(j&#x3D;sq.length-1;j&gt;&#x3D;i-1;j--)</span><br><span class="line">	&#x2F;&#x2F;让j为最后一个元素的角标，循环递减，并且当j等于插入位置i的前驱时，停止循环</span><br><span class="line">	&#123;</span><br><span class="line">		sq.elem[j+1]&#x3D;sq.elem[j];        &#x2F;&#x2F;给j+1角标的空间赋值当前j角标的值，实现后移</span><br><span class="line">	&#125;</span><br><span class="line">	sq.elem[i-1]&#x3D;a;                     &#x2F;&#x2F;赋值第i个位置，即角标为i-1的空间为a</span><br><span class="line">	sq.length++;                        &#x2F;&#x2F;表长增加</span><br><span class="line">	return true;                        &#x2F;&#x2F;返回插入成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>顺序表的删除是将待删除位置后面的全部往前覆盖，向前移动较多元素，并且需要从待删除位置的后一个开始移动，以免覆盖数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool delete(SQlist &amp;sq,int i)</span><br><span class="line">&#x2F;&#x2F;传址需要删除元素的顺序表，并且传值需要删除的元素位置</span><br><span class="line">&#123;</span><br><span class="line">	int j;</span><br><span class="line">	if(i&lt;1||i&gt;sq.length) return false;   &#x2F;&#x2F;如果i值不合法，则不作插入</span><br><span class="line">	for(j&#x3D;i;j&lt;&#x3D;sq.length-1;j++)</span><br><span class="line">	&#x2F;&#x2F;将i位置之后的所有元素都向前移，并且循环在将最后一个元素移动到表长减一后的位置停止</span><br><span class="line">	&#123;</span><br><span class="line">		sq.elem[j-1]&#x3D;sq.elem[j];        &#x2F;&#x2F;被删位置后的元素全部前移</span><br><span class="line">	&#125;</span><br><span class="line">	sq.length--;                        &#x2F;&#x2F;表长减少</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-1-顺序表的建立及遍历-20-分"><a href="#R7-1-顺序表的建立及遍历-20-分" class="headerlink" title="R7-1 顺序表的建立及遍历 (20 分)"></a>R7-1 顺序表的建立及遍历 (20 分)</h3><p>读入n值及n个整数，建立顺序表并遍历输出。</p>
<p>输入格式:<br>读入n及n个整数</p>
<p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p>
<p>输入样例:<br>在这里给出一组输入。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-3 10 20 78</span><br></pre></td></tr></table></figure>
<p>输出样例:<br>在这里给出相应的输出。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-3 10 20 78</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(List &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sq.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">output</span><span class="params">(List &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq.a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;sq.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sq.a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List sqlist;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(sqlist);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqlist.a[i];</span><br><span class="line">        sqlist.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sqlist.length!=<span class="number">0</span>) </span><br><span class="line">        output(sqlist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="R7-2-jmu-ds-顺序表区间元素删除-20-分"><a href="#R7-2-jmu-ds-顺序表区间元素删除-20-分" class="headerlink" title="R7-2 jmu-ds-顺序表区间元素删除 (20 分)"></a>R7-2 jmu-ds-顺序表区间元素删除 (20 分)</h3><p>若一个线性表L采用顺序存储结构存储，其中所有的元素为整数。设计一个算法，删除元素值在[x,y]之间的所有元素，要求算法的时间复杂度为O(n)，空间复杂度为O(1)。</p>
<p>输入格式:<br>三行数据，第一行是顺序表的元素个数，第二行是顺序表的元素，第三行是x和y。</p>
<p>输出格式:<br>删除元素值在[x,y]之间的所有元素后的顺序表。</p>
<p>输入样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 1 9 10 67 12 8 33 6 2</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure>
<p>输出样例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 67 12 33 2</span><br></pre></td></tr></table></figure>


<p><strong>解法：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(sqlist &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(sqlist &amp;sq,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;sq.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sq.a[j]&gt;=x&amp;&amp;sq.a[j]&lt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=j;i&lt;sq.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sq.a[i]=sq.a[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            sq.length--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqlist List;</span><br><span class="line">    <span class="keyword">int</span> n,i,x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(List);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;List.a[i];</span><br><span class="line">        List.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    del(List,x,y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;List.a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;List.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;List.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-6:序列式容器STL deque</title>
    <url>/2021/05/19/c++%E5%AD%A6%E4%B9%A0-9/</url>
    <content><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>deque容器即双端队列容器，擅长在序列头部和尾部添加或删除元素，不擅长在序列中间添加或删除元素，且deque容器可以根据需要修改自身容量大小，但deque容器存储时，并不能保证所有元素都存储到连续的内存空间中</p>
<p>当需要向序列两端频繁添加或删除元素时，应该首选deque容器，同样需要引用同名头文件&lt; deque &gt;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;	<span class="comment">//创建一个空deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//创建具有10个元素的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">2</span>)</span></span>;	<span class="comment">//创建具有10个元素，且初值为2的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;	<span class="comment">//以d2为模板拷贝构造一个deque容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a,a+<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//拷贝构造一个装有其他类型容器中指定区域的元素的deque容器</span></span><br></pre></td></tr></table></figure>


<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素所在位置前一个位置的迭代器</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td>
</tr>
<tr>
<td>size()</td>
<td>返回实际元素个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，我们很少会用到这个函数</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素</td>
</tr>
<tr>
<td>push_front()</td>
<td>在序列的头部添加一个元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或一段元素</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程</td>
</tr>
</tbody></table>
<div class="tip warning"><p>

</p><p>和vector容器相比，额外增加了在容器头部添加和删除元素的成员函数，并删除了capacity()、reserve()和data()成员函数</p>
<p></p></div>



<h2 id="deque容器迭代器"><a href="#deque容器迭代器" class="headerlink" title="deque容器迭代器"></a>deque容器迭代器</h2><p>deque容器的迭代器类型是随机访问迭代器，相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p>
<div class="note danger flat"><p>迭代器的功能是遍历容器，在遍历的同时可以访问甚至修改容器中元素，但迭代器不能用来初始化空的deque容器（这一点和vector是一样的），故而如下代码错误：</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    *first = <span class="number">1</span>;		<span class="comment">//该处错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><p>对于空的deque容器，可以通过push_back()、push_front()、resize()成员函数实现添加元素</p>
</div>

<p>此外，向deque容器添加元素时，deque容器会申请更多的内存空间，其包含的所有元素可能会被复制或移动到新的内存地址，导致之前创建的迭代器失效（这点和vector容器也是一样的）</p>
<h2 id="访问deque容器"><a href="#访问deque容器" class="headerlink" title="访问deque容器"></a>访问deque容器</h2><ol>
<li>容器名[n]——可能越界【通用】</li>
<li>at（）函数访问——性能较前者会有所损耗，但较安全【通用】</li>
<li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li>
</ol>
<div class="tip warning"><p>

</p><p>注：deque容器没有提供data（）函数，同时deque容器存储时不保证存储在连续空间中，故而应该尽可能避免用指针去访问deque容器中指定位置处的元素</p>
<p></p></div>



<h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><p>deque提供增删元素的成员函数如下：</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>push_back()</td>
<td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的一个元素</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器尾部的一个元素</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>C++11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td>
</tr>
<tr>
<td>emplace_front()</td>
<td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置</td>
</tr>
<tr>
<td>emplace()</td>
<td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程</td>
</tr>
<tr>
<td>erase()</td>
<td>移除一个元素或某一区域内的多个元素</td>
</tr>
<tr>
<td>clear()</td>
<td>删除容器中所有的元素</td>
</tr>
</tbody></table>
<p><strong>在实际应用中，常用emplace()、emplace_front()和emplace_back()分别替代函数insert()、push_front()和push_back()</strong></p>
<p>其中insert()可以有四种语法格式：insert（pos，elem）、insert（pos，n，elem）、insert（pos，first，last）以及insert（pos initlist），具体使用参见vector容器篇的说明</p>
<p><strong>emplace系列函数参数说明：</strong></p>
<ul>
<li>emplace(pos,args)函数：pos为指定位置，元素将插入到该位置之前，args对应元素数据类型的构造函数参数</li>
<li>emplace_first(args)函数：将元素插入到容器头部，args对应元素数据类型的构造函数参数</li>
<li>emplace_back(args)函数：将元素插入到容器尾部，args对应元素数据类型的构造函数参数</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul>
<li>deque&lt;数据类型&gt; 数组名(数据个数，初始值)；【参数可省】</li>
<li>deque&lt;数据类型&gt; 数组名(另一个deque容器)；</li>
<li>deque&lt;数据类型&gt; 数组名(首地址，尾地址)；</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul>
<li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p>
</li>
<li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p>
</li>
<li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul>
<li>容器名[n]——可能越界</li>
<li>at（）函数访问——性能较前者会有所损耗，但较安全</li>
<li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li>
<li>deque容器没有data（）函数，且存储空间不连续，不建议用指针</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><ul>
<li>增添元素：insert()、push_front()、push_back</li>
<li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li>
<li>删除元素：erase()【删除一部分】、clear()【清空容器】</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>





<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.push_back(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.push_back(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.push_front(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.size());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.begin(); i &lt; d.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>元素个数为：4<br>0 1 2 3</p>
<p></p></div>

<br>

<br>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> end = d.cend();</span><br><span class="line">    <span class="comment">//常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6;//尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10;//尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">//常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;end)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>1 2 3 4 5</p>
<p></p></div>

<br>

<br>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改首元素</span></span><br><span class="line">    d.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改尾元素</span></span><br><span class="line">    d.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>deque 首元素为：1<br>deque 尾元素为：5<br>deque 新的首元素为：10<br>deque 新的尾元素为：20</p>
<p></p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-5:序列式容器STL vector</title>
    <url>/2021/05/16/c++%E5%AD%A6%E4%B9%A0-8/</url>
    <content><![CDATA[<h1 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>vector是stl中最常用的容器之一，和array非常相似，但vector实现的是可以插入删除的动态数组，且会自动调整所占用的内存空间，而array只是静态的，容量固定的数组</p>
<p>vector被称为向量容器，在尾部插入和删除元素效率很高，而下头部或中部插入删除的话效率稍低，定义时需要引用头文件&lt; vector &gt;，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure>
<p>以上生成了一个空的vector容器，因为没有元素，所以也并没有分配空间，当添加第一个元素时，vector会自动分配内存</p>
<p>同样也可以在创建的同时指定初始值以及元素个数，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如上，创建了一个有5个元素的vector容器</p>
<p>或者是直接指定元素个数，所有默认初始值都为0,也可以自行赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>,<span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如上创建了一个含20个double类型的数据的vector容器，并且设定的初始值都为1.0</p>
<p>另外，圆括号中的两个参数都可以用变量代替，而且存储元素类型相同的vector容器也可以用于创建新的vector容器（复制的方式）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value1(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value2(value1);</span><br></pre></td></tr></table></figure>
<p>在此基础上，如果不想复制其他容器中所有的内容，可以用指针或迭代器来指定初始值的范围：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>);	<span class="comment">//values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value2(<span class="built_in">std</span>::begin(value1),<span class="built_in">std</span>::begin(value1)+<span class="number">3</span>);	<span class="comment">//新创建的value2包含&#123;1,2,3&#125;这3个元素</span></span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

</p><p>由于vector的类模板也位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略（上述已经省略）</p>
<p></p></div>

<br>

<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; vector &gt;中也封装并提供了可供使用的成员函数：</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody><tr>
<td>size()</td>
<td>返回实际元素个数</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td>
</tr>
<tr>
<td>reserve()</td>
<td>增加容器的容量</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小</td>
</tr>
<tr>
<td>operator[ ]</td>
<td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素</td>
</tr>
<tr>
<td>at()</td>
<td>使用经过边界检查的索引访问元素</td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用</td>
</tr>
<tr>
<td>data()</td>
<td>返回指向容器中第一个元素的指针</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容</td>
</tr>
<tr>
<td>push_back()</td>
<td>在序列的尾部添加一个元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移出序列尾部的元素</td>
</tr>
<tr>
<td>insert()</td>
<td>在指定的位置插入一个或多个元素</td>
</tr>
<tr>
<td>erase()</td>
<td>移出一个元素或一段元素</td>
</tr>
<tr>
<td>clear()</td>
<td>移出所有的元素，容器大小变为 0</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素</td>
</tr>
</tbody></table>
<h2 id="vector容器迭代器"><a href="#vector容器迭代器" class="headerlink" title="vector容器迭代器"></a>vector容器迭代器</h2><p>vector容器的迭代器也是随机访问迭代器，并且vector模板类提供的操作迭代器的成员函数也和array一样</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中首元素的正向迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器”尾元素+1“的正向迭代器，此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向尾元素的反向迭代器</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向“首元素-1”的反向迭代器，通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td>
</tr>
</tbody></table>
<p>此外，c++11新增的begin（）和end（）全局函数也同样适用，和表中的两个同名成员函数作用相同</p>
<h3 id="vector迭代器的特点"><a href="#vector迭代器的特点" class="headerlink" title="vector迭代器的特点"></a>vector迭代器的特点</h3><p>vector容器可以随存储元素的增加，自行申请更多的存储空间，故而创建一个空的vector容器并不会影响该容器后续的使用</p>
<p>但<strong>在初始化空的vector时，不能使用迭代器</strong>（没有存储数据的容器是没有分配存储空间的，也就没有指向这个空间的指针），因为对于空的vector容器来说，begin（）和end（）成员函数返回的迭代器是相同的，可以看做指针指向同一个位置</p>
<div class="note danger flat"><p>故而，因为创建的vector容器values为空，没有分配存储空间，使用迭代器初始化不成功，如下代码将没有输出</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.begin(); first &lt; values.end(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;	<span class="comment">//初始化的同时输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note success flat"><p>对于空的vector容器来说，可以通过调用push_back()或者借助resize()成员函数实现初始化容器的目的</p>
</div>

<p><strong>此外，vector容器在申请更多内存时，容器中的所有元素可能会被复制或移动到新的内存地址，会导致之前创建的迭代器失效</strong></p>
<div class="note danger flat"><p>如下，values 容器在增加容量之后，元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    values.reserve(<span class="number">20</span>);	<span class="comment">//增加 values 的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将在输出以下结果后崩溃：</p>
<div class="snote paperclip light"><p>
values 容器首个元素的地址：0096DFE8

</p><p>values 容器首个元素的地址：00965560</p>
<p></p></div>

<div class="note success flat"><p>为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍，修改的部分代码如下：</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">first = values.begin();</span><br><span class="line">end = values.end();</span><br><span class="line"><span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">    ++first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<div class="snote paperclip light"><p>
values 容器首个元素的地址：0164DBE8

</p><p>values 容器首个元素的地址：01645560</p>
<p>123</p>
<p></p></div>



<h2 id="访问vector容器"><a href="#访问vector容器" class="headerlink" title="访问vector容器"></a>访问vector容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>vector容器同样可以使用容器名[i]【因为有[]运算符重载，但该重载为了提高效率，同样没有设置边界检查操作】和at（）成员函数的方式获取容器中的元素的值，亦或是data（）成员函数【用于返回指向首个元素的指针】</p>
<p>除此之外，vector容器还提供两个成员函数，front（）可以返回第一个元素的引用，back（）返回最后一个元素的引用</p>
<h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>vector依旧有提供size（）成员函数作为循环结束的条件帮助完成容器遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

</p><p>注：size（）成员函数返回的是实际存储元素的个数，而capacity（）成员函数返回的是vector容器的总容积，两者有所差别</p>
<p></p></div>

<p>或者使用for(auto &amp;c:s)完成基于范围的循环，配合begin（）成员函数和end（）成员函数成对使用也可以完成用vector迭代器对vector容器的遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first=values.begin(); first&lt;values.end(); ++first) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="增加容器中的元素"><a href="#增加容器中的元素" class="headerlink" title="增加容器中的元素"></a>增加容器中的元素</h2><h3 id="从容器尾部添加"><a href="#从容器尾部添加" class="headerlink" title="从容器尾部添加"></a>从容器尾部添加</h3><p>能够用于给容器添加元素的函数，在vector容器提供的成员函数中有两个，分别是push_back()和emplace_back()函数</p>
<p>push_back()和emplace_back()函数都是在vector容器尾部添加一个元素，用法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);		<span class="comment">//上下两行代码实现的效果相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，push_back()和emplace_back()函数的使用方法完全一样，看上去就像是直接替代而已</p>
<div class="tip warning"><p>

</p><p>两者的区别在于底层实现的机制不同，push_back()会先随便创建一个元素m，然后将元素的值拷贝或移动到容器的元素n中，会多一个将元素m复制给n，然后析构m的过程，而emplace_back()则是直接在容器尾部创建元素n，故而后者的效率比前者高，但考虑到兼顾c++11标准以前的版本，前者也依然保留使用</p>
<p></p></div>

<h3 id="从容器中间插入"><a href="#从容器中间插入" class="headerlink" title="从容器中间插入"></a>从容器中间插入</h3><p>在vector容器中的指定位置插入元素可以调用成员函数insert()和emplace()</p>
<p>insert()有四种语法格式：</p>
<table>
<thead>
<tr>
<th>语法格式</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>insert（pos，elem）</td>
<td>在迭代器pos指定的位置之前插入一个新元素elem，返回表示新元素插入位置的迭代器</td>
</tr>
<tr>
<td>insert（pos，n，elem）</td>
<td>在迭代器pos指定的位置之前插入n个元素elem，并返回表示第一个新元素插入位置的迭代器</td>
</tr>
<tr>
<td>insert（pos，first，last）</td>
<td>在迭代器pos指定的位置之前，插入其他容器（不限于vector中位于[first，last）区域的所有元素，并返回第一个新元素插入位置的迭代器</td>
</tr>
<tr>
<td>insert（pos，initlist）</td>
<td>在迭代器pos指定的位置之前，插入初始化列表中的所有元素，并返回表示第一个新插入元素位置的迭代器</td>
</tr>
</tbody></table>
<p>相较insert（），emplace（）是c++11标准新增加的成员函数，用于在vector中指定位置之前插入<strong>一个</strong>新的元素，函数声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator pos,args……)</span></span>;</span><br></pre></td></tr></table></figure>
<p>pos为指定插入位置的迭代器，args对应新插入元素构造函数的多个参数，返回值为新插入元素位置的迭代器</p>
<p>同push_back()和emplace_back()函数的关系一样，insert()和emplace()函数插入单个元素时效果是一样的，但emplace()是直接在指定位置构造元素，而不需要移动，所以效率比insert()高，但无法兼顾c++11标准前的编译器</p>
<h2 id="删除容器中的元素"><a href="#删除容器中的元素" class="headerlink" title="删除容器中的元素"></a>删除容器中的元素</h2><p>对于访问、添加、插入元素来说，都只能借助vector模板类提供的成员函数，但删除vector容器元素还可以借助一些全局函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>pop_back()</td>
<td>删除 vector 容器中<strong>最后一个元素</strong>，该容器的size减1，capacity不变</td>
</tr>
<tr>
<td>erase(pos)</td>
<td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td>
</tr>
<tr>
<td>swap(begin)、pop_back()</td>
<td>先调用 swap()函数【需要引入头文件algorithm或者utility】交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素，<strong>容器中元素顺序会被打乱</strong></td>
</tr>
<tr>
<td>erase(begin,end)</td>
<td><strong>删除</strong> vector 容器中位于<strong>迭代器 [begin,end)指定区域内的所有元素</strong>，并返回指向被删除的下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td>
</tr>
<tr>
<td>remove()</td>
<td><strong>删除容器中所有和指定元素值相等</strong>的元素【需要引用头文件algorithm】，并返回指向最后一个元素下一个位置的迭代器，由于该容器的size和capacity均不变，所以遍历需要借助remove()返回的迭代器，否则可能溢出</td>
</tr>
<tr>
<td>clear()</td>
<td><strong>删除 vector 容器中所有的元素</strong>，使其变成空的 vector 容器。该容器的size减为0，capacity不变</td>
</tr>
</tbody></table>
<p>remove()函数删除掉容器中多个指定元素后，容器大小和容量都没有改变，其剩余位置还保留了之前存储的元素，这些无用的元素可以用erase()删除，故此，remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用,如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::remove(demo.begin(), demo.end(), <span class="number">3</span>);	<span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.erase(iter, demo.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;	<span class="comment">//输出剩余的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>

</p><p>size is :3<br>capacity is :6<br>1 4 5</p>
<p></p></div>



<h2 id="容器扩容问题"><a href="#容器扩容问题" class="headerlink" title="容器扩容问题"></a>容器扩容问题</h2><p>vector容器本身是动态存储的，而多数stl版本中vector容器的自动扩容后容量都会提高到原来的两倍，然后将存储的所有元素按序复制到新的存储空间中，并析构以前存储的元素，释放旧的存储空间，由此可知，整个过程是十分耗时的</p>
<p>故而，虽然vector容器在增添新元素且容量不足时会自动扩容，但考虑到程序效率，还是应该在创建后用reverse()函数设定元素容量为足够大，尽可能避免在原有存储空间已满的情况下还添加新元素，以免vector容器进行不必要的扩容</p>
<h2 id="vector-lt-bool-gt"><a href="#vector-lt-bool-gt" class="headerlink" title="vector&lt; bool &gt;"></a>vector&lt; bool &gt;</h2><p>vector&lt; bool &gt;并不是存储bool类型的vector容器，和普通vector&lt; T &gt;模板的底层实现是不一样的，被特殊处理过，存储单位是bit而不是常用的byte</p>
<p>由于其特殊性，vector&lt; bool &gt;不能支持一些容器该有的基本操作，一般来说尽可能避免使用vector&lt; bool &gt;，取而代之的是，<strong>可以使用deque&lt; bool &gt;来取代，两者功能基本相同</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="vector"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#vector-1">定义方式</button></li><li class="tab"><button type="button" data-href="#vector-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#vector-3">迭代器特点</button></li><li class="tab"><button type="button" data-href="#vector-4">访问元素</button></li><li class="tab"><button type="button" data-href="#vector-5">添删元素</button></li><li class="tab"><button type="button" data-href="#vector-6">其他注意</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="vector-1"><ul>
<li>vector&lt;数据类型&gt; 容器名{每个元素的值}；</li>
<li>vector&lt;数据类型&gt; 容器名(数据个数，初始值)；【参数可省】</li>
<li>vector&lt;数据类型&gt; 容器名(另一个vector容器)；</li>
<li>vector&lt;数据类型&gt; 容器名(首地址，尾地址)；</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-2"><ul>
<li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p>
</li>
<li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p>
</li>
<li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-3"><ul>
<li>初始化空的vector时，不可以使用迭代器</li>
<li>在申请更多内存时，容器中元素存储地址可能被更新，造成之前创建的迭代器失效</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-4"><p>对于单个元素：</p>
<ul>
<li>用容器名[i]的方式——直接访问，性能最高</li>
<li>使用at()函数——可避免越界</li>
<li>使用front()和back()函数——返回第一个/最后一个元素的引用</li>
<li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li>
</ul>
<p>对于多个元素：</p>
<ul>
<li>使用size（）函数作为条件循环获取</li>
<li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-5"><ul>
<li>增添元素：insert()、push_front()、push_back</li>
<li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li>
<li>删除元素：</li>
<li><ul>
<li>pop_back()【删除最后一个元素】</li>
<li>erase()【删除一部分，后续前移】</li>
<li>clear()【清空容器】</li>
<li>remove()【删除和指定值相等的元素】</li>
</ul>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-6"><ul>
<li>vector容器虽然能够自动扩容，但耗时较多，应该用reverse（）函数修改容量而避免不必要的自动扩容</li>
<li>vector&lt; bool &gt;不是存储bool类型的vector容器，不支持基本操作，可以使用deque&lt; bool &gt;替代</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>




<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value;	<span class="comment">//初始化一个空vector容量</span></span><br><span class="line">    value.push_back(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;L&#x27;</span>);	<span class="comment">//向value容器中的尾部依次添加 S、T、L 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, value.size());<span class="comment">//调用 size() 成员函数容器中的元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = value.begin(); i &lt; value.end(); i++) 	<span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">    value.insert(value.begin(), <span class="string">&#x27;C&#x27;</span>);	<span class="comment">//向容器开头插入字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; value.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>
元素个数为：3

</p><p>S T L</p>
<p>首个元素为：C</p>
<p></p></div>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    <span class="keyword">while</span> (first != end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>
1 2 3 4 5

</p></div>

]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-4:序列式容器STL array</title>
    <url>/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/</url>
    <content><![CDATA[<h1 id="array-lt-T-N-gt-（数组容器）"><a href="#array-lt-T-N-gt-（数组容器）" class="headerlink" title="array&lt;T,N&gt;（数组容器）"></a>array&lt;T,N&gt;（数组容器）</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>在c++的普通数组上新增了一些成员函数和全局函数的容器，使用时需要调用对应的&lt; array &gt;头文件，示意如下图：</p>
<p><img src="/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/1.png" alt="1"></p>
<p>在array&lt;T,N&gt;类模板中，T用于指明数据类型，N表示数据个数，一旦建立则长度固定不变，即不能增加和删除，只能改变某个元素的值，故N也必须是常量，不可以用变量表示</p>
<p>如下语句为创建一个具有5个char类型元素的array容器，其名为value，{}负责初始化（没有初始化可省略），未被初始化的值将默认设为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,5&gt; values&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

</p><p>由于array的类模板位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略</p>
<p></p></div>

<br>

<h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; array &gt;中不仅封装了array容器的定义，也提供了可供使用的成员函数，调用成员函数的时候可以直接通过类的方式调用，即：array容器的名称.成员函数（）</p>
<p>【此处有关迭代器的成员函数被后置到下一个小标题，可通过目录跳转查看】</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>size()</td>
<td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td>
</tr>
<tr>
<td>empty()</td>
<td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td>
</tr>
<tr>
<td>at(n)</td>
<td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td>
</tr>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody></table>
<p>此外，get（）全局函数也被array头文件重载，该重载函数的功能是访问容器中指定元素并返回该元素的引用<br><br></p>
<h2 id="array容器迭代器"><a href="#array容器迭代器" class="headerlink" title="array容器迭代器"></a>array容器迭代器</h2><p>array容器配备的迭代器是功能最为强大的随机访问迭代器</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td>
</tr>
</tbody></table>
<div class="tip warning"><p>

</p><p>注：代码中的auto关键字可以使编译器自动判定变量的类型，并完成该类型变量的定义，以上函数在实际使用时，都可以用auto代替其返回值类型，编译器可以自行判断出该迭代器的类型</p>
<p></p></div>



<h3 id="begin（）-end（）和cbegin（）-cend（）"><a href="#begin（）-end（）和cbegin（）-cend（）" class="headerlink" title="begin（）/end（）和cbegin（）/cend（）"></a>begin（）/end（）和cbegin（）/cend（）</h3><p>begin()和end()返回正向迭代器对象，分别指向“首元素”和“尾元素+1”的位置，在实际使用中，可以利用其完成初始化容器和遍历容器中元素</p>
<p>由于c++11的全局中begin（）和end（）函数也能够从容器中获取迭代器，且当操作对象是array时，能够与封装的函数通用，故而以下两者是等价的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = values.begin();	<span class="comment">//用封装的函数begin（）定义</span></span><br><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::begin(values);	<span class="comment">//用全局函数begin（）定义</span></span><br></pre></td></tr></table></figure>
<p>cbegin（）/cend（）返回的是const类型的正向迭代器，可以用于遍历容器中元素，可以访问元素，但无法修改所存储的元素，这一点和c++中被const关键字控制的数据和函数都无法进行元素修改</p>
<h3 id="rbegin（）-rend（）和crbegin（）-crend（）"><a href="#rbegin（）-rend（）和crbegin（）-crend（）" class="headerlink" title="rbegin（）/rend（）和crbegin（）/crend（）"></a>rbegin（）/rend（）和crbegin（）/crend（）</h3><p>rbegin（）/rend（）可以分别返回指向最后一个元素和指向第一个元素前一个位置的随机访问迭代器，又称反向迭代器，用于逆序的方式处理元素。</p>
<div class="tip warning"><p>

</p><p>注：在使用反向迭代器进行++和–运算的时候，++指的是迭代器向左移动一位，–指的是迭代器向右移动一位，即和正向时相比，两个运算符的功能也互换了</p>
<p></p></div>

<p>而crbegin（）和crend（）和上述的唯一差别也在于返回的迭代器为const类型，不能用于修改容器中的元素，除此之外，使用上和上述完全相同</p>
<h2 id="访问array容器"><a href="#访问array容器" class="headerlink" title="访问array容器"></a>访问array容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>首先，可以通过**容器名[]**的方式直接访问和使用容器中的元素，和普通数组访问元素的方式相同，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2</span>*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p>
<p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2</span>*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码和前一行语句相比，当发生越界时，程序会抛出out_of_range异常，所以除非确定没有越界，否则at（）比直接引用会更加安全</p>
<p>当然，如果每次访问元素都去检查是否越界的话，无疑会产生很多性能开销，当不可能越界时，还是避免为好</p>
<p>array 容器还提供了 get&lt; n &gt; 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素，但是其中n只能是一个常量表达式，不可以是循环变量</p>
<p>array的成员函数中还有着data（）函数，该函数返回一个指向元素的指针，可以使用【*（a+i）】的方式访问容器中各个元素的值</p>
<h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>可以利用size（）函数【返回值为size_t】作为循环条件访问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.size() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，对于任何可以使用迭代器的容器都可以使用基于范围的循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure>
<div class="tip warning"><p>

</p><p>注：for(auto &amp;c:s)是在c11标准下可以执行的特殊格式的for循环语句，区别在于引用类型可以改变原来的值，可以对容器中的内容进行赋值，即可通过对c赋值来做到容器s的填充，在不加“&amp;”引用符号时，可以利用c遍历并获得s容器中的每个值，但c无法改变s容器中的元素</p>
<p></p></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="array"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#array-1">定义方式</button></li><li class="tab"><button type="button" data-href="#array-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#array-3">访问元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="array-1"><p>array&lt;数据类型，数据个数（常数）&gt; 数组名{可省略的初始化列表}；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-2"><ul>
<li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p>
</li>
<li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p>
</li>
<li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p>
</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-3"><p>对于单个元素：</p>
<ul>
<li>用容器名[i]的方式——直接访问，性能最高</li>
<li>使用at()函数——可避免越界</li>
<li>使用get&lt; n &gt;对固定位置的元素访问——n只能使用常量</li>
<li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li>
</ul>
<p>对于多个元素：</p>
<ul>
<li>使用size（）函数作为条件循环获取</li>
<li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	//需要引入 array 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values&#123;&#125;;	<span class="comment">//初始化 values 容器为 &#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        values.at(i) = i;	<span class="comment">//使用 get() 重载函数输出指定位置元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">3</span>&gt;(values) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">//如果容器不为空，则输出容器中所有的元素</span></span><br><span class="line">    <span class="keyword">if</span> (!values.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val = values.begin(); val &lt; values.end(); val++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>

</p><p>3<br>0 1 2 3</p>
<p></p></div>




<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values1;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; values1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.at(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="keyword">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.begin(); i &lt; values1.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.begin(); i &lt; values2.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<div class="snote paperclip light"><p>


</p><p>values1[0] is : 0<br>values1[1] is : 1<br>values1[2] is : 2<br>Values1 is : 0 1 2 3 4<br>Values2 is : 10 11 12 13 14</p>
<p></p></div>

<br>

<br>


<div class="tip warning"><p>

</p><p>题外话：由于STL标准库不是只有array容器，当迭代器指向容器中一个特定元素时，迭代器不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，迭代器到底指向array容器还是vector容器</p>
<p>（即：只知道一个数据的类型和存储它的地址，无法判断这一整组数据是静态数组还是动态数组）</p>
<p></p></div>]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-3：STL库基础</title>
    <url>/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/</url>
    <content><![CDATA[<h1 id="STL库基本组成"><a href="#STL库基本组成" class="headerlink" title="STL库基本组成"></a>STL库基本组成</h1><table>
<thead>
<tr>
<th>STL组成</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>封装数据结构的模板类，如vector向量容器、list列表等</td>
</tr>
<tr>
<td>算法</td>
<td>许多被设计成模板的数据结构算法在命名空间中定义，大部分包含在algorithm头文件中，少部分位于numeric头文件</td>
</tr>
<tr>
<td>迭代器</td>
<td>在C++STL中，对容器中数据的读和写，是通过迭代器完成的</td>
</tr>
<tr>
<td>函数对象</td>
<td>一个将运算符重载为成员函数的类叫函数对象类，这个类的对象就是函数对象</td>
</tr>
<tr>
<td>适配器</td>
<td>可以使一个类的接口（模板的参数适配成用户指定的形式，让本来不能在一起工作的两个类工作在一起</td>
</tr>
<tr>
<td>内存分配器</td>
<td>为容器类模板提供自定义的内存申请和释放功能</td>
</tr>
</tbody></table>
<p>C++标准中，STL头文件被组织为13个：</p>
<ul>
<li>iterator：定义了一些迭代器模板</li>
<li>functional：定义一些函数对象类型和支持函数对象的功能</li>
<li>vector：类似数组，需要所有元素为统一类型，定义vector容器和vector对象的操作</li>
<li>deque：封装双端队列，定义deque容器和deque对象操作</li>
<li>list：封装列表，定义list容器和list对象操作</li>
<li>queue：封装队列（只有一端可操作，有点栈的感觉，但先进先出），定义queue容器和queue对象操作</li>
<li>stack：封装堆栈，定义stack容器和stack对象操作</li>
<li>set：封装二叉树（红黑树），定义set对象和set对象操作</li>
<li>map：封装加权二叉树（红黑树），定义map对象和map对象操作</li>
<li>algorithm：定义多种算法，例如升降序排序、查找之类的</li>
<li>numeric：定义了基础性的数值算法</li>
<li>memory</li>
<li>utility</li>
</ul>
<br>

<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>STL容器就是封装了数据结构的模板类的集合，提有三类标准容器：序列容器、排序容器和哈希容器，后两类有时也统称关联容器。</p>
<table>
<thead>
<tr>
<th>容器种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>序列容器</td>
<td>主要包括vector向量容器、list列表容器以及deque双端队列容器。元素在容器中的位置同元素值无关，插入元素时指定在什么位置，元素就位于什么位置。</td>
</tr>
<tr>
<td>排序容器</td>
<td>包括set集合容器、multiset多重集合容器、map映射容器、multimap多重映射容器。元素默认从小到大排列，插入元素时同样插入到合适的位置，所以在查找时具有非常好的性能。</td>
</tr>
<tr>
<td>哈希容器</td>
<td>包括4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。容器中的元素是未排序的，位置由哈希函数决定。【c++11的编译器下才能使用，VS支持，gcc/g++编译器是不支持的】</td>
</tr>
</tbody></table>
<h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>以线性排列来存储数据，且不进行排序的容器，有如下几种：</p>
<ul>
<li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li>
<li>vector&lt; T &gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li>
<li>deque&lt; T &gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li>
<li>list&lt; T &gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt; T &gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li>
<li>forward_list&lt; T &gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li>
</ul>
<div class="tip warning"><p>注：虽然stack< T >和queue< T >本质上也是序列容器，但都是在deque的基础上改造的，更习惯称为容器适配器</p><p></p></div>

<h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器，在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比序列式容器，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。</p>
<p>相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。</p>
<br>

<h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>迭代器和c++的指针非常相似，可以是任何需要的类型，通过迭代器可以指向容器中的某个元素，也可以执行读写操作。</p>
<p>迭代器的功能强弱决定了容器是否支持STL的某种算法。</p>
<p>常用迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p>
<p>【其中输入/输出迭代器不是把数组和容器当做操作对象，而是将输入/输出流作为对象，较为特殊。】</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-2">双向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-3">随机访问迭代器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>已知p是一个前向迭代器，则p支持++p，p++，*p操作，可以被复制或赋值，可以用==和！=运算符进行比较，且两个正向迭代器可以相互赋值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>具有正向迭代器的所有功能，同时具有–p或p–的操作（即一次向后移动一个位置）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>具有双向迭代器的全部功能，可以用&lt;、&gt;、&lt;=、&gt;=运算符比较，且p2-p1有意义，为p2指向元素和p1指向元素的序号差</p>
<p>当i为整型变量或常量时：</p>
<ul>
<li>p+=i：往后移动i个元素</li>
<li>p-=i：往前移动i个元素</li>
<li>p+i：返回p后面第i个元素的迭代器</li>
<li>p-i：返回p前面第i个元素的迭代器</li>
<li>p[i]：返回p后面第i个元素的引用</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<table>
<thead>
<tr>
<th>容器</th>
<th>对应迭代器类型</th>
</tr>
</thead>
<tbody><tr>
<td>array</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>vector</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>deque</td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td>list</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>set/multiset</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>map/multimap</td>
<td>双向迭代器</td>
</tr>
<tr>
<td>forward_list</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_map/unordered_multimap</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>unordered_set/unordered_multiset</td>
<td>前向迭代器</td>
</tr>
<tr>
<td>stack</td>
<td>不支持迭代器</td>
</tr>
<tr>
<td>queue</td>
<td>不支持迭代器</td>
</tr>
</tbody></table>
<div class="tip warning"><p>注：容器适配器stack和queue没有迭代器，其本身具有一些成员函数，用于对元素进行访问</p><p></p></div>

<br>

<h1 id="迭代器定义方式"><a href="#迭代器定义方式" class="headerlink" title="迭代器定义方式"></a>迭代器定义方式</h1><table>
<thead>
<tr>
<th>定义方式</th>
<th>格式</th>
</tr>
</thead>
<tbody><tr>
<td>正向迭代器</td>
<td>::iterator 迭代器名;</td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td>::const_iterator 迭代器名;</td>
</tr>
<tr>
<td>反向迭代器（反向迭代器适配器）</td>
<td>::reverse_iterator 迭代器名;</td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td>::const_reverse_iterator 迭代器名;</td>
</tr>
</tbody></table>
<div class="tip warning"><p>

</p><p>注意事项：</p>
<ul>
<li>读取迭代器指向的元素使用和指针一样的方法：*迭代器名</li>
<li>反向迭代器和正向迭代器：正向迭代器使用p++时，迭代器指向容器中后一个元素，而反向迭代器使用p++时，迭代器指向前一个元素</li>
<li>常量迭代器和非常量迭代器：常量迭代器同c++中const声明是几乎一样的，所以只有通过非常量迭代器才能修改其指向的元素</li>
<li>如容器array、deque、vector同时支持4种，但并不是每个容器都适用以上4种定义迭代器的方式，如forward_list只支持正向迭代器而不支持反向迭代器</li>
</ul>
<p></p></div>

<p>以下为范例1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;				//需要引入vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;			<span class="comment">//v被初始化为有5个元素</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第1次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)			<span class="comment">//可以通过v.size()的方式得到元素个数</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;				<span class="comment">//可以像普通数组一样使用vector容器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第2次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">	<span class="keyword">for</span> (i = v.begin(); i ！= v.end(); i++)		<span class="comment">//能用v.begin()和v.end()的方式获得首末元素的地址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;					<span class="comment">//可以用*迭代器名的方式获取元素值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第3次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	i = v.begin();</span><br><span class="line">	<span class="keyword">while</span> (i &lt; v.end())					<span class="comment">//实现间隔一个元素输出</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		i += <span class="number">2</span>;					<span class="comment">//随机访问迭代器支持“+=整型”的操作</span></span><br><span class="line">	&#125;</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上运行结果为：</p>
<div class="snote paperclip light"><p>

</p><p>第1次遍历v<br>1 2 3 4 5 6<br>第2次遍历v<br>1 2 3 4 5 6<br>第3次遍历v<br>1 3 5</p>
<p></p></div>

<div class="tip warning"><p>

</p><p>注：VisualStudio在调试时不会检查迭代器越界问题，但运行时系统会弹窗报错”cannot seek vector iterator after end”</p>
<p></p></div>

<br>

<p>以下为范例2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure>

<div class="note success flat"><p>以下代码合法：</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i != v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用”&lt;”比较：</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i &lt; v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure>
<div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用下标随机访问比较：</p>
</div>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL库</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-2：string头文件</title>
    <url>/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/</url>
    <content><![CDATA[<h1 id="头文件：string"><a href="#头文件：string" class="headerlink" title="头文件：string"></a>头文件：string</h1><h2 id="用于简化操作的常用函数"><a href="#用于简化操作的常用函数" class="headerlink" title="用于简化操作的常用函数"></a>用于简化操作的常用函数</h2><ul>
<li><p>string变量读取单个字符用s[i]可以读出</p>
</li>
<li><p>输入带空格的字符串，用getline(cin,a)；(a为字符串类型变量)</p>
</li>
<li><p>str.=“”——清空</p>
</li>
<li><p>str.empty()——是否为空</p>
</li>
<li><p>str.size()——str长度</p>
</li>
<li><p>swap(s1，s2)——交换s1，s2</p>
</li>
<li><p>str. insert(x,“aaa”)——在下标x处插入aaa</p>
</li>
<li><p>str.substr(x,y)——读出下标为x开始长度为y的字符串</p>
</li>
<li><p>str.erase(x,y)——移除下标x长度为y的字符</p>
</li>
<li><p>str.find(“字符或字符串”)——找str中第一次出现的下标，找不到就是-1</p>
</li>
<li><p>while((i=str.find(“a”,i))!=-1) { i++; cout&lt;&lt;i&lt;&lt;endl; }  ——读出所有a字符出现的下标</p>
<p>  (基本思路是找到一个就从那个下标+1继续找)</p>
</li>
<li><p>str.replace(x，y，“aa”)——用aa替换(x，y)(删掉下标x开始长度为y个，在下标为x处插入aa)</p>
</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>string s——生成一个空字符串s</p>
<p>string s(str) ——拷贝构造函数 生成str的复制品</p>
<p>string s(str,stridx)——将字符串str内“始于位置stridx”的部分当作字符串的初值</p>
<p>string s(str,stridx,strlen) ——将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</p>
<p>string s(cstr) ——将C字符串作为s的初值</p>
<p>string s(chars,chars_len) ——将C字符串前chars_len个字符作为字符串s的初值。</p>
<p> string s(num,c) ——生成一个字符串，包含num个c字符</p>
<p> string s(beg,end) ——以区间beg;end(不包含end)内的字符作为字符串s的初值</p>
<p>s.~string() ——销毁所有字符，释放内存</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><p> =，assign()——赋以新值</p>
</li>
<li><p>swap()——交换两个字符串的内容</p>
</li>
<li><p>+=，append()，push_back()——在尾部添加字符</p>
</li>
<li><p>insert()——插入字符</p>
</li>
<li><p>erase()——删除字符</p>
</li>
<li><p>clear()——删除全部字符</p>
</li>
<li><p>replace()——替换字符</p>
</li>
<li><p>+——串联字符串</p>
</li>
<li><p>==，!=，&lt;，&lt;=，&gt;，&gt;=，compare()——比较字符串</p>
</li>
<li><p>size(),length()——返回字符数量</p>
</li>
<li><p>max_size()——返回字符的可能最大个数</p>
</li>
<li><p>empty()——判断字符串是否为空</p>
</li>
<li><p>capacity()——返回重新分配之前的字符容量</p>
</li>
<li><p>reserve()——保留一定量内存以容纳一定数量的字符</p>
</li>
<li><p> [ ], at()——存取单一字符</p>
</li>
<li><p>“&gt;&gt;”,getline()——从stream读取某值</p>
</li>
<li><p>” &lt;&lt;“ ——将谋值写入stream</p>
</li>
<li><p>copy()——将某值赋值为一个C_string</p>
</li>
<li><p>c_str()——将内容以C_string返回</p>
</li>
<li><p> data()——将内容以字符数组形式返回</p>
</li>
<li><p>substr()——返回某个子字符串</p>
</li>
<li><p>begin() end()——提供类似STL的迭代器支持</p>
</li>
<li><p> rbegin() rend()——逆向迭代器</p>
</li>
<li><p>get_allocator()——返回配置器</p>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p>
<p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。</p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++拓展-1：algorithm头文件</title>
    <url>/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<h1 id="头文件：algorithm"><a href="#头文件：algorithm" class="headerlink" title="头文件：algorithm"></a>头文件：algorithm</h1><p>algorithm意为”算法”,是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p>
<h2 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h2><ol>
<li><strong>容器</strong> 容器是用来存放各种数据的一个东西，<code>&lt;algorithm&gt;</code>中的算法是针对容器设计的。因此，不论数据是一些<code>int</code>，<code>char</code>还是自定义的<code>class</code>，<code>&lt;algorithm&gt;</code>中的函数都可以正确应对。<code>vector</code>是最常用的容器。</li>
<li><strong>迭代器</strong> 迭代器是与容器进行配套使用的。它的作用是对容器中的元素进行遍历，比如数组的指针就可以看作一种迭代器。迭代器一般支持解引用（<code>operator*()</code>）、自加（<code>operator++()</code>）、相等（<code>operator==()</code>）等操作。</li>
<li><strong>谓词</strong> 谓词是用来对<code>&lt;algorithm&gt;</code>中的函数进行定制操作的。谓词可以是lambda表达式或是函数/函数指针，并且<code>&lt;algorithm&gt;</code>中只有一元谓词和二元谓词，即函数只能接收一个或两个参数。对于需要额外参数的谓词可以使用lambda表达式的捕获功能。</li>
<li><strong><code>pair</code></strong> 部分算法会有两个返回值，<code>pair</code>有两个成员<code>first</code>和<code>second</code>，用来将两个值进行打包返回。</li>
</ol>
<h2 id="用到的主要参数说明"><a href="#用到的主要参数说明" class="headerlink" title="用到的主要参数说明"></a>用到的主要参数说明</h2><ul>
<li><code>beg</code>和<code>end</code>是表示元素范围的迭代器。</li>
<li><code>beg2</code>是第二个输入序列开始位置的迭代器，<code>end2</code>表示第二个序列末尾位置（如果有的话）。如果没有<code>end2</code>，则假定<code>beg2</code>表示的序列与<code>beg</code>和<code>end</code>表示的序列一样大。<code>beg</code>和<code>beg2</code>不必是相同的类型，但两个序列中的元素都要能调用给定的可调用对像。比如<code>beg</code>是一个<code>std::vector&lt;int&gt;::iterator</code>，而<code>beg2</code>可以是一个<code>std::deque&lt;int&gt;::iterator</code>。</li>
<li><code>dest</code>是表示目的序列的迭代器，目的序列必须保证能够存储算法生成的所有元素。若无法确定大小，可以调用<code>std::back_inserter()</code>函数获取目的序列的插入迭代器。</li>
<li><code>unaryPred</code>和<code>binayPred</code>是一元和二元谓词，其实参都是序列中的元素。</li>
<li><code>comp</code>是一个二元谓词，用于比较两个元素。</li>
<li><code>unaryOp</code>和<code>binaryOp</code>是可调用对象。</li>
</ul>
<p>此外，部分算法要求序列是有序的，默认是使用小于运算符（<code>&lt;</code>）定义的升序。若使用谓词版本，则有序是按<code>comp</code>升序。</p>
<h2 id="常用函数及用法"><a href="#常用函数及用法" class="headerlink" title="常用函数及用法"></a>常用函数及用法</h2><h3 id="非修改性序列操作（12个）"><a href="#非修改性序列操作（12个）" class="headerlink" title="非修改性序列操作（12个）"></a>非修改性序列操作（12个）</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul>
<li>对序列中的每个元素执行某操作 for_each()</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>在序列中找出某个值的第一次出现的位置 find()   利用底层元素的等于操作符，对范围内的元素与输入的值进行比较。当匹配时，结束搜索，返回该元素的一个 InputIterator 。</li>
<li>在序列中找出符合某谓词的第一个元素 find_if()</li>
<li>在序列中找出一子序列的最后一次出现的位置 find_end()</li>
<li>在序列中找出第一次出现指定值集中之值的位置 find_first_of()</li>
<li>在序列中找出相邻的一对值 adjacent_find()</li>
</ul>
<h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><ul>
<li>在序列中统计某个值出现的次数 count()</li>
<li>在序列中统计与某谓词匹配的次数 count_if()</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul>
<li>找出两个序列相异的第一个元素 mismatch()</li>
<li>两个序列中的对应元素都相同时为真 equal()</li>
</ul>
<h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul>
<li>在序列中找出一子序列的第一次出现的位置 search()</li>
<li>在序列中找出一值的连续n次出现的位置 search_n()</li>
</ul>
<h3 id="修改性序列操作（27个）"><a href="#修改性序列操作（27个）" class="headerlink" title="修改性序列操作（27个）"></a>修改性序列操作（27个）</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul>
<li>从序列的第一个元素起进行复制 copy()</li>
<li>从序列的最后一个元素起进行复制 copy_backward()</li>
</ul>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul>
<li>交换两个元素 swap()</li>
<li>交换指定范围的元素 swap_ranges()</li>
<li>交换由迭代器所指的两个元素 iter_swap()</li>
</ul>
<h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><ul>
<li>将某操作应用于指定范围的每个元素 transform()</li>
</ul>
<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul>
<li>用一个给定值替换一些值 replace()</li>
<li>替换满足谓词的一些元素 replace_if()</li>
<li>复制序列时用一给定值替换元素 replace_copy()</li>
<li>复制序列时替换满足谓词的元素 replace_copy_if()</li>
</ul>
<h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul>
<li>用一给定值取代所有元素 fill()</li>
<li>用一给定值取代前n个元素 fill_n()</li>
</ul>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><ul>
<li>用一操作的结果取代所有元素 generate()</li>
<li>用一操作的结果取代前n个元素 generate_n()</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul>
<li>删除具有给定值的元素 remove()</li>
<li>删除满足谓词的元素 remove_if()</li>
<li>复制序列时删除具有给定值的元素 remove_copy()</li>
<li>复制序列时删除满足谓词的元素 remove_copy_if()</li>
</ul>
<h4 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h4><ul>
<li>删除相邻的重复元素 unique()</li>
<li>复制序列时删除相邻的重复元素 unique_copy()</li>
</ul>
<h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ul>
<li>反转元素的次序 reverse()</li>
<li>复制序列时反转元素的次序 reverse_copy()</li>
</ul>
<h4 id="环移"><a href="#环移" class="headerlink" title="环移"></a>环移</h4><ul>
<li>循环移动元素 rotate()</li>
<li>复制序列时循环移动元素 rotate_copy()</li>
</ul>
<h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><ul>
<li>采用均匀分布来随机移动元素 random_shuffle()</li>
</ul>
<h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul>
<li>将满足某谓词的元素都放到前面 partition()</li>
<li>将满足某谓词的元素都放到前面并维持原顺序 stable_partition()</li>
</ul>
<h3 id="序列排序及相关操作（27个）"><a href="#序列排序及相关操作（27个）" class="headerlink" title="序列排序及相关操作（27个）"></a>序列排序及相关操作（27个）</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul>
<li>以很好的平均效率排序 sort()</li>
<li>并维持相同元素的原有顺序 stable_sort()</li>
<li>将序列的前一部分排好序 partial_sort()</li>
<li>复制的同时将序列的前一部分排好序 partial_sort_copy()</li>
<li>将第n各元素放到它的正确位置 nth_element()</li>
</ul>
<h4 id="二分检索"><a href="#二分检索" class="headerlink" title="二分检索"></a>二分检索</h4><ul>
<li>找到大于等于某值的第一次出现 lower_bound()</li>
<li>找到大于某值的第一次出现 upper_bound()</li>
<li>找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()</li>
<li>在有序序列中确定给定元素是否存在 binary_search()</li>
</ul>
<h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><ul>
<li>归并两个有序序列 merge()</li>
<li>归并两个接续的有序序列 inplace_merge()</li>
</ul>
<h4 id="有序结构上的集合操作"><a href="#有序结构上的集合操作" class="headerlink" title="有序结构上的集合操作"></a>有序结构上的集合操作</h4><ul>
<li>一序列为另一序列的子序列时为真 includes()</li>
<li>构造两个集合的有序并集 set_union()</li>
<li>构造两个集合的有序交集 set_intersection()</li>
<li>构造两个集合的有序差集 set_difference()</li>
<li>构造两个集合的有序对称差集（并-交） set_symmetric_difference()</li>
</ul>
<h4 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h4><ul>
<li>向堆中加入元素 push_heap()</li>
<li>从堆中弹出元素 pop_heap()</li>
<li>从序列构造堆 make_heap()</li>
<li>给堆排序 sort_heap()</li>
</ul>
<h4 id="最大和最小"><a href="#最大和最小" class="headerlink" title="最大和最小"></a>最大和最小</h4><ul>
<li>两个值中较小的 min()</li>
<li>两个值中较大的 max()</li>
<li>序列中的最小元素 min_element()</li>
<li>序列中的最大元素 max_element()</li>
</ul>
<h4 id="词典比较"><a href="#词典比较" class="headerlink" title="词典比较"></a>词典比较</h4><ul>
<li>两个序列按字典序的第一个在前 lexicographical_compare()</li>
</ul>
<h4 id="排列生成器"><a href="#排列生成器" class="headerlink" title="排列生成器"></a>排列生成器</h4><ul>
<li>按字典序的下一个排列 next_permutation()</li>
<li>按字典序的前一个排列 prev_permutation() </li>
</ul>
<p>其他详细内容：<a href="https://www.lagou.com/lgeduarticle/9665.html">https://www.lagou.com/lgeduarticle/9665.html</a></p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>网页设计-4</title>
    <url>/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/</url>
    <content><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>css中的盒模型相当于礼物的外包装盒，封装周围的HTML元素，包括外边距（margin），边框（border），内边距（padding）和实际内容（content），常用的div元素就是一种区块容器标记，可以将网页分隔为不同的部分，以实现网页的规划和布局。</p>
<p>纵深结构来说，盒模型自下而上为：外边距、背景颜色、背景图像、内边距、内容、边框</p>
<p><img src="/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/1.PNG" alt="1"></p>
<div class="tip important font5 fas fa-bell"><p>css代码中的宽和高（width和height）指的是如下部分：</p><p>盒子的总宽度=width+左右内边框之和+左右边框宽度之和+左右外边距之和</p><p>盒子的总高度=height+上下内边距之和+上下边框宽度之和+上下外边框之和</p></div>

<br>

<h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><p>边框主要包括边框宽度、边框样式、边框颜色、此外还有border的综合属性，在CSS3中添加了圆角边距，图片边距属性。</p>
<ul>
<li><p>边框宽度（border-width）：用于设置元素边框的宽度值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-width</span>：上边距宽度<span class="selector-attr">[右边距宽度 下边距宽度 左边距宽度]</span>;</span><br><span class="line"></span><br><span class="line">其中，宽度由数字和单位组成，不可为负数，常以像素（<span class="selector-tag">px</span>）为单位，且设定1个值时全部应用，设定2~3个值时，省略的部分将使用对边的样式</span><br></pre></td></tr></table></figure></li>
<li><p>边框样式（border-style）：用于设置样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-style</span>：上边框样式<span class="selector-attr">[右边框样式 下边框样式 左边框样式]</span>;</span><br><span class="line"></span><br><span class="line">其中，设置时必须按上右下左的顺时针顺序，当设置1个值时为4边，2个值为上下/左右，3个值为上/左右/下，也可以通过形如<span class="selector-tag">border-left-style</span>的方式分别设置</span><br></pre></td></tr></table></figure>
<p>样式取值共9种，如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>不显示边框（默认）</td>
<td>groove</td>
<td>边框带有立体感的沟槽</td>
</tr>
<tr>
<td>dotted</td>
<td>点线</td>
<td>ridge</td>
<td>边框成脊形</td>
</tr>
<tr>
<td>dashed</td>
<td>虚线</td>
<td>inset</td>
<td>使整个方框凹陷</td>
</tr>
<tr>
<td>solid</td>
<td>实线</td>
<td>outset</td>
<td>使整个方框凸起</td>
</tr>
<tr>
<td>double</td>
<td>双实线</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>边框颜色（border-color）：用于定义边框的颜色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-color</span>:上边框颜色<span class="selector-attr">[右边框颜色 下边框颜色 左边框颜色]</span>;</span><br><span class="line"></span><br><span class="line">其中，颜色值符合定义法，有十六进制<span class="selector-id">#RRGGBB</span>和<span class="selector-tag">RGB</span>代码、<span class="selector-tag">rgb</span>(<span class="selector-tag">r</span>,<span class="selector-tag">g</span>,<span class="selector-tag">b</span>)三种，仅定义几个值的样式应用方式同上两种，可以通过形如<span class="selector-tag">border-left-color</span>的方式分别定义，（上使用<span class="selector-tag">top</span>，下使用<span class="selector-tag">bottom</span>）</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>边框综合属性（border）</p>
<p>border为复合属性，前三者的简写方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">border&lt;边框宽度&gt;|&lt;边框样式&gt;|&lt;颜色&gt;;</span><br><span class="line"></span><br><span class="line">在复合属性中，边框<span class="selector-tag">border</span>同时设置4条边，如只需要1条边框应用该样式，需要通过形如<span class="selector-tag">border-left</span>的方式分别设置</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><h3 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h3><p>主要用于调整内容在盒子中的值，指内容content和边框border的距离，也被称作内填充。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>:上内边距值<span class="selector-attr">[右内边距值 下内边距值 左内边距值]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>边距值为数字和单位组成，不可为负值，常用像素（px）为单位，也可以是百分比，随父元素width变化而变化，和height无关</li>
<li>padding遵循复制原则，也可以通过形如padding-left的方式设置样式</li>
</ul>
<h3 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h3><p>margin指元素边框和相邻元素之间的距离（盒子和盒子的距离）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>:上外边距值<span class="selector-attr">[右外边距值 下外边距值 左外边距值]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>margin为复合属性，同padding用法类似，但可以使用负值，使相邻元素重叠，若盒元素使用了宽度属性，设margin为auto时，可以实现盒元素居中</li>
<li>margin也遵循复制原则，可通过形如margin-left的方式设置样式</li>
</ul>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>网页设计</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title>网页设计-3</title>
    <url>/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/</url>
    <content><![CDATA[<h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="css格式定义"><a href="#css格式定义" class="headerlink" title="css格式定义"></a>css格式定义</h3><p>css样式设置由选择器和声明部分组成，示例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器类型&#123;</span><br><span class="line">	属性1:值1;</span><br><span class="line">	属性2:值2;</span><br><span class="line">	…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，作为分隔每个属性的标志，最末尾的属性后的分号可以省略，但规范上是不省略的</p>
<h3 id="css样式调用"><a href="#css样式调用" class="headerlink" title="css样式调用"></a>css样式调用</h3><p>分为：行内样式表，内部样式表，链入外部样式表</p>
<p>以下为链入外部样式表的两种方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方法1：<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;相对地址&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheeet&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">方法2：<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="keyword">@import</span> url(<span class="string">&quot;相对地址&quot;</span>);</span></span><br><span class="line">	  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注：也可以在当前网页内以css的方式写入本网页的样式（如行内样式表和内部样式表），但是该样式仅作用于该网页，而且夹杂于内容中，故不推荐使用</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器：p、hn等标签"><a href="#标签选择器：p、hn等标签" class="headerlink" title="标签选择器：p、hn等标签"></a>标签选择器：p、hn等标签</h3><p>代表该标签的共性，用css修改时，将会作用于当前网页所有该标签</p>
<p>调用方式：直接使用定义的标签</p>
<p>选择器类型：指定的标签名字</p>
<h3 id="类选择器：以-开头"><a href="#类选择器：以-开头" class="headerlink" title="类选择器：以.开头"></a>类选择器：以.开头</h3><p>把相同类型的元素分类定义成不同的样式，用css修改时，将改变这一类的所有元素样式</p>
<p>调用方式：class=”类选择器的名字”（多个效果可用空格隔开）</p>
<p>选择器类型：.类选择器名</p>
<p><strong>注意：</strong></p>
<ul>
<li>不要试图用一个类名，把某个标签的所有样式写完，一个标签应该多携带几个类</li>
<li>每个类要尽可能的小，以达到公共性</li>
</ul>
<h3 id="id选择器：以-开头"><a href="#id选择器：以-开头" class="headerlink" title="id选择器：以#开头"></a>id选择器：以#开头</h3><p>代表某一元素的个性，用css修改时，只改变当前元素的样式</p>
<p>调用方式：id=”id选择器的名字”</p>
<p>选择器类型：#id选择器的名字</p>
<p>注：id选择器在文档中只能使用一次，而类选择器可以使用多次</p>
<h3 id="通配符选择器：“-”"><a href="#通配符选择器：“-”" class="headerlink" title="通配符选择器：“*”"></a>通配符选择器：“*”</h3><p>作用于所有的标签样式，用css修改时会改变所有使用该css的网页样式</p>
<p>使用方式：不需要调用，在css文件链接时直接附加</p>
<h3 id="群组选择器-并集选择器：“-”"><a href="#群组选择器-并集选择器：“-”" class="headerlink" title="群组选择器/并集选择器：“,”"></a>群组选择器/并集选择器：“,”</h3><p>表达“或”的含义，部分样式相同或完全相同时使用</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名1,标签名2,……&#123;属性表&#125;</span><br></pre></td></tr></table></figure>


<h3 id="标签指定式选择器-交集选择器"><a href="#标签指定式选择器-交集选择器" class="headerlink" title="标签指定式选择器/交集选择器"></a>标签指定式选择器/交集选择器</h3><p>表达“和”的含义，同时使用标签选择器和类选择器或者同时使用标签选择器和id选择器</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名.类名&#123;属性表&#125;</span><br><span class="line">标签名#id&#123;属性表&#125;</span><br></pre></td></tr></table></figure>


<h3 id="包含选择器-后代选择器"><a href="#包含选择器-后代选择器" class="headerlink" title="包含选择器/后代选择器"></a>包含选择器/后代选择器</h3><p>选择元素或元素组的后代，也称后代选择器，把外层标签写在前面，内层标签写在后面，中间用空格分隔</p>
<p>使用方式：（两个选择器中间必须有空格）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器1 选择器2&#123;属性表&#125;</span><br></pre></td></tr></table></figure>


<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>为拥有指定属性的html元素设置样式，不局限于class和id属性，下表以attribute代替属性选择器名</p>
<table>
<thead>
<tr>
<th align="center">选择器</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[attribute]</td>
<td align="center">选取带有指定属性的元素</td>
</tr>
<tr>
<td align="center">[attribute=value]</td>
<td align="center">选取带有指定属性且取值为value的元素</td>
</tr>
<tr>
<td align="center">[attribute~=value]</td>
<td align="center">选取属性值中包含指定词汇的元素</td>
</tr>
<tr>
<td align="center">[attribute|=value]</td>
<td align="center">选取带有指定值开头的属性值的元素，值必须是整个单词</td>
</tr>
<tr>
<td align="center">[attribute^=value]</td>
<td align="center">匹配属性值以指定值开头的每个元素</td>
</tr>
<tr>
<td align="center">[attribute$=value]</td>
<td align="center">匹配属性值以指定值结尾的每个元素</td>
</tr>
<tr>
<td align="center">[attribute]*=value]</td>
<td align="center">匹配属性值中包含指定值的每个元素</td>
</tr>
</tbody></table>
<p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标签名[属性选择器名]&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">选择器为<span class="selector-attr">[attribute]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here]</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">选择器为<span class="selector-attr">[attribute=value]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here=red]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><p>主要包括子元素选择器，相邻兄弟选择器，普通兄弟选择器</p>
<table>
<thead>
<tr>
<th align="center">属性名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">子元素选择器（E&gt;F）</td>
<td align="center">选择所有作为E元素的<strong>直接子元素</strong>F，对更深一层的元素不起作用</td>
</tr>
<tr>
<td align="center">兄弟相邻选择器（E+F)</td>
<td align="center">选择<strong>紧跟</strong>在E元素<strong>后面</strong>的F元素，选择相邻的第一个兄弟元素</td>
</tr>
<tr>
<td align="center">普通兄弟选择器（E~F）</td>
<td align="center">选择E元素之后的<strong>所有</strong>兄弟元素F，作用于多个元素</td>
</tr>
</tbody></table>
<p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">子元素选择器：</span><br><span class="line">标签名&gt;子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签内，直接子元素的<span class="selector-tag">a</span>标签都为红色</span><br><span class="line"></span><br><span class="line">兄弟相邻选择器：</span><br><span class="line">标签名+子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签同级的紧挨的下一个<span class="selector-tag">a</span>标签为红色</span><br><span class="line"></span><br><span class="line">普通兄弟选择器：</span><br><span class="line">标签名~子元素标签名&#123;属性表&#125;</span><br><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签后的所有同级的<span class="selector-tag">a</span>标签都是红色</span><br></pre></td></tr></table></figure>


<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="超链接伪类选择器"><a href="#超链接伪类选择器" class="headerlink" title="超链接伪类选择器"></a>超链接伪类选择器</h4><table>
<thead>
<tr>
<th align="center">伪类名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a:link</td>
<td align="center">未访问时的超链接状态</td>
</tr>
<tr>
<td align="center">a:visited</td>
<td align="center">访问后的超链接的状态（也可用于普通非链接元素:visited）</td>
</tr>
<tr>
<td align="center">a:hover</td>
<td align="center">鼠标经过、悬停时超链接的状态</td>
</tr>
<tr>
<td align="center">a:active</td>
<td align="center">鼠标单击不动时超链接的状态（也可用于普通非链接元素:active）</td>
</tr>
</tbody></table>
<p><strong><em>注：</em></strong></p>
<ul>
<li><strong><em>样式必须符合link、visited、hover、active顺序</em></strong></li>
<li><strong><em>在css定义中，a:hover必须被置于a:link和a:visited后才有效</em></strong></li>
<li><strong><em>a:active必须被置于a:hover之后才有效</em></strong></li>
</ul>
<p>使用方法：（以a:link和h1为例）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">a:link&#123;属性表&#125;       &lt;!--超链接伪类选择器--&gt;</span><br><span class="line">h1:hover&#123;属性表&#125;	  &lt;!--普通非链接元素伪类选择器--&gt;</span><br></pre></td></tr></table></figure>


<h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:root</td>
<td align="center">将样式绑定到页面的根元素中（即指位于文档树中最顶层结构的html标签）</td>
</tr>
<tr>
<td align="center">:not</td>
<td align="center">用于选择除某个元素之外的所有元素</td>
</tr>
<tr>
<td align="center">:empty</td>
<td align="center">指定当元素内容为空白时使用的样式</td>
</tr>
<tr>
<td align="center">:target</td>
<td align="center">对页面中某个target元素指定样式，只在用户点击链接并跳转到target元素后生效</td>
</tr>
</tbody></table>
<p>其中，:target使用时，前面不需要添加标签名，在锚点跳转后应用于跳转到的位置</p>
<h4 id="子元素伪类选择器"><a href="#子元素伪类选择器" class="headerlink" title="子元素伪类选择器"></a>子元素伪类选择器</h4><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:first-child</td>
<td>对父元素中的第一个子元素指定样式</td>
</tr>
<tr>
<td>:last-child</td>
<td>对父元素中的最后一个子元素指定样式</td>
</tr>
<tr>
<td>:only-child</td>
<td>当某个父元素中只有一个子元素时使用的样式</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>对指定序号的子元素设置样式（正数），表示第几个子元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>对指定序号的子元素设置样式（正数），表示倒数第几个子元素</td>
</tr>
<tr>
<td>:nth-child(even)</td>
<td>所有正数第偶数个子元素，等同于:nth-child(2n)</td>
</tr>
<tr>
<td>:nth-child(odd)</td>
<td>所有正数第奇数个子元素，等同于:nth-child(2n+1)</td>
</tr>
<tr>
<td>:nth-last-child(even)</td>
<td>所有倒数第偶数个子元素</td>
</tr>
<tr>
<td>:nth-last-child(odd)</td>
<td>所有倒数第奇数个子元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>用于匹配属于父元素的特定类型的第n个子元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>用于匹配属于父元素的特定类型的倒数第n个子元素</td>
</tr>
</tbody></table>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是针对css中已经定义的伪元素使用的选择器，css中主要使用的伪元素为“:before”伪元素选择器和”:after”伪元素选择器</p>
<h4 id="before伪元素选择器"><a href="#before伪元素选择器" class="headerlink" title=":before伪元素选择器"></a>:before伪元素选择器</h4><p>用于在被选元素的内容前面插入内容，必须配合“content”属性来指定要插入的具体内容</p>
<p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>element表示元素，“{}”中的content属性用来指定要插入的具体内容，既可以为文本也可以为图片</p>
<h4 id="after伪元素选择器"><a href="#after伪元素选择器" class="headerlink" title=":after伪元素选择器"></a>:after伪元素选择器</h4><p>用于在被选元素内容的后面插入内容，必须配合“content”属性来指定要插入的具体内容</p>
<p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>如果子元素定义的样式没有和父元素冲突，那么将继承父元素的样式，可以再加以修改，并不会影响父元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如上，strong标签为em标签的父元素，em标签为strong标签的子元素</p>
<p><strong><em>注：</em></strong></p>
<ul>
<li><strong><em>实际开发中，通常对使用较多的字体、文本属性使用继承，在body中统一设置字体、字号、颜色、行距等</em></strong></li>
<li><strong><em>文本属性（如color、font-类等）具有继承性，但对于元素的布局属性、盒模型属性（如背景属性、边框属性、外边距属性、内边距属性、定位属性、布局属性、元素宽高属性等）都不能继承</em></strong></li>
</ul>
<h2 id="优先级说明"><a href="#优先级说明" class="headerlink" title="优先级说明"></a>优先级说明</h2><h3 id="基本优先级"><a href="#基本优先级" class="headerlink" title="基本优先级"></a>基本优先级</h3><ul>
<li>各种选择器不冲突时将全部应用</li>
<li>某些选择器冲突时，冲突部分将会以行内样式&gt;id选择器&gt;class选择器&gt;标签选择器的顺序优先应用</li>
<li>优先级相同时，在冲突部分，后定义的选择器内容将覆盖前面的选择器</li>
</ul>
<h3 id="优先级修改"><a href="#优先级修改" class="headerlink" title="优先级修改"></a>优先级修改</h3><p>在使用时，可以用!important关键字将某个选择器的优先级提到最高，但一般还是建议统筹设计</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>:blue <span class="meta">!important</span>;</span><br><span class="line">	<span class="attribute">font-style</span>:italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，p标签中的颜色被设定成了最高优先级，如果p标签的字体颜色样式与其他选择器冲突，则优先运用p标签中定义的“blue”</p>
<h3 id="权值计算"><a href="#权值计算" class="headerlink" title="权值计算"></a>权值计算</h3><p>如果用具体的权值描述样式的优先级，优先级从低到高如下排列：</p>
<ol>
<li>继承样式——0分</li>
<li>标签选择器——1分</li>
<li>伪元素或对象选择器——1分</li>
<li>类选择器——10分</li>
<li>属性选择器——10分</li>
<li>id选择器——100分</li>
<li>行内样式——1000分</li>
<li>！important——无穷大</li>
</ol>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>网页设计</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title>网页设计-2</title>
    <url>/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/</url>
    <content><![CDATA[<h1 id="表单结构"><a href="#表单结构" class="headerlink" title="表单结构"></a>表单结构</h1><p>表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介</p>
<h2 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h2><ul>
<li><h3 id="表单标签-form"><a href="#表单标签-form" class="headerlink" title="表单标签-form"></a>表单标签-form</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get/post&quot;</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">    填入表单域和表单按钮等</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>action：</strong>表示接受并处理表单数据的服务器程序的url地址</p>
<p><strong>method：get</strong>为默认，表单数据和URL一起发送，提交的数据显示在浏览器地址栏中，保密性差，有数据量限制；<strong>post</strong>保密性好，并且无数据量限制，表单数据和URL分开发送，保密性好</p>
<p><strong>name：</strong>指定表单名称，以区分一个页面中的多个表单</p>
</li>
</ul>
<ul>
<li><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单常用控件</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>预览</th>
</tr>
</thead>
<tbody><tr>
<td>input type=“date”</td>
<td>日期选择框</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/8.png" alt="8"></td>
</tr>
<tr>
<td>input type=“text”</td>
<td>单行文本输入框</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/1.png" alt="1"></td>
</tr>
<tr>
<td>input type=“password”</td>
<td>密码输入框（输入的文字用*表示）</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/2.png" alt="2"></td>
</tr>
<tr>
<td>input type=“radio”</td>
<td>单选框（同一个name属性起效）</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/3.png" alt="3"></td>
</tr>
<tr>
<td>input type=”checkbox“</td>
<td>复选框（同一个name属性起效）</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/7.png" alt="7"></td>
</tr>
<tr>
<td>input type=“hidden”</td>
<td>隐藏域（不显示，供开发使用）</td>
<td>——————————</td>
</tr>
<tr>
<td>input type=“file”</td>
<td>文件域（上传文件）</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/4.png" alt="4"></td>
</tr>
<tr>
<td>select</td>
<td>列表框</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/5.png" alt="5"></td>
</tr>
<tr>
<td>textarea</td>
<td>多行文本输入框</td>
<td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/6.png" alt="6"></td>
</tr>
</tbody></table>
</li>
</ul>
<p>  <strong>表单域常用属性</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>控件名称（公共属性，与每个表单域对应）</td>
</tr>
<tr>
<td>type</td>
<td>控件类型，如radio，text等</td>
</tr>
<tr>
<td>size</td>
<td>指定控件的宽度</td>
</tr>
<tr>
<td>value</td>
<td>用于设定输入默认值（公共属性，可用来指定输入区域默认值）</td>
</tr>
<tr>
<td>maxlength</td>
<td>在单行文本时允许输入的最大字符数</td>
</tr>
<tr>
<td>src</td>
<td>插入图像的地址</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="表单按钮"><a href="#表单按钮" class="headerlink" title="表单按钮"></a>表单按钮</h3><p><strong>普通按钮:触发提交表单的动作，配合JavaScript使用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name值&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>提交按钮：将表单中的信息提交给表单中action指向的文件</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;button_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>图片式提交按钮：指可以在按钮位置上放置图片，这幅图片具有提交按钮的功能</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>重置按钮：指清除已填写的表单内容，恢复为默认内容，重新填写</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="H5结构性标签"><a href="#H5结构性标签" class="headerlink" title="H5结构性标签"></a>H5结构性标签</h1><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>网页页眉的结构标签，位于网页的最上端，一般header标签至少包含但不局限于一个标题，还可以包括hgroup标签，包括表格内容，网页封面，logo图案，搜索表单和nav等。</p>
<h2 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h2><p>网页中的导航条，是navigator的缩写，常用无序列表的形式加上css外观配置实现，一般置于header下方。</p>
<p>nav标签可以应用于传统导航条，侧边栏导航，页内导航，翻页操作等场合</p>
<h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>用于对网页中的内容进行分区分块，定义文档中的节。一般情况下，section标签常由标题和内容组成。</p>
<p><strong>注意：</strong></p>
<ul>
<li>section标签表示一段专题性的内容，一般会带有标题，没有标题的区块不要用section定义</li>
<li>根据实际情况来看，若是article标签，aside标签或是nav标签更符合使用条件，那么不要使用section标签</li>
<li>当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div标签而不是section</li>
</ul>
<h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><p>一个特殊的section标签，比section具有更明确的语义，代表一个独立的，完整的相关内容块，可独立于页面其他内容使用</p>
<p><strong>注意：</strong></p>
<ul>
<li>article标签会有标题部分，通常可以包含header，有时也会包含footer</li>
<li>article可以嵌套，内层的article对外层的article标签有着隶属关系，如博客的文章可以用article显示，一些评论也可以以article的形式嵌入其中</li>
</ul>
<h2 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h2><p>aside标签用来装载非正文的内容，被视为页面里单独的一个部分，作为页面或站点全局的附属信息部分，例如广告，友链，侧边栏，导航条等等，可以被article包含在内</p>
<h2 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h2><p>footer定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说作者和日期。</p>
<p>作为页面页脚时，一般包括版权，相关文件和链接</p>
<p>footer和header标签使用基本一样，可以在一个页面中多次使用，也可以在article或section中添加，相当于该区段的页脚</p>
<h2 id="框架示例："><a href="#框架示例：" class="headerlink" title="框架示例："></a>框架示例：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>叮叮书店<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站logo·叮叮书店(div)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">value</span>=<span class="string">&quot;搜索&quot;</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书籍分类<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>特刊降价<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;cart&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;adv&quot;</span>&gt;</span></span><br><span class="line">			此处用于添加广告</span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;recommend&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h2</span>&gt;</span>本周推荐<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;recommend-book&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书1标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span>书1<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;recommend-book&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书2标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>书2简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;new&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h2</span>&gt;</span>最近新书<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;new-book&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effect-1&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod4.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-2&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">p</span>&gt;</span>书3简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;new-book&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书4标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effect-1&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-2&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书4标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">p</span>&gt;</span>书4简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h2</span>&gt;</span>最近促销<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale-book&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书5标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effort-1&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/sale.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale-book&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">h3</span>&gt;</span>书6标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effort-1&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/sale.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;advert&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad1.jpg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad2.jpg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;best-selling&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>畅销图书<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书1名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书1现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书1原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书2名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书2现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书2原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书3名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书3现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书3原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling4.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书4名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书4现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书4原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					</span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling5.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书5名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书5现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书5原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;classify-partner&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;classify&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>图书分类<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>编程语言<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>图形图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网页制作<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>考试认证<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;partner&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>合作伙伴<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国电子商务研究中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>清华大学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国人民大学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国社会科学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">h2</span>&gt;</span>关于书店<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picture&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/about.gif&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">p</span>&gt;</span>书店介绍<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer-wrapper&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>服务条款<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>隐私策略<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright内容<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/vcss.gif&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">address</span>&gt;</span>通讯地址：</span><br><span class="line">			电话：</span><br><span class="line">			<span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>网页设计</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title>网页设计-1</title>
    <url>/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/</url>
    <content><![CDATA[<h1 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>             //编码方式为utf-8</span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>第一个HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            这是我的第一个html文件</span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上为基本应该存在的结构框架，效果图如下：</p>
<p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/2.png" alt="2"></p>
<h1 id="文字段落标签"><a href="#文字段落标签" class="headerlink" title="文字段落标签"></a>文字段落标签</h1><h2 id="标题与段落标签"><a href="#标题与段落标签" class="headerlink" title="标题与段落标签"></a>标题与段落标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> <span class="tag">&lt;<span class="name">h2</span>&gt;</span> <span class="tag">&lt;<span class="name">h3</span>&gt;</span> <span class="tag">&lt;<span class="name">h4</span>&gt;</span> <span class="tag">&lt;<span class="name">h5</span>&gt;</span> <span class="tag">&lt;<span class="name">h6</span>&gt;</span> //从左到右重要性递减</span><br><span class="line">    <span class="tag">&lt;<span class="name">hn</span> <span class="attr">align</span>=<span class="string">&quot;对齐方式&quot;</span>&gt;</span>标题内容<span class="tag">&lt;/<span class="name">hn</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;对齐方式&quot;</span>&gt;</span>段落文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="水平分割线标签"><a href="#水平分割线标签" class="headerlink" title="水平分割线标签"></a>水平分割线标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> 属性=<span class="string">&quot;属性值&quot;</span>/&gt;</span></span><br><span class="line">//size设置粗细，align对齐方式，width设置宽度，color设置颜色，noshade设置3d阴影</span><br></pre></td></tr></table></figure>
<h3 id="换行缩进标签"><a href="#换行缩进标签" class="headerlink" title="换行缩进标签"></a>换行缩进标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>						//强制换行</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span>   //缩进</span><br></pre></td></tr></table></figure>


<h2 id="文本的格式化标签"><a href="#文本的格式化标签" class="headerlink" title="文本的格式化标签"></a>文本的格式化标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span>						//粗体</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span>			//强调，一般为粗体</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>						//斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span>					//强调，一般为斜体</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">del</span>&gt;</span>					//删除线</span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">ins</span>&gt;</span>					//加下划线</span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span><span class="tag">&lt;/<span class="name">sup</span>&gt;</span>					//上标</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span><span class="tag">&lt;/<span class="name">sub</span>&gt;</span>					//下标</span><br></pre></td></tr></table></figure>


<h2 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h2><table>
<thead>
<tr>
<th>特殊字符</th>
<th>字符代码</th>
<th>特殊字符</th>
<th>字符代码</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td>&amp;nbsp；</td>
<td>“</td>
<td>&amp;quot；</td>
</tr>
<tr>
<td>&lt;</td>
<td>&amp;lt；</td>
<td>©</td>
<td>&amp;copy；</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt；</td>
<td>®</td>
<td>&amp;reg；</td>
</tr>
<tr>
<td>&amp;</td>
<td>&amp;amp；</td>
<td>×</td>
<td>&amp;times；</td>
</tr>
</tbody></table>
<h1 id="图像与超链接标签"><a href="#图像与超链接标签" class="headerlink" title="图像与超链接标签"></a>图像与超链接标签</h1><h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><h3 id="创建超链接"><a href="#创建超链接" class="headerlink" title="创建超链接"></a>创建超链接</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;资源地址&quot;</span> <span class="attr">target</span>=<span class="string">&quot;窗口名称&quot;</span> <span class="attr">title</span>=<span class="string">&quot;链接提示&quot;</span>&gt;</span>链接对象<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ol>
<li>绝对路径：网络主页上所存在的，或是文件在硬盘上的真实路径。</li>
<li>相对路径：以当前文件为起点，进行相对文件的查找。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">./          //指当前文件所在目录下（可省略）</span><br><span class="line">../         //指当前文件所在目录的上一目录下</span><br></pre></td></tr></table></figure>
<h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>锚点定义：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;锚点名称&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">//或将name改做id</span><br></pre></td></tr></table></figure>
<p>跳转锚点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;锚点名称&quot;</span>&gt;</span>链接的文字<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="影像地图"><a href="#影像地图" class="headerlink" title="影像地图"></a>影像地图</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像地址&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#影像地图名称&quot;</span>&gt;</span>   //使用影像地图</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;影像地图名称&quot;</span>&gt;</span>					  //定义影像地图</span><br><span class="line">	<span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;热区形状&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;热区坐标&quot;</span> <span class="attr">href</span>=<span class="string">&quot;链接地址&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--此处可以添加多个area--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>shape与coords的附加说明：</strong></p>
<ul>
<li>shape=”circle“，coords=”x,y,z“（x,y定义圆心位置，z为半径)</li>
<li>shape=“polygon”，coords=“x1,y1,x2,y2……”（每个顶点的坐标都要写入）</li>
<li>shape=“rectangle”，coords=“x1,y1,x2,y2”（一个顶点的坐标和其对角顶点坐标）</li>
</ul>
<h1 id="表格与列表标签"><a href="#表格与列表标签" class="headerlink" title="表格与列表标签"></a>表格与列表标签</h1><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格的定义范例"><a href="#表格的定义范例" class="headerlink" title="表格的定义范例"></a><strong>表格的定义范例</strong></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>								//表格的第一个横行</span><br><span class="line">    	<span class="tag">&lt;<span class="name">th</span>&gt;</span>此处表头字体自动加粗<span class="tag">&lt;/<span class="name">th</span>&gt;</span>		 //具体到行内的一个单元格</span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>								//表格的第二个横行</span><br><span class="line">    	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">caption</span>&gt;</span>定义表格的标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span>定义表格的表头<span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span>对表格中的主体内容进行分组<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tfoot</span>&gt;</span>对表格中的页脚内容进行分组<span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line">// 后三个标签应该结合使用</span><br></pre></td></tr></table></figure>


<h3 id="表格标签”table”的属性："><a href="#表格标签”table”的属性：" class="headerlink" title="表格标签”table”的属性："></a><strong>表格标签”table”的属性：</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width/height</td>
<td>表格的宽度（高度），值可以是数值或百分比，数值表示像素点数，百分比是占浏览器宽度（高度）的比例</td>
</tr>
<tr>
<td>align</td>
<td>表格相对周围元素的对齐方式</td>
</tr>
<tr>
<td>background</td>
<td>表格的背景图片</td>
</tr>
<tr>
<td>bgcolor</td>
<td>表格的背景颜色，一般后期通过样式控制，不建议使用</td>
</tr>
<tr>
<td>border</td>
<td>表格边框宽度（像素为单位）</td>
</tr>
<tr>
<td>bordercolor</td>
<td>表格边框的颜色</td>
</tr>
<tr>
<td>cellspacing</td>
<td>单元格之间的间距</td>
</tr>
<tr>
<td>cellpadding</td>
<td>单元格内容与边界之间空白距离的大小</td>
</tr>
</tbody></table>
<h3 id="表格设置border时，可以设置显示隐藏边框"><a href="#表格设置border时，可以设置显示隐藏边框" class="headerlink" title="表格设置border时，可以设置显示隐藏边框"></a><strong>表格设置border时，可以设置显示隐藏边框</strong></h3><table>
<thead>
<tr>
<th>frame</th>
<th>描述</th>
<th>frame</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>box</td>
<td>显示所有边框</td>
<td>alove</td>
<td>只显示上边框</td>
</tr>
<tr>
<td>void</td>
<td>不显示边框</td>
<td>below</td>
<td>只显示下边框</td>
</tr>
<tr>
<td>hsides</td>
<td>只显示上下边框</td>
<td>lhs</td>
<td>只显示左边框</td>
</tr>
<tr>
<td>vsides</td>
<td>只显示左右边框</td>
<td>rhs</td>
<td>只显示右边框</td>
</tr>
</tbody></table>
<h3 id="单元格td的设置"><a href="#单元格td的设置" class="headerlink" title="单元格td的设置"></a><strong>单元格td的设置</strong></h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width/height</td>
<td>单元格的宽和高，接受绝对值和相对值</td>
<td>align</td>
<td>单元格内容的水平对齐方式（left、right、center等）</td>
</tr>
<tr>
<td>colspan</td>
<td>规定单元格横跨列数（纵向合并单元格）</td>
<td>valign</td>
<td>单元格内容的垂直对齐方式（top、middle、bottom等）</td>
</tr>
<tr>
<td>rowspan</td>
<td>规定单元格横跨行数（横向合并单元格）</td>
<td>bgcolor</td>
<td>单元格的背景色</td>
</tr>
</tbody></table>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul>
<li><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">编号类型</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>type决定列表图标类型：</strong></p>
<ul>
<li><p>disc为实心圆（默认）</p>
</li>
<li><p>circle为空心圆</p>
</li>
<li><p>square为方块</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">type</span>=<span class="string">&quot;编号类型&quot;</span> <span class="attr">start</span>=<span class="string">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>type决定列表序号样式：</strong></p>
<ul>
<li><strong>type=1：</strong>1,2,3,4,5……</li>
<li><strong>type=A：</strong>A,B,C,D,E……</li>
<li><strong>type=a：</strong>a,b,c,d,e……</li>
<li><strong>type=I：</strong>I,II,III,IV,V……</li>
<li><strong>type=i：</strong>i,ii,iii,iv,v……</li>
</ul>
<p><strong>reversed属性为true时，可以实现倒序排列，start指定第一项的序号</strong></p>
</li>
</ul>
<ul>
<li><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>注释一<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>注释二<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">dt</span>&gt;</span><span class="tag">&lt;<span class="name">dd</span>&gt;</span>注释三<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">type</span>=<span class="string">&quot;circle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>上海</span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">&quot;6&quot;</span> <span class="attr">type</span>=<span class="string">&quot;1&quot;</span> <span class="attr">reversed</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>浦东新区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>徐汇区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>长宁区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>普陀区<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码为无序列表嵌套有序列表，效果图如下</p>
<p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/1.png" alt="1"></p>
<h1 id="页面布局与float浮动"><a href="#页面布局与float浮动" class="headerlink" title="页面布局与float浮动"></a>页面布局与float浮动</h1><ul>
<li><h2 id="页面布局方式"><a href="#页面布局方式" class="headerlink" title="页面布局方式"></a>页面布局方式</h2><p><strong>主要包括文档流和浮动层，通常以文档流为默认</strong></p>
<p>文档流：从上到下，从左到右排布，遇到块级元素换行</p>
<p>浮动层：给元素的float属性赋值后元素将紧贴父元素的左右边框，从上到下，从左到右，遇块换行排布，能够实现板块的拼接</p>
<img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/3.png" alt="3" style="zoom:50%;">

<p>前者为文档流，后者为div2向右浮动</p>
<img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/4.png" alt="4" style="zoom:50%;">
</li>
<li><h2 id="float浮动的特点"><a href="#float浮动的特点" class="headerlink" title="float浮动的特点"></a>float浮动的特点</h2><ol>
<li><strong>让页面中的元素可以水平排列</strong></li>
<li><strong>浮动元素会完全脱离文档流，不再占据文档流中的位置</strong></li>
<li><strong>设置浮动后，元素会向父元素的左侧或右侧移动</strong></li>
<li><strong>浮动元素默认不会从父元素中移除</strong></li>
<li><strong>浮动元素向左或向右移动时，不会超过前面的其他浮动元素</strong></li>
<li><strong>如果浮动元素的上面是一个没有浮动的块级元素，则浮动元素无法上浮</strong></li>
<li><strong>浮动元素不会超过上一个浮动的兄弟元素，最多保持等高</strong></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>网页设计</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>网页设计</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础-3</title>
    <url>/2021/01/22/c++%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<h2 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h2><p>在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p>
<h3 id="1、插入器-lt-lt"><a href="#1、插入器-lt-lt" class="headerlink" title="1、插入器(&lt;&lt;)"></a><strong>1、插入器(&lt;&lt;)</strong></h3><p>　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’/n’;就表示把字符串”Write Stdout”和换行字符(‘/n’)输出到标准输出流。</p>
<h3 id="2、析取器-gt-gt"><a href="#2、析取器-gt-gt" class="headerlink" title="2、析取器(&gt;&gt;)"></a><strong>2、析取器(&gt;&gt;)</strong></h3><p>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p>
<p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream。下面就把此类的文件操作过程一一道来。</p>
<h3 id="3、打开文件"><a href="#3、打开文件" class="headerlink" title="3、打开文件"></a><strong>3、打开文件</strong></h3><p>　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p>
<p>　　void open(const char* filename,int mode,int access);</p>
<p>　　参数：</p>
<p>　　filename：　　要打开的文件名<br>　　mode：　　　　要打开文件的方式<br>　　access：　　　打开文件的属性<br>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p>
<p>　　ios::app：　　　以追加的方式打开文件<br>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性<br>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文<br>　　ios::in：　　　 文件以输入方式打开<br>　　ios::out：　　　文件以输出方式打开<br>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　<br>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败<br>　　ios::trunc：　　如果文件存在，把文件长度设为0<br>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p>
<p>　　打开文件的属性取值是：</p>
<p>　　0：普通文件，打开访问<br>　　1：只读文件<br>　　2：隐含文件<br>　　4：系统文件<br>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p>
<p>　　例如：以二进制输入方式打开文件c:/config.sys</p>
<p>　　fstream file1;<br>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p>
<p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p>
<p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p>
<p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p>
<p>　　fstream file1(“c://config.sys”);</p>
<p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p>
<p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件<br>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p>
<p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p>
<h3 id="4、关闭文件"><a href="#4、关闭文件" class="headerlink" title="4、关闭文件"></a>4、关闭文件</h3><p>　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p>
<h3 id="5、读写文件"><a href="#5、读写文件" class="headerlink" title="5、读写文件"></a>5、读写文件</h3><p>　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p>
<h4 id="1、文本文件的读写"><a href="#1、文本文件的读写" class="headerlink" title="1、文本文件的读写"></a>1、文本文件的读写</h4><p>　　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p>
<p>　　file2&lt;&lt;”I Love You”;//向文件写入字符串”I Love You”<br>　　int i;<br>　　file1&gt;&gt;i;//从文件输入一个整数值。</p>
<p>　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p>
<p>　　操纵符 功能 输入/输出<br>　　dec 格式化为十进制数值数据 输入和输出<br>　　endl 输出一个换行符并刷新此流 输出<br>　　ends 输出一个空字符 输出<br>　　hex 格式化为十六进制数值数据 输入和输出<br>　　oct 格式化为八进制数值数据 输入和输出<br>　　setpxecision(int p) 设置浮点数的精度位数 输出</p>
<p>　　比如要把123当作十六进制输出：file1&lt;</p>
<h4 id="2、二进制文件的读写"><a href="#2、二进制文件的读写" class="headerlink" title="2、二进制文件的读写"></a>2、二进制文件的读写</h4><h5 id="①put"><a href="#①put" class="headerlink" title="①put()"></a>①put()</h5><p>　　put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(‘c’);就是向流写一个字符’c’。</p>
<h5 id="②get"><a href="#②get" class="headerlink" title="②get()"></a>②get()</h5><p>　　get()函数比较灵活，有3种常用的重载形式：</p>
<p>　　一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p>
<p>　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p>
<p>　　还有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=’/n’)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’/n’。例如：</p>
<p>　　file2.get(str1,127,’A’);//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p>
<h5 id="③读写数据块"><a href="#③读写数据块" class="headerlink" title="③读写数据块"></a>③读写数据块</h5><p>　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p>
<p>　　read(unsigned char *buf,int num);<br>　　write(const unsigned char *buf,int num);</p>
<p>　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p>
<p>　　例：</p>
<p>　　unsigned char str1[]=”I Love You”;<br>　　int n[5];<br>　　ifstream in(“xxx.xxx”);<br>　　ofstream out(“yyy.yyy”);<br>　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中<br>　　in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换<br>　　in.close();out.close();</p>
<h3 id="6、检测EOF"><a href="#6、检测EOF" class="headerlink" title="6、检测EOF"></a>6、检测EOF</h3><p>　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p>
<p>　　例：　　if(in.eof())ShowMessage(“已经到达文件尾！”);</p>
<h3 id="7、文件定位"><a href="#7、文件定位" class="headerlink" title="7、文件定位"></a>7、文件定位</h3><p>　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p>
<p>　　istream &amp;seekg(streamoff offset,seek_dir origin);<br>　　ostream &amp;seekp(streamoff offset,seek_dir origin);</p>
<p>　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p>
<p>　　ios::beg：　　文件开头<br>　　ios::cur：　　文件当前位置<br>　　ios::end：　　文件结尾<br>　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p>
<p>　　例：</p>
<p>　　file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节<br>　　file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</p>
<h3 id="8-BCB提供的文件操作函数"><a href="#8-BCB提供的文件操作函数" class="headerlink" title="8.BCB提供的文件操作函数"></a>8.BCB提供的文件操作函数</h3><p>总共分为三类：</p>
<p>1、文件名函数</p>
<p>2、文件管理函数</p>
<p>3、文件I/O函数</p>
<h4 id="1、文件名函数"><a href="#1、文件名函数" class="headerlink" title="1、文件名函数"></a>1、文件名函数</h4><p>　　文件名函数可以对文件的名称、所在子目录、驱动器和扩展名等进行操作。下表列出这些函数及其功能。</p>
<p>　　函数 说明<br>　　ExpandFileName() 返回文件的全路径(含驱动器、路径)<br>　　ExtractFileExt() 从文件名中抽取扩展名<br>　　ExtractFileName() 从文件名中抽取不含路径的文件名<br>　　ExtractFilePath() 从文件名中抽取路径名<br>　　ExtractFileDir() 从文件名中抽取目录名<br>　　ExtractFileDrive() 从文件名中抽取驱动器名<br>　　ChangeFileExt() 改变文件的扩展名<br>　　ExpandUNCFileName() 返回含有网络驱动器的文件全路径<br>　　ExtractRelativePath() 从文件名中抽取相对路径信息<br>　　ExtractShortPathName() 把文件名转化为DOS的8·3格式<br>　　MatchesMask() 检查文件是否与指定的文件名格式匹配</p>
<p>　　下面就把这些函数作一一介绍：</p>
<h5 id="⑴ExpandFileName"><a href="#⑴ExpandFileName" class="headerlink" title="⑴ExpandFileName()"></a><strong>⑴ExpandFileName()</strong></h5><p>　　功能：返回文件的全路径(含驱动器、路径)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandFileName(Application-&gt;ExeName));//显示你的程序文件名，如C:/MyBCB/Sample1.EXE</p>
<h5 id="⑵ExtractFileExt"><a href="#⑵ExtractFileExt" class="headerlink" title="⑵ExtractFileExt()"></a><strong>⑵ExtractFileExt()</strong></h5><p>　　功能：从文件名中抽取扩展名</p>
<p>　　参数：FileName:要处理的文件名（全路径）</p>
<p>　　例：ShowMessage(ExtractFileExt(Application-&gt;ExeName));//显示”.exe”</p>
<h5 id="⑶ExtractFileName"><a href="#⑶ExtractFileName" class="headerlink" title="⑶ExtractFileName()"></a><strong>⑶ExtractFileName()</strong></h5><p>　　功能：从文件名中抽取不含路径的文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileExt(“c://Winnt//SOL.EXE”));//显示”SOL.EXE”</p>
<h5 id="⑷ExtractFilePath"><a href="#⑷ExtractFilePath" class="headerlink" title="⑷ExtractFilePath()"></a><strong>⑷ExtractFilePath()</strong></h5><p>　　功能：从文件名中抽取路径名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFilePath(“Winnt//SOL.EXE”));//显示”Winnt/“</p>
<h5 id="⑸ExtractFileDir"><a href="#⑸ExtractFileDir" class="headerlink" title="⑸ExtractFileDir()"></a><strong>⑸ExtractFileDir()</strong></h5><p>　　功能：从文件名中抽取目录名(和上个函数不同，不包括最后的”/“)</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDir(“Winnt//SOL.EXE”));//显示”Winnt”,注意和上个函数的区别</p>
<h5 id="⑹ExtractFileDrive"><a href="#⑹ExtractFileDrive" class="headerlink" title="⑹ExtractFileDrive()"></a><strong>⑹ExtractFileDrive()</strong></h5><p>　　功能：从文件名中抽取驱动器名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractFileDrive(“c://Winnt//SOL.EXE”));//显示”c:”</p>
<h5 id="⑺ChangeFileExt"><a href="#⑺ChangeFileExt" class="headerlink" title="⑺ChangeFileExt()"></a><strong>⑺ChangeFileExt()</strong></h5><p>　　功能：更改文件名的扩展名，不是对真正的文件进行改名，只是对文件名这个字符串进行处理</p>
<p>　　参数：FileName:要改名的文件名，Extension：新的扩展名</p>
<p>　　例：ShowMessage(ChangeFileExt(“c://Winnt//SOL.EXE”,”.OOO”));//显示”c:/winnt/SOL.OOO”</p>
<h5 id="⑻ExpandUNCFileName"><a href="#⑻ExpandUNCFileName" class="headerlink" title="⑻ExpandUNCFileName()"></a><strong>⑻ExpandUNCFileName()</strong></h5><p>　　功能：返回含有网络驱动器的文件全路径，格式为：//机器名/共享名/文件名</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExpandUNCFileName(“F://Winnt//SOL.EXE”));/<em>如果F:是映射的网络驱动器//NT40/WINNT，则显示”//NT40/WINNT/SOL.EXE”</em>/</p>
<h5 id="⑼ExtractRelativePath"><a href="#⑼ExtractRelativePath" class="headerlink" title="⑼ExtractRelativePath()"></a><strong>⑼ExtractRelativePath()</strong></h5><p>　　功能：从文件名中抽取相对路径信息，如”../sss/ss.asd”这种形式</p>
<p>　　参数：BaseName：基准文件名；DestName：目标文件名</p>
<p>　　例：ShowMessage(ExtractRelativePath(“D://Source//c//1.123”,”D://Source//Asm//dz.asm”));/<em>显示”../asm/dz.asm”</em>/</p>
<h5 id="10-ExtractShortPathName"><a href="#10-ExtractShortPathName" class="headerlink" title="(10) ExtractShortPathName()"></a><strong>(10) ExtractShortPathName()</strong></h5><p>　　功能：把文件名转换为DOS的8、3格式</p>
<p>　　参数：FileName:要处理的文件名</p>
<p>　　例：ShowMessage(ExtractShortPathName(“E://Program Files//Dual Wheel Mouse//4dmain.exe”));/<em>显示”E:/Progra<del>1/dualwh</del>1/4dmain.exe”</em>/</p>
<h5 id="⑾MatchesMask"><a href="#⑾MatchesMask" class="headerlink" title="⑾MatchesMask()"></a><strong>⑾MatchesMask()</strong></h5><p>　　功能：检查文件是否与指定的文件名格式匹配</p>
<p>　　参数：FileName:要处理的文件名；Mask:文件名格式，支持通配符</p>
<p>　　例：ShowMessage(MatchesMask(“Lxf.exe”,”*.?x?));//显示”true”</p>
<h4 id="2、文件管理函数"><a href="#2、文件管理函数" class="headerlink" title="2、文件管理函数"></a>2、文件管理函数</h4><p>　　这类函数包括设置和读取驱动器、子目录和文件的有关的各种操作，下表列出这类操作常用的函数及其功能。</p>
<p>　　函数 功能<br>　　CreateDir() 创建新的子目录<br>　　DeleteFile() 删除文件<br>　　DirectoryExists() 判断目录是否存在<br>　　DiskFree() 获取磁盘剩余空间<br>　　DiskSize() 获取磁盘容量<br>　　FileExists() 判断文件是否存在<br>　　FileGetAttr() 获取文件属性<br>　　FileGetDate() 获取文件日期<br>　　GetCurrentDir() 获取当前目录<br>　　RemoveDir() 删除目录<br>　　SetCurrentDir() 设置当前目录</p>
<p>　　下面就把这些函数作一一介绍：</p>
<h5 id="⑴CreateDir"><a href="#⑴CreateDir" class="headerlink" title="⑴CreateDir()"></a><strong>⑴CreateDir()</strong></h5><p>　　功能：建立子目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要建立的子目录的名字</p>
<p>　　例：Create(“ASM”);//在当前目录下建立一个名为ASM的子目录</p>
<h5 id="⑵DeleteFile"><a href="#⑵DeleteFile" class="headerlink" title="⑵DeleteFile()"></a><strong>⑵DeleteFile()</strong></h5><p>　　功能：删除文件，如果成功返回true，否则返回false</p>
<p>　　参数：FileName:要删除的文件名</p>
<p>　　例：if(OpenDialog1-&gt;Execute())DeleteFile(OpenDialog1-&gt;FileName);</p>
<h5 id="⑶DirectoryExists"><a href="#⑶DirectoryExists" class="headerlink" title="⑶DirectoryExists()"></a><strong>⑶DirectoryExists()</strong></h5><p>　　功能：检测目录是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：Name:要检测的目录名</p>
<p>　　例：if(!DirectoryExists(“ASM”))CreateDir(“ASM”);//如果ASM这个目录不存在则创建之</p>
<h5 id="⑷DiskFree"><a href="#⑷DiskFree" class="headerlink" title="⑷DiskFree()"></a><strong>⑷DiskFree()</strong></h5><p>　　功能：检测磁盘剩余空间，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的剩余空间</p>
<h5 id="⑸DiskSize"><a href="#⑸DiskSize" class="headerlink" title="⑸DiskSize()"></a><strong>⑸DiskSize()</strong></h5><p>　　功能：检测磁盘容量，返回值以字节为单位，如果指定的磁盘无效，返回-1</p>
<p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p>
<p>　　例：ShowMessage(DiskFree(0));//显示当前盘的容量</p>
<p>　　<strong>⑹FileExists()</strong></p>
<p>　　功能：检测文件是否存在，如果存在返回true，否则返回false</p>
<p>　　参数：FileName:要检测的文件名</p>
<p>　　例：if(FileExists(“AAA.ASM”))DeleteFile(“AAA.ASM”);</p>
<h5 id="⑺FileGetAttr"><a href="#⑺FileGetAttr" class="headerlink" title="⑺FileGetAttr()"></a><strong>⑺FileGetAttr()</strong></h5><p>　　功能：取得文件属性，如果出错返回-1</p>
<p>　　返回值如下表，如果返回$00000006表示是一个具有隐含和系统属性的文件(4+2)</p>
<p>　　常量 值 含义<br>　　faReadOnly $00000001 只读文件<br>　　faHidden $00000002 隐含文件<br>　　faSysFile $00000004 系统文件<br>　　faVolumeID $00000008 卷标<br>　　faDirectory $00000010 目录<br>　　faArchive $00000020 归档文件</p>
<p>　　例：if(FileGetAttr(“LLL.TXT”)&amp;0x2)ShowMessage(“这是一个有隐含属性的文件”);</p>
<p>　　与此对应的有FileSetAttr() ，请自已查阅帮助系统</p>
<h5 id="⑻FileGetDate"><a href="#⑻FileGetDate" class="headerlink" title="⑻FileGetDate()"></a><strong>⑻FileGetDate()</strong></h5><p>　　功能：返回文件的建立时间到1970-1-1日0时的秒数</p>
<p>　　参数：Handle:用FileOpen()打开的文件句柄。</p>
<p>　　例：</p>
<p>　　int i=FileOpen(“C://autoexec.bat”,fmOpenRead);<br>　　ShowMessage(FileGetDate(i));<br>　　FileClose(i);</p>
<p>　　与此对应的有FileSetDate()</p>
<p>　　<strong>⑼GetCurrentDir()</strong></p>
<p>　　功能：取得当前的目录名</p>
<p>　　例：ShowMessage(GetCurrentDir());</p>
<h5 id="⑽RemoveDir"><a href="#⑽RemoveDir" class="headerlink" title="⑽RemoveDir()"></a><strong>⑽RemoveDir()</strong></h5><p>　　功能：删除目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要删除的目录名</p>
<p>　　例：if(DiectoryExists(“ASM”))RemoveDir(“ASM”);</p>
<h5 id="⑾SetCurrentDir"><a href="#⑾SetCurrentDir" class="headerlink" title="⑾SetCurrentDir()"></a><strong>⑾SetCurrentDir()</strong></h5><p>　　功能：设置当前目录，如果成功返回true，否则返回false</p>
<p>　　参数：Dir:要切换到的目录名</p>
<p>　　例：SetCurrentDir(“C://WINDOWS”);</p>
<h4 id="3、文件I-O函数"><a href="#3、文件I-O函数" class="headerlink" title="3、文件I/O函数"></a>3、文件I/O函数</h4><p>　　这类函数完成对文件的读写相关的操作，这种类型的操作和C的基于I/O文件操作类似，下表列出这类操作常用的函数及其功能。</p>
<p>　　FileOpen() 打开文件<br>　　FileClose() 关闭文件<br>　　FileRead() 读文件<br>　　FileSeek() 文件定位<br>　　FileWrite() 写文件<br>　　FileCreate() 创建文件</p>
<p>　　下面就对这些函数作详细介绍。</p>
<p>　　<strong>⑴FileOpen()</strong></p>
<p>　　功能：打开文件，如果成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要打开的文件名；Mode：打开的方式，取值如下表，可用”或”(“|”)运算符连接。</p>
<p>　　常量 值 说明</p>
<p>　　fmOpenRead 0 以只读属性打开<br>　　fmOpenWrite 1 以只写属性打开<br>　　fmOpenReadWrite 2 以读/写属性打开<br>　　fmShareCompat 0 兼容FCB方式(汇编中有相应的DOS功能调用)<br>　　fmShareExclusive 16 共享方式：以独占方式打开，在关闭以前，别人不能访问<br>　　fmShareDenyWrite 32 共享方式：拒绝写访问<br>　　fmShareDenyRead 48 共享方式：拒绝读访问<br>　　fmShareDenyNone 64 共享方式：无限制，允许读写<br>　　例：int i=FileOpen(“C://WINDOWS//Win.ini”,fmOpenReadWrite|fmShareExclusive);</p>
<p>　　<strong>⑵FileClose()</strong></p>
<p>　　功能：关闭打开的句柄。</p>
<p>　　参数：Handle:要关闭的句柄</p>
<p>　　例：FileClose(i);</p>
<p>　　<strong>⑶FileRead()</strong></p>
<p>　　功能：读文件，返回实际读取的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要读取的句柄；Buffer:存放读取的数据的缓冲区；Count:想读取的字节数</p>
<p>　　例：char str[400];FileRead(hnd1,str,400);</p>
<p>　　<strong>⑷FileSeek()</strong></p>
<p>　　功能：移动文件读取指针，成功返回文件指针的位置，失败返回-1</p>
<p>　　参数：Handle:相关联的句柄；Offset:移动的量；Orgin:移动的基准，0=文件头，1=当前位置，2=文件尾。</p>
<p>　　例：ShowMessage(FileSeek(hnd1,0,2));//取得文件的长度</p>
<p>　　<strong>⑸FileWrite()</strong></p>
<p>　　功能：写文件，返回实际写入的字节数，句柄必须首先由FileOpen或FileCreate创建。</p>
<p>　　参数：Handle:要写入的句柄；Buffer:存放写入数据的缓冲区；Count:想写入的字节数</p>
<p>　　例：char str[]=”I Love You”;FileWrite(hnd1,str,strlen(str));</p>
<p>　　<strong>⑹FileCreate()</strong></p>
<p>　　功能：创建文件。成功返回其句柄，否则返回-1</p>
<p>　　参数：FileName:要创建的文件名</p>
<p>　　例：if(!FileExists(“KC.C”))hnd1=FileCreate(“KC.C”);</p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础-2</title>
    <url>/2021/01/20/c++%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p><strong>1.c++面向对象的三大特性：封装、继承、多态</strong></p>
<p><strong>2.c++认为万物皆可对象，对象上有其属性和行为</strong></p>
<p><strong>3.具有相同性质的对象，我们可以抽象称为类</strong></p>
<h3 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h3><h4 id="（1）意义："><a href="#（1）意义：" class="headerlink" title="（1）意义："></a>（1）意义：</h4><ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
<p>在设计类的时候，属性和行为写在一起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名&#123; 访问权限: 属性 &#x2F; 行为 &#125;;</span><br><span class="line">&#x2F;&#x2F;属性使用变量表示</span><br><span class="line">&#x2F;&#x2F;行为一般用函数表示</span><br></pre></td></tr></table></figure>
<p>在类的概念下，具体的一个物体（整体），称作对象。【类似结构体】</p>
</li>
<li><p>将属性和行为加以权限控制</p>
<p>访问权限有三种：</p>
<p>1.public（公共权限）：类内可以访问，类外可以访问</p>
<p>2.protected（保护权限)：类内可以访问，类外不可以访问，子类可以访问</p>
<p>3.private（私有权限）：类内可以访问，类外不可以访问，子类不可以访问</p>
</li>
</ul>
<h4 id="（2）struct和class区别（默认访问权限不同）"><a href="#（2）struct和class区别（默认访问权限不同）" class="headerlink" title="（2）struct和class区别（默认访问权限不同）"></a>（2）struct和class区别（默认访问权限不同）</h4><ul>
<li>struct默认权限为公共，可以定义成员函数</li>
<li>class默认权限为私有</li>
</ul>
<h4 id="（3）成员属性设置为私有"><a href="#（3）成员属性设置为私有" class="headerlink" title="（3）成员属性设置为私有"></a>（3）成员属性设置为私有</h4><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限【通过设置公有权限下函数控制读写权限】</p>
<p>优点2：对于写权限，我们可以检测数据的有效性</p>
<h4 id="（4）对象的初始化和清理"><a href="#（4）对象的初始化和清理" class="headerlink" title="（4）对象的初始化和清理"></a>（4）对象的初始化和清理</h4><p>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</p>
<p>对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知。同样的使用完一个对象或变量,没有及时清理，也会造成一定的安全问题。</p>
<p>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构,编译器会提供。</p>
<p>编译器提供的构造函数和析构函数是空实现。</p>
<h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数:"></a>1.构造函数:</h5><p>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p>
<p>默认情况下，c++一般给一个类添加三个函数：默认构造函数，默认析构函数，默认拷贝构造函数</p>
<p><strong>语法:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名()&#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用，,而且只会调用一次</li>
</ul>
<p><strong>构造函数的分类及调用：</strong></p>
<p>1.两种分类方式：</p>
<ul>
<li><p>按参数分：有参构造和无参构造（又称默认构造参数）</p>
</li>
<li><p>按类型分：</p>
<p>普通构造</p>
<p>拷贝构造（将其他对象的属性作为默认值拷贝过来）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名（const 类名 &amp;对象名）&#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p>c++中拷贝构造函数调用时机通常有三种情况：</p>
<ol>
<li>使用一个已经创建完毕的对象来初始化新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ol>
</li>
</ul>
<p>2.三种调用方式：</p>
<ul>
<li><p><strong>括号法</strong>：通过有无括号和参数个数调用对应的构造函数，无括号调用默认构造函数</p>
</li>
<li><p><strong>显示法：</strong>通过“=”号调用对应构造函数，左侧是“类名 对象名”，右侧带入具体内容，无左侧内容和“=”号的，为匿名对象，特点是当前行执行结束后，系统会立刻回收掉匿名对象</p>
<p>*<strong>不要利用拷贝构造函数，初始化匿名对象！</strong>编译器会认为是重定义</p>
</li>
<li><p><strong>隐式转换法：</strong>隐藏掉显示法”=“右侧的类名和括号，是显示法的简化写法</p>
</li>
</ul>
<p>3.调用规则</p>
<ul>
<li>用户定义有参构造函数，c++ 不提供无参构造，但会提供默认拷贝构造</li>
<li>用户定义拷贝构造函数，c++不提供其他构造函数</li>
</ul>
<p>4.深浅拷贝</p>
<ul>
<li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>【使用new在堆区开辟新空间（一般变量在栈上），并返回一段空间的首地址，一般用指针接收，需要手动在析构函数中用“delete”释放这一段空间，并且将指针变为空指针（指向NULL），如果用浅拷贝就会直接拷贝地址，从而发生重复释放，这时需要用深拷贝模仿操作开辟一个新空间】</p>
<p><img src="/2021/01/20/c++%E5%AD%A6%E4%B9%A0-2/pic-2.png" alt="pic-2"></p>
</li>
<li><p>浅拷贝：简单的赋值拷贝操作</p>
</li>
</ul>
<h5 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2.析构函数:"></a>2.析构函数:</h5><p>主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~类名()&#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号~</li>
<li>析构函数不可以有参数,因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li>
</ul>
<p><strong>3.初始化列表</strong>——初始化属性</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构造函数（）:属性1（值1），属性2（值2）……&#123;构造函数的函数体&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（5）类对象作为类成员"><a href="#（5）类对象作为类成员" class="headerlink" title="（5）类对象作为类成员"></a>（5）类对象作为类成员</h4><p>c++类的成员可以是另一个类的对象，我们称该成员为对象成员</p>
<p>B类中有对象A作为成员，A为对象成员，构造时，先构造类的对象，再构造自身，析构时先析构自身，再析构类的对象</p>
<h4 id="（6）静态成员"><a href="#（6）静态成员" class="headerlink" title="（6）静态成员"></a>（6）静态成员</h4><p>在成员变量和成员函数前加上关键字static，称为静态成员，分为：静态成员变量和静态成员函数</p>
<ul>
<li><p>静态成员变量</p>
<p>1.所有对象共享同一份数据</p>
<p>2.在编译阶段分配内存</p>
<p>3.类内声明（static 变量类型 静态成员变量名；），类外初始化（变量类型 类名::静态成员变量名 = 初值；）</p>
</li>
<li><p>静态成员函数</p>
<p>1.所有对象共享同一个函数</p>
<p>2.静态成员函数只能访问静态成员变量</p>
</li>
</ul>
<p>静态成员函数的访问：</p>
<ol>
<li>通过对象访问</li>
<li>通过类名访问</li>
</ol>
<p>*静态成员函数同样具有访问权限</p>
<h4 id="（7）c-对象模型和this指针"><a href="#（7）c-对象模型和this指针" class="headerlink" title="（7）c++对象模型和this指针"></a>（7）c++对象模型和this指针</h4><p>成员变量和成员函数分开存储：在c++中，类内的成员变量和成员函数分开储存，只有非静态成员变量才属于类的对象</p>
<p>空对象占用内存空间为：1，为了区分每个空对象所占内存的位置</p>
<p>非空对象占用内存空间决定于其包含成员所占字节数。</p>
<p>每一个非静态成员函数只会诞生-份函数实例，也就是说多个同类型的对象会共用一块代码那么问题是:这一块代码是如何区 分那个对象调用自己的呢?</p>
<p>C+ +通过提供特殊的对象指针，this指针， 解决上述问题。this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针this指针不需要定义，直接使用即可</p>
<p><strong>this指针的用途:</strong></p>
<p>●当形参和成员变量同名时，可用this指针来区分</p>
<p>●在类的非静态成员函数中返回对象本身，可使用return *this</p>
<p>c++中，空指针也是可以调用成员函数的，但是需要注意有没有用到this指针，如果用到的话，需要加以判断保证代码的健壮性。</p>
<p><strong>常函数:</strong></p>
<p>●成员函数后加const后我们称为这个函数为常函数</p>
<p>●常函数内不可以修改成员属性</p>
<p>●成员属性声明时加关键字mutable后, 在常函数中依然可以修改</p>
<p>常对象:</p>
<p>●声明对象前加const称该对象为常对象</p>
<p>●常对象只能调用常函数</p>
<h4 id="（8）友元"><a href="#（8）友元" class="headerlink" title="（8）友元"></a>（8）友元</h4><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类访问另一个类中私有成员，关键字为friend</p>
<p>友元的三种实现：</p>
<p>●全局函数做友元</p>
<p>●类做友元</p>
<p>●成员函数做友元.</p>
<h4 id="（9）运算符重载"><a href="#（9）运算符重载" class="headerlink" title="（9）运算符重载"></a>（9）运算符重载</h4><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p>
<p>当调用一个重载函数或重载运算符时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p>
<p>可以重定义或重载大部分 C++ 内置的运算符。这样就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box operator+(const Box&amp;);</span><br></pre></td></tr></table></figure>

<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box operator+(const Box&amp;, const Box&amp;);</span><br></pre></td></tr></table></figure>
<p>可重载运算符：</p>
<table>
<thead>
<tr>
<th>双目算术运算符</th>
<th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th>
</tr>
</thead>
<tbody><tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td>
</tr>
</tbody></table>
<p>不可重载运算符：</p>
<ul>
<li>**.**：成员访问运算符</li>
<li><strong>.*</strong>, <strong>-&gt;*</strong>：成员指针访问运算符</li>
<li>**::**：域运算符</li>
<li><strong>sizeof</strong>：长度运算符</li>
<li>**?:**：条件运算符</li>
<li>**#**： 预处理符号</li>
</ul>
<h3 id="（5）继承"><a href="#（5）继承" class="headerlink" title="（5）继承"></a>（5）继承</h3><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p>
<p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p>
<p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p>
<p><img src="/2021/01/20/c++%E5%AD%A6%E4%B9%A0-2/pic-3.png" alt="pic-3"></p>
<h4 id="基类-amp-派生类："><a href="#基类-amp-派生类：" class="headerlink" title="基类 &amp; 派生类："></a><strong>基类 &amp; 派生类：</strong></h4><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class derived-class: access-specifier base-class</span><br></pre></td></tr></table></figure>
<p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<h4 id="访问控制和继承："><a href="#访问控制和继承：" class="headerlink" title="访问控制和继承："></a><strong>访问控制和继承</strong>：</h4><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">访问</th>
<th align="left">public</th>
<th align="left">protected</th>
<th align="left">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一个类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">yes</td>
</tr>
<tr>
<td align="left">派生类</td>
<td align="left">yes</td>
<td align="left">yes</td>
<td align="left">no</td>
</tr>
<tr>
<td align="left">外部的类</td>
<td align="left">yes</td>
<td align="left">no</td>
<td align="left">no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<h4 id="继承类型："><a href="#继承类型：" class="headerlink" title="继承类型："></a>继承类型：</h4><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li>
<li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li>
<li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li>
</ul>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承:"></a>多继承:</h4><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p>
<h3 id="（6）多态"><a href="#（6）多态" class="headerlink" title="（6）多态"></a>（6）多态</h3><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>多态分为两类：</p>
<p>●静态多态:函数重载和运算符重载属于静态多态，复用函数名</p>
<p>●动态多态:派生类和虚函数实现运行时多态</p>
<p>静态多态和动态多态区别:</p>
<p>●静态多态的函数地址早绑定- 编译阶段确定函数地址</p>
<p>●动态多态的函数地址晚绑定- 运行阶段确定函数地址</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>每个子类都能有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p>
<h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础-1</title>
    <url>/2021/01/18/c++%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<h1 id="c-基础（同c比较）"><a href="#c-基础（同c比较）" class="headerlink" title="c++基础（同c比较）"></a>c++基础（同c比较）</h1><table>
<thead>
<tr>
<th></th>
<th>C</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>常规预处理命令</td>
<td>&lt;stdio.h&gt;</td>
<td><iostream>  后加using namespace std，声明存储位置；</iostream></td>
</tr>
<tr>
<td>输入</td>
<td>scanf（“%d,%d”，&amp;m,&amp;n）；</td>
<td>cin&gt;&gt;m&gt;&gt;n;</td>
</tr>
<tr>
<td>输出</td>
<td>printf（“%d”，m）；</td>
<td>cout&lt;&lt;m；</td>
</tr>
<tr>
<td>换行符</td>
<td>\n</td>
<td>endl（\n依旧沿用）</td>
</tr>
</tbody></table>
<h2 id="C-的数据类型"><a href="#C-的数据类型" class="headerlink" title="C++的数据类型"></a>C++的数据类型</h2><p><img src="/2021/01/18/c++%E5%AD%A6%E4%B9%A0-1/pic-1.jpg" alt="pic-1"></p>
<p><u>*布尔常量：布尔常量其数据类型为bool ，其取值只有两个：false（假）和true（真）。</u></p>
<p>*C++的基本数据类型与C基本相同：</p>
<p>基本数据类型（以32位编译系统为例）</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>字宽</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128~127</td>
</tr>
<tr>
<td>signed char</td>
<td>1</td>
<td>-128~127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0~255</td>
</tr>
<tr>
<td>short [int]</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>signed short [int]</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>unsigned short [int]</td>
<td>2</td>
<td>0-65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>signed [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>unsigned [int]</td>
<td>4</td>
<td>0-4294967295</td>
</tr>
<tr>
<td>long [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>signed long [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>unsigned long [int]</td>
<td>4</td>
<td>0-4294967295</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>约6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>约12位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>16</td>
<td>约15位有效数字</td>
</tr>
</tbody></table>
<h2 id="定义C-语言的标识符应该遵循如下规则："><a href="#定义C-语言的标识符应该遵循如下规则：" class="headerlink" title="定义C++语言的标识符应该遵循如下规则："></a>定义C++语言的标识符应该遵循如下规则：</h2><p>(1)标识符只能由字母、数字和下划线三类字符组成。</p>
<p>(2)第一个字符必须为字母（第一个字符也可以是下划线，但通常被视为系统自定义的标识符）。</p>
<p>(3)大写字母和小写字母被认为是两个不同的字符。</p>
<p>(4)标识符长度不限，其有效长度通常依赖于机器类型，为便于阅读，一般用有意义的单词序列的命名方法。</p>
<p>(5)标识符不能是C++的关键字。</p>
<p>C++系统关键字是系统已经预定义的一些标识符，它们的意义和作用由系统规定。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义描述</th>
<th>关键字</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>跳出循环体，结束循环</td>
<td>public</td>
<td>公有成员；公有继承</td>
</tr>
<tr>
<td>case</td>
<td>分支语句中的分支</td>
<td>return</td>
<td>从函数中返回</td>
</tr>
<tr>
<td>char</td>
<td>字符型数据</td>
<td>short</td>
<td>短整型数据</td>
</tr>
<tr>
<td>class</td>
<td>定义类的关键字</td>
<td>signed</td>
<td>有符号型数据</td>
</tr>
<tr>
<td>const</td>
<td>常量符号</td>
<td>sizeof</td>
<td>取数据类型长度运算符</td>
</tr>
<tr>
<td>continue</td>
<td>跳出本次循环，进行下一次</td>
<td>static</td>
<td>静态数据</td>
</tr>
<tr>
<td>default</td>
<td>分支语句中的默认分支</td>
<td>struct</td>
<td>定义结构体类型数据</td>
</tr>
<tr>
<td>delete</td>
<td>释放指针指向的内存块</td>
<td>switch</td>
<td>分支语句</td>
</tr>
<tr>
<td>do</td>
<td>do型循环</td>
<td>template</td>
<td>声明模板</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型数据</td>
<td>this</td>
<td>本类指针</td>
</tr>
<tr>
<td>else</td>
<td>判断语句中的否定分支</td>
<td>typedef</td>
<td>重定义数据类型</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举型数据</td>
<td>union</td>
<td>定义联合体型数据</td>
</tr>
<tr>
<td>extern</td>
<td>声明外部变量</td>
<td>virtual</td>
<td>虚继承；虚函数</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型数据</td>
<td>void</td>
<td>定义函数不返回数值</td>
</tr>
<tr>
<td>for</td>
<td>for型循环</td>
<td>while</td>
<td>while型循环</td>
</tr>
<tr>
<td>friend</td>
<td>友元类</td>
<td>int</td>
<td>整型数据</td>
</tr>
<tr>
<td>goto</td>
<td>跳转语句</td>
<td>long</td>
<td>长整型数据</td>
</tr>
<tr>
<td>if</td>
<td>条件判断语句</td>
<td>new</td>
<td>申请内存块</td>
</tr>
<tr>
<td>inline</td>
<td>声明为内联函数</td>
<td>operator</td>
<td>定义运算符重载</td>
</tr>
<tr>
<td>protected</td>
<td>保护成员；保护继承</td>
<td>private</td>
<td>私有成员；私有继承</td>
</tr>
</tbody></table>
<h2 id="C-中各类符号表示："><a href="#C-中各类符号表示：" class="headerlink" title="C++中各类符号表示："></a>C++中各类符号表示：</h2><table>
<thead>
<tr>
<th>转义字符</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>‘\a’</td>
<td>响铃符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\b’</td>
<td>退格符</td>
<td>用于回退一个字符</td>
</tr>
<tr>
<td>‘\f’</td>
<td>换页符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\r’</td>
<td>回车符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\t’</td>
<td>水平制表符</td>
<td>用于制表</td>
</tr>
<tr>
<td>‘\’</td>
<td>反斜杠符</td>
<td>用于输出或文件的路径名中</td>
</tr>
<tr>
<td>‘\’’</td>
<td>单引号</td>
<td>用于输出单引号</td>
</tr>
<tr>
<td>‘\”’</td>
<td>双引号</td>
<td>用于输出双引号</td>
</tr>
<tr>
<td>‘\0’</td>
<td>空字符</td>
<td>用于结束标志</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法运算符，或正值运算符</td>
</tr>
<tr>
<td>-</td>
<td>减法运算符，或负值运算符</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算符</td>
</tr>
<tr>
<td>/</td>
<td>除法运算符</td>
</tr>
<tr>
<td>%</td>
<td>求余运算符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>==</td>
<td>相等</td>
</tr>
<tr>
<td>!=</td>
<td>不相等</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>按位求反</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>单目运算符，逻辑非</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>双目运算符，逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>双目运算符，逻辑或</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加赋值</td>
</tr>
<tr>
<td>*=</td>
<td>乘赋值</td>
</tr>
<tr>
<td>%=</td>
<td>求余赋值</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移位赋值</td>
</tr>
<tr>
<td>|=</td>
<td>按位或赋值</td>
</tr>
<tr>
<td>-=</td>
<td>减赋值</td>
</tr>
<tr>
<td>/=</td>
<td>除赋值</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移位赋值</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与赋值</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或赋值</td>
</tr>
</tbody></table>
<p>按位求反“~”是将各个二进制位由1变成0，由0变成1，它是一个单目运算符。</p>
<p>按位与“&amp;”是将两个二进制位的操作数从低位到高位依次对齐后，每位求与运算。只有两个都是1时，结果为1，否则为0。</p>
<p>按位或“|”是将两个二进制位的操作数从低位到高位依次对齐后，每位求或运算。只有两个都是0时，结果为0，否则为1。</p>
<p>按位异或“^”是将两个二进制位的操作数从低位到高位依次对齐后，每位求异或运算。只要两个位不同时，结果为1，否则为0。</p>
<p>左移“&lt;&lt;”是将一个二进制数的数按指定移动的位数向左移动，移掉的被丢弃，右边移出的空位补0。</p>
<p>右移“&gt;&gt;”是将一个二进制数的数按指定移动的位数向右移动，移掉的被丢弃，左边移出的空位或者一律补0或者补符号位，这要由机器决定。</p>
<h2 id="选择结构："><a href="#选择结构：" class="headerlink" title="选择结构："></a>选择结构：</h2><p>\1. if语句——单行if语句，多行if语句，多条件if语句，嵌套if（使用方式和c语言基本相同）</p>
<p>\2. 表达式？x：y——三目运算符（使用方法和c语言基本相同）</p>
<p>\3. Swtch语句——switch（整型和字符）{case 常量：break；}（使用方法和c语言基本相同）</p>
<p>\4. While与do whlie语句——while（条件）{循环体}/do{循环体}while（条件）（使用方法与c语言基本相同）</p>
<p>rand（）生成一个【0，1）的随机数</p>
<h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><h2 id="函数的分文件编写："><a href="#函数的分文件编写：" class="headerlink" title="函数的分文件编写："></a>函数的分文件编写：</h2><p>1.创建后缀名.h的头文件</p>
<p>2.创建后缀名.cpp的源文件</p>
<p>3.在头文件中写函数的声明</p>
<p>4.在源文件中写函数的定义：包含<iostream>的同时还需要包含创建的“自定义头文件”</iostream></p>
<p><strong>如上，再次使用的时候直接引用自定义头文件就能够使用已定义在另一文件的函数里。</strong></p>
<h1 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h1><h2 id="空指针和野指针："><a href="#空指针和野指针：" class="headerlink" title="空指针和野指针："></a>空指针和野指针：</h2><p><strong>空指针：</strong>指针变量指向内存中编号为0的空间，用于初始化指针变量。</p>
<p><strong>（注：指向的内存不可以访问，0~255之间的内存编号为系统占用。）</strong></p>
<p>野指针：指针变量指向非法的内存空间【例如int*p=（int *）0x1100】</p>
<p><strong>由于指针的指向内容不一定在所申请的内存空间范围内，在程序中尽可能避免出现访问非法（未申请空间）的野指针。</strong></p>
<h2 id="const修饰指针："><a href="#const修饰指针：" class="headerlink" title="const修饰指针："></a>const修饰指针：</h2><p>1.const修饰指针——常量指针（const int*p=&amp;a）：指针的指向可以修改，但是指针指向的值不可以改</p>
<p>2.const修饰常量——指针常量（int * const p=&amp;a）：指针的指向不可以改，但是指针指向的值可以改</p>
<p>3.const即修饰指针又修饰常量（const int * const p=&amp;a）:指针的指向和指针指向的值都不能改</p>
<h2 id="函数指针：指向函数的指针"><a href="#函数指针：指向函数的指针" class="headerlink" title="函数指针：指向函数的指针"></a>函数指针：指向函数的指针</h2><p>函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。</p>
<p>一个函数的地址是该函数的进入点，也是调用函数的地址。</p>
<p>函数的调用可以通过函数名，也可以通过指向函数的指针来调用。</p>
<p>函数指针还允许将函数作为变元传递给其他函数。</p>
<p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p>
<p>定义形式：</p>
<pre><code>    类型 （*指针变量名）（参数列表）；</code></pre>
<p>例如：</p>
<pre><code>    int (*p)(int i,int j);</code></pre>
<p>p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。</p>
<p>p首先和*结合，表明p是一个指针。然后再与（）结合，表明它指向的是一个函数。</p>
<p>指向函数的指针也称为函数指针。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *f(int i, int j);&#x2F;&#x2F;返回值是指针的函数f</span><br><span class="line"></span><br><span class="line">int (*p)(int i, int j);&#x2F;&#x2F;指向函数的指针p</span><br></pre></td></tr></table></figure>


<h1 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h1><h2 id="1-基本概念："><a href="#1-基本概念：" class="headerlink" title="1.基本概念："></a>1.基本概念：</h2><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>
<h2 id="2-结构体定义和使用："><a href="#2-结构体定义和使用：" class="headerlink" title="2.结构体定义和使用："></a>2.结构体定义和使用：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct 结构体名称 &#123; 结构体成员列表 &#125;；</span><br></pre></td></tr></table></figure>
<p>通过结构体创建变量的方式如下三种：**(创建变量时，struct 关键字可以省略)**</p>
<ul>
<li><p><strong>struct 结构体名 变量名</strong></p>
</li>
<li><p><strong>struct 结构体名 变量名 ={ 成员1值，成员2值……}</strong></p>
</li>
<li><p><strong>定义结构体时顺便创建变量</strong></p>
</li>
</ul>
<h2 id="3-结构体数组"><a href="#3-结构体数组" class="headerlink" title="3.结构体数组"></a>3.结构体数组</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>将自定义的结构体放入数组中，方便自定义结构体的维护</p>
<h3 id="形如："><a href="#形如：" class="headerlink" title="形如："></a>形如：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct 结构体名 数组名[元素个数] &#x3D;&#123;&#123;&#125;，&#123;&#125;，&#123;&#125;......&#125;；</span><br></pre></td></tr></table></figure>


<h3 id="结构体数组遍历："><a href="#结构体数组遍历：" class="headerlink" title="结构体数组遍历："></a>结构体数组遍历：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0;i &lt; 3;i++)&#x2F;&#x2F;遍历每个结构体</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;结构体名 数组名[i].成员&lt;&lt;endl;&#x2F;&#x2F;即输出所有结构体的某一成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-结构体指针："><a href="#4-结构体指针：" class="headerlink" title="4.结构体指针："></a>4.结构体指针：</h2><p>作用：通过指针访问结构体中成员</p>
<p><strong>使用操作符-&gt;可以通过结构体指针访问结构体属性</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在学习C++的过程中我们经常会用到.和::和:和-&gt;，在此整理一下这些常用符号的区别。 </span><br><span class="line"></span><br><span class="line">  1、A.B则A为对象或者结构体(s1.age&#x3D;18;)；</span><br><span class="line"></span><br><span class="line">  2、A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</span><br><span class="line"></span><br><span class="line">  3*、::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；</span><br><span class="line"></span><br><span class="line">  4*、:一般用来表示继承；</span><br></pre></td></tr></table></figure>
<p>*<em>注意：定义指针时，指针的类型应该与被指向的结构体变量相符，即用“struct 结构体名 * 指针名”*</em></p>
<h2 id="5-结构体嵌套结构体"><a href="#5-结构体嵌套结构体" class="headerlink" title="5.结构体嵌套结构体"></a>5.结构体嵌套结构体</h2><p>作用：在一个结构体内嵌套另一个结构体，即将结构体的成员设置为结构体（参考嵌套if）</p>
<p><strong>注意：在定义外层结构体前，需要先定义内层结构体</strong></p>
<h2 id="6-结构体做函数参数"><a href="#6-结构体做函数参数" class="headerlink" title="6.结构体做函数参数"></a>6.结构体做函数参数</h2><p>作用：将结构体作为参数向函数中传递</p>
<p><strong>两种传递方式：值传递、地址传递</strong>（同基本数据类型相同）</p>
<h2 id="7-结构体中const使用场景"><a href="#7-结构体中const使用场景" class="headerlink" title="7.结构体中const使用场景"></a>7.结构体中const使用场景</h2><p>作用：用const来防止误操作，一旦有修改的操作就会报错</p>
<h1 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h1><h2 id="1-用处："><a href="#1-用处：" class="headerlink" title="1.用处："></a><strong>1.用处：</strong></h2><p>给一个变量起别名，通过多个变量名修改变量值</p>
<h2 id="2-形如："><a href="#2-形如：" class="headerlink" title="2.形如："></a><strong>2.形如：</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型 &amp;别名 &#x3D; 原名</span><br></pre></td></tr></table></figure>


<h2 id="3-注意事项：引用必须初始化，且在初始化后不可以改变"><a href="#3-注意事项：引用必须初始化，且在初始化后不可以改变" class="headerlink" title="3.注意事项：引用必须初始化，且在初始化后不可以改变"></a>3.注意事项：引用必须初始化，且在初始化后不可以改变</h2><h2 id="4-引用做函数参数"><a href="#4-引用做函数参数" class="headerlink" title="4.引用做函数参数"></a>4.引用做函数参数</h2><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<h2 id="5-引用做函数返回值"><a href="#5-引用做函数返回值" class="headerlink" title="5.引用做函数返回值"></a>5.引用做函数返回值</h2><p><strong>用法：</strong>函数调用可以作为左值</p>
<p><strong>（f（）=1000；先运行返回引用的函数f（）得到返回值，然后返回值=1000）</strong></p>
<p><strong>注意：不要返回局部变量引用——可给局部变量加static前缀，变成静态变量</strong></p>
<p><em>（第一次结果因为编译器做了保留，所以正确，但第二次局部变量已经被释放，结果会乱码错误。）</em></p>
<h2 id="6-引用的本质："><a href="#6-引用的本质：" class="headerlink" title="6.引用的本质："></a>6.引用的本质：</h2><p><strong>引用在c++内部的实现，实际上是一个指针常量</strong></p>
<h2 id="7-常量引用"><a href="#7-常量引用" class="headerlink" title="7.常量引用"></a>7.常量引用</h2><p><strong>作用：常量引用主要用来修饰形参，防止误操作，在函数形参列表中加const修饰形参，防止形参改变实参</strong></p>
<h1 id="函数提高："><a href="#函数提高：" class="headerlink" title="函数提高："></a>函数提高：</h1><h2 id="1-函数默认参数"><a href="#1-函数默认参数" class="headerlink" title="1.函数默认参数"></a>1.函数默认参数</h2><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （参数&#x3D;默认值）&#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<p>1.如果某个位置已经有了默认参数，那么之后都必须有默认值</p>
<p>2.如果函数声明中有默认参数，函数实现中不能有默认参数（重定义）</p>
<h2 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h2><p>c++中函数的形参列表可以有占位参数，用来做占位，调用函数时，必须填补该位置</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名 （数据类型无形参名）&#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：占位参数也可以有默认参数</strong></p>
<h2 id="3-函数重载"><a href="#3-函数重载" class="headerlink" title="3.函数重载"></a>3.函数重载</h2><p>作用：函数名可以相同，提高复用性</p>
<h3 id="1-函数重载满足条件："><a href="#1-函数重载满足条件：" class="headerlink" title="1.函数重载满足条件："></a><strong>1.函数重载满足条件：</strong></h3><ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数类型不同，或者个数不同，或者顺序不同</li>
</ul>
<p>*<strong>函数的返回值不可以作为函数重载的条件</strong></p>
<h3 id="2-注意事项："><a href="#2-注意事项：" class="headerlink" title="2.注意事项："></a>2.注意事项：</h3><ul>
<li><p>引用作为重载条件（int &amp;a——应用变量，const int &amp;a——应用常量）</p>
</li>
<li><p>函数重载遇到函数的默认参数（在默认参数影响下，输入的函数参数个数可以变化，并有可能与重载的其他函数重复，从而产生错误）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业课程</category>
        <category>C++</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-4</title>
    <url>/2021/02/19/Linux%E5%AD%A6%E4%B9%A0-4/</url>
    <content><![CDATA[<h1 id="常用命令大全："><a href="#常用命令大全：" class="headerlink" title="常用命令大全："></a>常用命令大全：</h1><h2 id="日常使用命令"><a href="#日常使用命令" class="headerlink" title="日常使用命令"></a>日常使用命令</h2><p>开关机命令<br>1、shutdown –h now：立刻进行关机</p>
<p>2、shutdown –r now：现在重新启动计算机</p>
<p>3、reboot：现在重新启动计算机</p>
<p>4、su -：切换用户；passwd：修改用户密码</p>
<p>5、logout：用户注销</p>
<h2 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h2><p>1、tab = 补全</p>
<p>2、ctrl + l -：清屏，类似clear命令</p>
<p>3、ctrl + r -：查找历史命令（history）；ctrl+c = 终止</p>
<p>4、ctrl+k = 删除此处至末尾所有内容</p>
<p>5、ctrl+u = 删除此处至开始所有内容</p>
<p>6、linux中的帮助命令：man、info、–help【[root@localhost ~]# man ls；[root@localhost ~]# info ls；[root@localhost ~]# ls –help】。退出帮助的话，按快捷键q</p>
<h2 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h2><p>1、ls</p>
<p>ls命令是列出目录内容的意思（List Directtory Contents）。运行它就是列出文件夹的内容，可能是文件也可能是文件夹。</p>
<p>  ls -l命令以详情模式(long listing fashion)列出文件夹的内容。</p>
<p>  ls -a命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件。</p>
<p>  注意：在Linux中，文件以“.”开头就是隐藏文件，并且每个文件，文件夹，设备或者命令都是以文件对待。</p>
<p>  2、lsblk</p>
<p>  lsblk就是列出块设备。除了RAM外，以标准的树状输出格式，整齐地显示块设备。</p>
<p>  lsblk -l命令以列表格式显示块设备(而不是树状格式)。</p>
<p>  注意：lsblk是最有用和最简单的方式来了解新插入的USB设备的名字，特别是当你在终端上处理磁盘/块设备时。</p>
<p>  3、uname</p>
<p>  “uname”命令就是Unix Name的简写。显示机器名，操作系统和内核的详细信息。</p>
<p>  注意：uname显示内核类别，uname -a显示详细信息。</p>
<p>  4、history</p>
<p>  “history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史。</p>
<p>  5、sudo</p>
<p>  “sudo”(super userdo)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p>
<p>  注意：sudo允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。</p>
<p>  并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事。</p>
<p>  6、chmod</p>
<p>  “chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p>
<p>  7、chown</p>
<p>  “chown”命令就是改变文件拥有者和所在用户组。每个文件都属于一个用户组和一个用户。在你的目录下，使用”ls -l”,你就会看到像这样的东西。</p>
<p>  8、apt</p>
<p>  Debian系列以“apt”命令为基础，“apt”代表了Advanced Package Tool。APT是一个为Debian系列系统（Ubuntu，Kubuntu等等）开发的高级包管理器，在Gnu/Linux系统上，它会为包自动地，智能地搜索，安装，升级以及解决依赖。例如：apt-get install mplayer</p>
<p>  9、cal</p>
<p>  “cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份。</p>
<p>  10、date</p>
<p>  “date”命令使用标准的输出打印当前的日期和时间，也可以深入设置。</p>
<h3 id="系统常用操作命令"><a href="#系统常用操作命令" class="headerlink" title="系统常用操作命令"></a>系统常用操作命令</h3><h4 id="1、指定运行级别"><a href="#1、指定运行级别" class="headerlink" title="1、指定运行级别"></a>1、指定运行级别</h4><p>命令：init[0123456]</p>
<p>运行级别：（0：关机；1：单用户；2：多用户状态没有网络服务；3：多用户状态有网络服务；4：系统未使用保留给用户；5：图形界面；6：系统重启）。</p>
<p> 常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab的id:5:inittab：这一行的数字。</p>
<p> 在启动引导界面的时候按e进入编辑，在进入grub引界面时，请输入e再选中第二个选项按e，再最后输入1[单用户级别]，然后按b进入单用户模式。</p>
<p> *：可通过此方法进行linux用户密码的修改。</p>
<h4 id="2、文件显示命令"><a href="#2、文件显示命令" class="headerlink" title="2、文件显示命令"></a>2、文件显示命令</h4><p>more：显示文件内容，带分页；</p>
<p>less：显示文件内容带分页；</p>
<p> grep：在文件中查询内容，grep –n “查找内容” 文件名；</p>
<p> | [管道命令]：在linux和unix系统中 | 就是管道命令，把上一个命令的结果交给 | 的后面的命令进行处理。</p>
<p> 例：grep –n “查找内容” 文件名 | more</p>
<p> cat：把文件串连接后输出到屏幕或加 &gt; fileName 到另一个档案。</p>
<p> head：格式：head [-n|c num]fileName，说明：显示文件头部内容。没有参数时，显示最前10行。</p>
<p> tail：格式：tail [-n|c num]fileName，说明：显示文件尾部内容。没有参数时，显示最后10行。</p>
<p> cut：格式：cut -cnum1-num2 filename，说明：显示每行从开头算起第 num1 到 num2 的字符。</p>
<h4 id="3、文件搜索命令find"><a href="#3、文件搜索命令find" class="headerlink" title="3、文件搜索命令find"></a>3、文件搜索命令find</h4><p>find：搜索文件及目录</p>
<p>在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而find命令可以解决上述问题。</p>
<p>  1、在特定的目录下搜索并显示指定名称的文件和目录。</p>
<p>  find / -name man：意思是说从根目录开始搜索名称为man的文件或目录。</p>
<p>  2、搜索一段时间内被存取/变更的文件或目录</p>
<p>  find / home–amin -10：十分钟内存取的文件或目录</p>
<p>  find / home–atime -10：十小时内存取的文件或目录</p>
<p>  find / home–cmin -10：十分钟内更改过的文件或目录</p>
<p>  find / home–ctime -10：十小时内更改过的文件或目录</p>
<p>  3、搜索指定大小的文件</p>
<p>  find / home–size +10k：意思是说查找/home目录下大小为10K的文件。</p>
<h4 id="4、重定向命令"><a href="#4、重定向命令" class="headerlink" title="4、重定向命令"></a>4、重定向命令</h4><p>重定向命令：管道定向命令“&gt;”为覆盖，“&gt;&gt;”追加写在原文件内容后面。</p>
<p>ls –l &gt;a.txt 列表的内容写入文件a.txt中（覆盖写）。</p>
<p>  ls –al&gt;&gt; aa.txt 列表的内容追加到文件aa.txt的末尾。</p>
<h4 id="5、其他命令"><a href="#5、其他命令" class="headerlink" title="5、其他命令"></a>5、其他命令</h4><p>who：格式：who - [husfV] [user]。说明：显示有哪些用户登录到系统中，显示的信息包含用户ID，使用的终端，上线时间，呆滞时间，CPU使用量，动作等等。相关命令 : who am i：显示当前用户是谁。</p>
<p>sleep：格式：sleep [–help] [–version] number[smhd]。说明 : sleep 可以用来将当前动作延迟一段时间。</p>
<p>  kill：格式：kill [ -s signal ] pid … 或 kill -l [ signal ]。说明：kill送出一个特定的信号 (signal) 给进程号为 pid 的进程。根据该信号而做特定的动作，若没有指定，默认是送出终止(TERM)信号。</p>
<p>  ps：格式：ps [options] [–help]。说明：显示进程的名称、占用资源、状态等。</p>
<p>  top：说明：显示CPU的使用率、内存大小、内存使用率、进程状态等。</p>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p>
<h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd … 返回上一级目录<br>cd …/… 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p>
<h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
<h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’ I n s t a l l e d − S i z e ; 10 t {Installed-Size;10}t Installed−Size;10t{Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
<h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p>
<h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><p><strong>使用 “+” 设置权限，使用 “-” 用于取消</strong></p>
<p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位</p>
<p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-” 用于取消<br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性</p>
<h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p>
<h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p>
<h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p>
<h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p>
<h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p>
<h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p>
<h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 49: …所有空白行 sed ‘/ *#̲/d; /^/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p>
<h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode …HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p>
<h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p>
<h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p>
<h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p>
<h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p>
<h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’</p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-3</title>
    <url>/2021/02/10/Linux%E5%AD%A6%E4%B9%A0-3/</url>
    <content><![CDATA[<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<ul>
<li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>/</strong> 写起，例如： /usr/share/doc 这个目录。</p>
</li>
<li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>/</strong> 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： <strong>cd ../man</strong> 这就是相对路径的写法。</p>
</li>
</ul>
<hr>
<h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~]# ls [--color&#x3D;&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~]# ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将家目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure>
<h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> cd [相对路径或绝对路径]</span><br><span class="line">#使用 mkdir 命令创建 runoob 目录</span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"></span><br><span class="line">#使用绝对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd &#x2F;root&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line">#使用相对路径切换到 runoob 目录</span><br><span class="line">[root@www ~]# cd .&#x2F;runoob&#x2F;</span><br><span class="line"></span><br><span class="line"># 表示回到自己的家目录，亦即是 &#x2F;root 这个目录</span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"></span><br><span class="line"># 表示去到目前的上一级目录，亦即是 &#x2F;root 的上一级目录的意思；</span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure>
<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd [-P]</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li>
</ul>
<p>实例：单纯显示出目前的工作目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd</span><br><span class="line">&#x2F;root   &lt;&#x3D;&#x3D; 显示出目录啦～</span><br></pre></td></tr></table></figure>
<p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;var&#x2F;mail   &lt;&#x3D;&#x3D;注意，&#x2F;var&#x2F;mail是一个连结档</span><br><span class="line">[root@www mail]# pwd</span><br><span class="line">&#x2F;var&#x2F;mail         &lt;&#x3D;&#x3D;列出目前的工作目录</span><br><span class="line">[root@www mail]# pwd -P</span><br><span class="line">&#x2F;var&#x2F;spool&#x2F;mail   &lt;&#x3D;&#x3D;怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@www mail]# ls -ld &#x2F;var&#x2F;mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 Sep  4 17:54 &#x2F;var&#x2F;mail -&gt; spool&#x2F;mail</span><br><span class="line"># 看到这里应该知道为啥了吧？因为 &#x2F;var&#x2F;mail 是连结档，连结到 &#x2F;var&#x2F;spool&#x2F;mail </span><br><span class="line"># 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</span><br></pre></td></tr></table></figure>
<h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：请到/tmp底下尝试创建数个新目录看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# mkdir test    &lt;&#x3D;&#x3D;创建一名为 test 的新目录</span><br><span class="line">[root@www tmp]# mkdir test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">mkdir: cannot create directory &#96;test1&#x2F;test2&#x2F;test3&#x2F;test4&#39;: </span><br><span class="line">No such file or directory       &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！</span><br><span class="line">[root@www tmp]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br></pre></td></tr></table></figure>
<p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p>
<p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mkdir -m 711 test2</span><br><span class="line">[root@www tmp]# ls -l</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>
<p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p>
<p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p>
<h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li>
</ul>
<p>删除 runoob 目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# rmdir runoob&#x2F;</span><br></pre></td></tr></table></figure>
<p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# ls -l   &lt;&#x3D;&#x3D;看看有多少目录存在？</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br><span class="line">[root@www tmp]# rmdir test   &lt;&#x3D;&#x3D;可直接删除掉，没问题</span><br><span class="line">[root@www tmp]# rmdir test1  &lt;&#x3D;&#x3D;因为尚有内容，所以无法删除！</span><br><span class="line">rmdir: &#96;test1&#39;: Directory not empty</span><br><span class="line">[root@www tmp]# rmdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4</span><br><span class="line">[root@www tmp]# ls -l        &lt;&#x3D;&#x3D;您看看，底下的输出中test与test1不见了！</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>
<p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p>
<p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p>
<h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">[root@www ~]# cp -i ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc</span><br><span class="line">cp: overwrite &#96;&#x2F;tmp&#x2F;bashrc&#39;? n  &lt;&#x3D;&#x3D;n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>
<h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
<li></li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# rm -i bashrc</span><br><span class="line">rm: remove regular file &#96;bashrc&#39;? y</span><br></pre></td></tr></table></figure>
<p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
<h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd &#x2F;tmp</span><br><span class="line">[root@www tmp]# cp ~&#x2F;.bashrc bashrc</span><br><span class="line">[root@www tmp]# mkdir mvtest</span><br><span class="line">[root@www tmp]# mv bashrc mvtest</span><br></pre></td></tr></table></figure>
<p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mv mvtest mvtest2</span><br></pre></td></tr></table></figure>


<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>检看 /etc/issue 这个文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cat &#x2F;etc&#x2F;issue</span><br><span class="line">CentOS release 6.4 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>
<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# tac &#x2F;etc&#x2F;issue</span><br><span class="line"></span><br><span class="line">Kernel \r on an \m</span><br><span class="line">CentOS release 6.4 (Final)</span><br></pre></td></tr></table></figure>
<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>实例一：用 nl 列出 /etc/issue 的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# nl &#x2F;etc&#x2F;issue</span><br><span class="line">     1  CentOS release 6.4 (Final)</span><br><span class="line">     2  Kernel \r on an \m</span><br></pre></td></tr></table></figure>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# more &#x2F;etc&#x2F;man_db.config </span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">--More--(28%)  &lt;&#x3D;&#x3D; </span><br></pre></td></tr></table></figure>
<p>在 more 这个程序的运行过程中：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# less &#x2F;etc&#x2F;man.config</span><br><span class="line">#</span><br><span class="line"># Generated automatically from man.conf.in by the</span><br><span class="line"># configure script.</span><br><span class="line">#</span><br><span class="line"># man.conf from man-1.6d</span><br><span class="line">....(中间省略)....</span><br><span class="line">:   &lt;&#x3D;&#x3D; 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure>
<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head [-n number] 文件 </span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head -n 20 &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail [-n number] 文件 </span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# tail &#x2F;etc&#x2F;man.config</span><br><span class="line"># 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：</span><br><span class="line">[root@www ~]# tail -n 20 &#x2F;etc&#x2F;man.config</span><br></pre></td></tr></table></figure>


<h2 id="Linux-链接概念"><a href="#Linux-链接概念" class="headerlink" title="Linux 链接概念"></a>Linux 链接概念</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，<strong>ln</strong> 命令产生硬链接。</p>
<h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a><strong>硬连接</strong></h3><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a><strong>软连接</strong></h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<h3 id="可以得到以下全部结论："><a href="#可以得到以下全部结论：" class="headerlink" title="可以得到以下全部结论："></a>可以得到以下全部结论：</h3><p>1).删除符号连接f3,对f1,f2无影响</p>
<p>2).删除硬连接f2，对f1,f3也无影响</p>
<p>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效</p>
<p> 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除</p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-2</title>
    <url>/2021/02/09/Linux%E5%AD%A6%E4%B9%A0-2/</url>
    <content><![CDATA[<h1 id="Linux-远程登录"><a href="#Linux-远程登录" class="headerlink" title="Linux 远程登录"></a>Linux 远程登录</h1><p>Linux 一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的 Linux 服务器。</p>
<p>这时我们就需要远程登录到Linux服务器来管理维护系统。</p>
<p>Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22。</p>
<p>Window 系统上 Linux 远程登录客户端有 SecureCRT, Putty, SSH Secure Shell 等</p>
<h2 id="使用密钥认证机制远程登录linux"><a href="#使用密钥认证机制远程登录linux" class="headerlink" title="使用密钥认证机制远程登录linux"></a>使用密钥认证机制远程登录linux</h2><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。</p>
<p>SSH 为建立在应用层和传输层基础上的安全协议。</p>
<p>该工具可以生成三种格式的key ：SSH-1(RSA) SSH-2(RSA) SSH-2(DSA) ，我们采用默认的格式即 SSH-2(RSA)。Number of bits in a generated key 这个是指生成的key的大小，这个数值越大，生成的key就越复杂，安全性就越高。</p>
<h3 id="1）创建目录-root-ssh-并设置权限"><a href="#1）创建目录-root-ssh-并设置权限" class="headerlink" title="1）创建目录 /root/.ssh 并设置权限"></a>1）创建目录 /root/.ssh 并设置权限</h3><p>[root@localhost ~]# mkdir /root/.ssh mkdir 命令用来创建目录，以后会详细介绍，暂时只了解即可。</p>
<p>[root@localhost ~]# chmod 700 /root/.ssh chmod 命令是用来修改文件属性权限的，以后会详细介绍。</p>
<h3 id="2）创建文件-root-ssh-authorized-keys"><a href="#2）创建文件-root-ssh-authorized-keys" class="headerlink" title="2）创建文件 / root/.ssh/authorized_keys"></a>2）创建文件 / root/.ssh/authorized_keys</h3><p>[root@localhost ~]# vim /root/.ssh/authorized_keys vim 命令是编辑一个文本文件的命令，同样在后续章节详细介绍。</p>
<h3 id="3）打开刚才生成的public-key-文件"><a href="#3）打开刚才生成的public-key-文件" class="headerlink" title="3）打开刚才生成的public key 文件"></a>3）打开刚才生成的public key 文件</h3><p>建议使用写字板打开，这样看着舒服一些，复制从AAAA开头至 “—- END SSH2 PUBLIC KEY —-“ 该行上的所有内容，粘贴到/root/.ssh/authorized_keys 文件中，要保证所有字符在一行。（可以先把复制的内容拷贝至记事本，然后编辑成一行载粘贴到该文件中）。</p>
<p>在这里要简单介绍一下，如何粘贴，用vim打开那个文件后，该文件不存在，所以vim会自动创建。按一下字母”i”然后同时按shift + Insert 进行粘贴（或者单击鼠标右键即可），前提是已经复制到剪切板中了。粘贴好后，然后把光标移动到该行最前面输入 <strong>ssh-rsa</strong> </p>
<h3 id="4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth"><a href="#4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth" class="headerlink" title="4）再设置putty选项，点窗口左侧的SSh –&gt; Auth"></a>4）再设置putty选项，点窗口左侧的SSh –&gt; Auth</h3><p>单击窗口右侧的Browse… 选择刚刚生成的私钥， 再点Open ，此时输入root，就不用输入密码就能登录了。</p>
<p>如果在前面你设置了Key Passphrase ，那么此时就会提示你输入密码的。为了更加安全建议大家要设置一个Key Passphrase。</p>
<h2 id="终端利用ssh登录远程服务器"><a href="#终端利用ssh登录远程服务器" class="headerlink" title="终端利用ssh登录远程服务器"></a><strong>终端利用ssh登录远程服务器</strong></h2><p>安装ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install ssh</span><br></pre></td></tr></table></figure>
<p>启动ssh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></table></figure>
<p>登录远程服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -p 50022 my@127.0.0.1</span><br><span class="line">输入密码：</span><br><span class="line">my@127.0.0.1:</span><br></pre></td></tr></table></figure>
<p><strong>-p</strong> 后面是端口</p>
<p><strong>my</strong> 是服务器用户名</p>
<p><strong>127.0.0.1</strong> 是服务器 ip</p>
<p>回车输入密码即可登录</p>
<h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p>
<p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p>
<ul>
<li>chown (change ownerp) ： 修改所属用户与组。</li>
<li>chmod (change mode) ： 修改用户的权限。</li>
</ul>
<p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www &#x2F;]# ls -l</span><br><span class="line">total 64</span><br><span class="line">dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class="line">dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p>
<p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p>
<ul>
<li>当为 <strong>d</strong> 则是目录</li>
<li>当为 <strong>-</strong> 则是文件；</li>
<li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li>
<li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li>
<li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p>
<p><img src="/2021/02/09/Linux%E5%AD%A6%E4%B9%A0-2/pic-2.png" alt="pic-2"></p>
<p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p>
<p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p>
<p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p>
<p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p>
<h1 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www &#x2F;]# ls -l</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron</span><br><span class="line">drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p>
<p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p>
<h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h3><p>Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。</p>
<p>与 chown的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>
<p>在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>
<h4 id="语法1："><a href="#语法1：" class="headerlink" title="语法1："></a>语法1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-R] 属组名 文件名</span><br></pre></td></tr></table></figure>
<h4 id="参数选项："><a href="#参数选项：" class="headerlink" title="参数选项："></a>参数选项：</h4><ul>
<li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li>
</ul>
<h4 id="语法2："><a href="#语法2：" class="headerlink" title="语法2："></a>语法2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference&#x3D;&lt;参考文件或目录&gt;][--version][文件或目录...]</span><br></pre></td></tr></table></figure>
<h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p>
<p>　　-f或–quiet或–silent 　不显示错误信息。</p>
<p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p>
<p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p>
<p>　　-v或–verbose 　显示指令执行过程。</p>
<p>　　–help 　在线帮助。</p>
<p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p>
<p>　　–version 　显示版本信息。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="实例1：改变文件的群组属性："><a href="#实例1：改变文件的群组属性：" class="headerlink" title="实例1：改变文件的群组属性："></a>实例1：改变文件的群组属性：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp -v bin log2012.log</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log</span><br><span class="line">[root@localhost test]# chgrp -v bin log2012.log</span><br></pre></td></tr></table></figure>
<p>“log2012.log” 的所属组已更改为 bin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure>
<p>说明： 将log2012.log文件由root群组改为bin群组</p>
<h5 id="实例2：根据指定文件改变文件的群组属性"><a href="#实例2：根据指定文件改变文件的群组属性" class="headerlink" title="实例2：根据指定文件改变文件的群组属性"></a>实例2：根据指定文件改变文件的群组属性</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp --reference&#x3D;log2012.log log2013.log</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</span><br><span class="line">-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]#  chgrp --reference&#x3D;log2012.log log2013.log </span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</span><br><span class="line">-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure>
<p>说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p>
<h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>Linux chown（英文全拼：<strong>change owner</strong>）命令用于设置文件所有者和文件关联组的命令。</p>
<p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 </p>
<p>只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 chgrp 命令。</p>
<h4 id="语法1：-1"><a href="#语法1：-1" class="headerlink" title="语法1："></a>语法1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown [–R] 属主名 文件名</span><br><span class="line">chown [-R] 属主名：属组名 文件名</span><br></pre></td></tr></table></figure>
<h4 id="语法2：-1"><a href="#语法2：-1" class="headerlink" title="语法2："></a>语法2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数 :"></a><strong>参数</strong> :</h4><ul>
<li>user : 新的文件拥有者的使用者 ID</li>
<li>group : 新的文件拥有者的使用者组(group)</li>
<li>-c : 显示更改的部分的信息</li>
<li>-f : 忽略错误信息</li>
<li>-h :修复符号链接</li>
<li>-v : 显示详细的处理信息</li>
<li>-R : 处理指定目录以及其子目录下的所有文件</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>把 /var/run/httpd.pid 的所有者设置 root：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown root &#x2F;var&#x2F;run&#x2F;httpd.pid</span><br></pre></td></tr></table></figure>
<p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown runoob:runoobgroup file1.txt</span><br></pre></td></tr></table></figure>
<p>将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure>
<p>把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown :512 &#x2F;home&#x2F;runoob</span><br></pre></td></tr></table></figure>
<p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~] cd ~</span><br><span class="line">[root@www ~]# chown bin install.log</span><br><span class="line">[root@www ~]# ls -l</span><br><span class="line">-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>
<p>将install.log的拥有者与群组改回为root：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# chown root:root install.log</span><br><span class="line">[root@www ~]# ls -l</span><br><span class="line">-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</span><br></pre></td></tr></table></figure>


<h3 id="3、chmod：更改文件9个属性"><a href="#3、chmod：更改文件9个属性" class="headerlink" title="3、chmod：更改文件9个属性"></a>3、chmod：更改文件9个属性</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>
<h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>mode : 权限设定字串，格式如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ugoa...][[+-&#x3D;][rwxX]...][,...]</span><br></pre></td></tr></table></figure>
<h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
</ul>
<h4 id="其他参数说明："><a href="#其他参数说明：" class="headerlink" title="其他参数说明："></a>其他参数说明：</h4><ul>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<h4 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h4><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p>
<table>
<thead>
<tr>
<th align="left">who</th>
<th align="left">用户类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>u</code></td>
<td align="left">user</td>
<td align="left">文件所有者</td>
</tr>
<tr>
<td align="left"><code>g</code></td>
<td align="left">group</td>
<td align="left">文件所有者所在组</td>
</tr>
<tr>
<td align="left"><code>o</code></td>
<td align="left">others</td>
<td align="left">所有其他用户</td>
</tr>
<tr>
<td align="left"><code>a</code></td>
<td align="left">all</td>
<td align="left">所用用户, 相当于 <em>ugo</em></td>
</tr>
</tbody></table>
<h5 id="operator-的符号模式表"><a href="#operator-的符号模式表" class="headerlink" title="operator 的符号模式表:"></a>operator 的符号模式表:</h5><table>
<thead>
<tr>
<th align="left">Operator</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td align="left">为指定的用户类型增加权限</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td align="left">去除指定用户类型的权限</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody></table>
<h5 id="permission-的符号模式表"><a href="#permission-的符号模式表" class="headerlink" title="permission 的符号模式表:"></a>permission 的符号模式表:</h5><table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">名字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>r</code></td>
<td align="left">读</td>
<td align="left">设置为可读权限</td>
</tr>
<tr>
<td align="left"><code>w</code></td>
<td align="left">写</td>
<td align="left">设置为可写权限</td>
</tr>
<tr>
<td align="left"><code>x</code></td>
<td align="left">执行权限</td>
<td align="left">设置为可执行权限</td>
</tr>
<tr>
<td align="left"><code>X</code></td>
<td align="left">特殊执行权限</td>
<td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">setuid/gid</td>
<td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td>
</tr>
<tr>
<td align="left"><code>t</code></td>
<td align="left">粘贴位</td>
<td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td>
</tr>
</tbody></table>
<h4 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h4><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p>
<table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">权限</th>
<th align="left">rwx</th>
<th align="left">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">7</td>
<td align="left">读 + 写 + 执行</td>
<td align="left">rwx</td>
<td align="left">111</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">读 + 写</td>
<td align="left">rw-</td>
<td align="left">110</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">读 + 执行</td>
<td align="left">r-x</td>
<td align="left">101</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">只读</td>
<td align="left">r–</td>
<td align="left">100</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">写 + 执行</td>
<td align="left">-wx</td>
<td align="left">011</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">只写</td>
<td align="left">-w-</td>
<td align="left">010</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">只执行</td>
<td align="left">–x</td>
<td align="left">001</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">无</td>
<td align="left">—</td>
<td align="left">000</td>
</tr>
</tbody></table>
<p>例如， 765 将这样解释：</p>
<ul>
<li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li>
<li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li>
<li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li>
</ul>
<h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h4><p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ugo+r file1.txt</span><br></pre></td></tr></table></figure>
<p>将文件 file1.txt 设为所有人皆可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+r file1.txt</span><br></pre></td></tr></table></figure>
<p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ug+w,o-w file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x ex1.py</span><br></pre></td></tr></table></figure>
<p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R a+r *</span><br></pre></td></tr></table></figure>
<p>此外chmod也可以用数字来表示权限如 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>
<p>语法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod abc file</span><br></pre></td></tr></table></figure>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p>r=4，w=2，x=1</p>
<ul>
<li>若要 rwx 属性则 4+2+1=7；</li>
<li>若要 rw- 属性则 4+2=6；</li>
<li>若要 r-x 属性则 4+1=5。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a&#x3D;rwx file</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 file</span><br></pre></td></tr></table></figure>
<p>效果相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod ug&#x3D;rwx,o&#x3D;x file</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 771 file</span><br></pre></td></tr></table></figure>
<p>效果相同</p>
<p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p>
<h4 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h4><table>
<thead>
<tr>
<th align="left"><code>命令</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>chmod a+r *file*</code></td>
<td align="left">给file的所有用户增加读权限</td>
</tr>
<tr>
<td align="left"><code>chmod a-x *file*</code></td>
<td align="left">删除file的所有用户的执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod a+rw *file*</code></td>
<td align="left">给file的所有用户增加读写权限</td>
</tr>
<tr>
<td align="left"><code>chmod +rwx *file*</code></td>
<td align="left">给file的所有用户增加读写执行权限</td>
</tr>
<tr>
<td align="left"><code>chmod u=rw,go= *file*</code></td>
<td align="left">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td>
</tr>
<tr>
<td align="left"><code>chmod -R u+r,go-r *docs*</code></td>
<td align="left">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 664 *file*</code></td>
<td align="left">对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td>
</tr>
<tr>
<td align="left"><code>chmod 0755 *file*</code></td>
<td align="left">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code> 没有特殊模式。</td>
</tr>
<tr>
<td align="left"><code>chmod 4755 *file*</code></td>
<td align="left"><code>4</code>设置了设置<a href="https://www.runoob.com/wiki/%E7%94%A8%E6%88%B7ID">用户ID</a>位，剩下的相当于 u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)。</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td>
<td align="left">删除可执行权限对path/以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td>
</tr>
<tr>
<td align="left"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td>
<td align="left">允许所有用户浏览或通过目录path/</td>
</tr>
</tbody></table>
<p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p>
<p>Linux 文件的基本权限就有九个，分别是 <strong>owner/group/others(拥有者/组/其他)</strong> 三种身份各有自己的 <strong>read/write/execute</strong> 权限。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<ul>
<li>r:4</li>
<li>w:2</li>
<li>x:1</li>
</ul>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—</strong> 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= — = 0+0+0 = 0</li>
</ul>
<p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod [-R] xyz 文件或目录</span><br></pre></td></tr></table></figure>
<p>选项与参数：</p>
<ul>
<li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li>
<li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li>
</ul>
<p>举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls -al .bashrc</span><br><span class="line">-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc</span><br><span class="line">[root@www ~]# chmod 777 .bashrc</span><br><span class="line">[root@www ~]# ls -al .bashrc</span><br><span class="line">-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</span><br></pre></td></tr></table></figure>
<p>那如果要将权限变成 <em>-rwxr-xr–</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。</p>
<h4 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h4><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p>
<ul>
<li>user：用户</li>
<li>group：组</li>
<li>others：其他</li>
</ul>
<p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p>
<p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p>
<table>
<thead>
<tr>
<th>chmod</th>
<th>u g o a</th>
<th>+(加入) -(除去) =(设定)</th>
<th>r w x</th>
<th>文件或目录</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 <strong>chmod u=rwx,g=rx,o=r 文件名</strong> 来设定:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  touch test1    &#x2F;&#x2F; 创建 test1 文件</span><br><span class="line"># ls -al test1    &#x2F;&#x2F; 查看 test1 默认权限</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br><span class="line"># chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r  test1    &#x2F;&#x2F; 修改 test1 权限</span><br><span class="line"># ls -al test1</span><br><span class="line">-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>
<p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  chmod  a-x test1</span><br><span class="line"># ls -al test1</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>课外拓展</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-1</title>
    <url>/2021/01/26/Linux%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h1 id="Linux-应用领域"><a href="#Linux-应用领域" class="headerlink" title="Linux 应用领域"></a>Linux 应用领域</h1><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p>
<h1 id="Linux-和-Windows的区别"><a href="#Linux-和-Windows的区别" class="headerlink" title="Linux 和 Windows的区别"></a>Linux 和 Windows的区别</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Windows</th>
<th align="left">Linux</th>
</tr>
</thead>
<tbody><tr>
<td align="left">界面</td>
<td align="left">界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td>
<td align="left">图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td>
</tr>
<tr>
<td align="left">驱动程序</td>
<td align="left">驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td>
<td align="left">由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td>
</tr>
<tr>
<td align="left">使用</td>
<td align="left">使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td>
<td align="left">图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td>
</tr>
<tr>
<td align="left">学习</td>
<td align="left">系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td>
<td align="left">系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td>
</tr>
<tr>
<td align="left">软件</td>
<td align="left">每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td>
<td align="left">大部分软件都可以自由获取，同样功能的软件选择较少。</td>
</tr>
</tbody></table>
<h1 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h1><p>linux启动时我们会看到许多启动信息。</p>
<p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p>
<ul>
<li>内核的引导</li>
<li>运行 init</li>
<li>系统初始化</li>
<li>建立终端 </li>
<li>用户登录系统</li>
</ul>
<h2 id="init程序的类型："><a href="#init程序的类型：" class="headerlink" title="init程序的类型："></a>init程序的类型：</h2><ul>
<li>SysV: init, CentOS 5之前, 配置文件： /etc/inittab</li>
<li>Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf</li>
<li>Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system</li>
</ul>
<h2 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h2><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>
<p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p>
<h2 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a>运行init</h2><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<p>init 程序首先是需要读取配置文件 /etc/inittab。</p>
<h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>
<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p>Linux系统有7个运行级别(runlevel)：</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登陆后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l5:5:wait:&#x2F;etc&#x2F;rc.d&#x2F;rc 5</span><br></pre></td></tr></table></figure>

<p>这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。</p>
<p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p>
<p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p>
<p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p>
<h2 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h2><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p>
<p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:&#x2F;sbin&#x2F;mingetty tty1</span><br><span class="line">2:2345:respawn:&#x2F;sbin&#x2F;mingetty tty2</span><br><span class="line">3:2345:respawn:&#x2F;sbin&#x2F;mingetty tty3</span><br><span class="line">4:2345:respawn:&#x2F;sbin&#x2F;mingetty tty4</span><br><span class="line">5:2345:respawn:&#x2F;sbin&#x2F;mingetty tty5</span><br><span class="line">6:2345:respawn:&#x2F;sbin&#x2F;mingetty tty6</span><br></pre></td></tr></table></figure>
<p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p>
<p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p>
<h1 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h1><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>（1）命令行登录</li>
<li>（2）ssh登录</li>
<li>（3）图形界面登录</li>
</ul>
<p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p>
<p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p>
<p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p>
<p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p>
<p>这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p>
<p>/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p>
<h2 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p>
<p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p>
<p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p>
<p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p>
<p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space +（ F1-F6）. </p>
<p>如果你在图形界面下请按Alt + Shift + Ctrl + （F1-F6） 切换至命令窗口。</p>
<h1 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机"></a>Linux 关机</h1><p>在linux领域内<strong>大多用在服务器上，很少遇到关机的操作</strong>。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p>
<p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure>
<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p><strong>[Tab] 有『命令补全』与『文件补齐』的功能</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Tab]      ## 接在一串指令的第一个字的后面，则为『命令补全』</span><br><span class="line">[Tab]      ## 接在一串指令的第二个字以后时，则为『文件补齐』</span><br></pre></td></tr></table></figure>
<p>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</p>
<p><strong>[Ctrl]+ C 如果在Linux 底下输入了错误的指令或参数，想让当前的程序『停掉』的话，可以输入：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Ctrl] + c </span><br></pre></td></tr></table></figure>
<p><strong>[Ctrl]-d 『键盘输入结束(End Of File, EOF 或 End Of Input)』的意思</strong></p>
<p>另外，他也可以用来取代 exit 的输入。</p>
<p>例如你想要直接离开文字接口，可以直接按下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Ctrl] + d   ## 相当于输入 exit</span><br></pre></td></tr></table></figure>
<p><strong>[shift]+{[PageUP]|[Page Down]}</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Shift]+[Page Up]    ## 往前翻页 </span><br><span class="line"></span><br><span class="line">[Shift]+[Page Down] ## 往后翻页</span><br></pre></td></tr></table></figure>
<p>shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shutdown -p now  ### 关闭机器</span><br><span class="line"># shutdown -H now  ### 停止机器      </span><br><span class="line"># shutdown -r 09:35 ### 在 09:35am 重启机器</span><br></pre></td></tr></table></figure>
<p>要取消即将进行的关机，只要输入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># shutdown -c</span><br></pre></td></tr></table></figure>
<p>halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># halt             ### 停止机器</span><br><span class="line"># halt -p          ### 关闭机器、关闭电源</span><br><span class="line"># halt --reboot    ### 重启机器</span><br></pre></td></tr></table></figure>
<p>poweroff 会发送一个 ACPI 信号来通知系统关机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># poweroff           ### 关闭机器、关闭电源</span><br><span class="line"># poweroff --halt    ### 停止机器</span><br><span class="line"># poweroff --reboot  ### 重启机器</span><br></pre></td></tr></table></figure>
<p>reboot 命令 reboot 通知系统重启。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># reboot           ### 重启机器</span><br><span class="line"># reboot --halt    ### 停止机器</span><br><span class="line"># reboot -p        ### 关闭机器</span><br></pre></td></tr></table></figure>


<h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F; </span><br></pre></td></tr></table></figure>
<p>可显示当前层的目录。</p>
<p><img src="/2021/01/26/Linux%E5%AD%A6%E4%B9%A0-1/pic-1.png" alt="树状目录结构图"></p>
<p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用 <strong>/</strong> 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。</p>
<p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <strong>.</strong> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 <strong>..</strong> 来表示。</p>
<ul>
<li> . ：代表当前的目录，也可以使用 ./ 来表示；</li>
<li> .. ：代表上一层目录，也可以 ../ 来代表。</li>
</ul>
<p>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p>
<h2 id="1-系统启动必须："><a href="#1-系统启动必须：" class="headerlink" title="1.系统启动必须："></a><strong>1.系统启动必须：</strong></h2><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p>
<p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p>
<p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
<p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>
<h2 id="2-指令集合："><a href="#2-指令集合：" class="headerlink" title="2.指令集合："></a><strong>2.指令集合：</strong></h2><p><strong>/bin：</strong>存放着最常用的程序和指令</p>
<p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p>
<h2 id="3-外部文件管理："><a href="#3-外部文件管理：" class="headerlink" title="3.外部文件管理："></a><strong>3.外部文件管理：</strong></h2><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p>
<p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p>
<p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p>
<h2 id="4-临时文件："><a href="#4-临时文件：" class="headerlink" title="4.临时文件："></a><strong>4.临时文件：</strong></h2><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
<p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p>
<p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p>
<h2 id="5-账户："><a href="#5-账户：" class="headerlink" title="5.账户："></a><strong>5.账户：</strong></h2><p><strong>/root</strong>：系统管理员的用户主目录。</p>
<p><strong>/home</strong>：用户的主目录，以用户的账号命名的。</p>
<p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p>
<p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p>
<p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p>
<p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p>
<h2 id="6-运行过程中要用："><a href="#6-运行过程中要用：" class="headerlink" title="6.运行过程中要用："></a><strong>6.运行过程中要用：</strong></h2><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p>
<p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p>
<h2 id="7-扩展用的："><a href="#7-扩展用的：" class="headerlink" title="7.扩展用的："></a><strong>7.扩展用的：</strong></h2><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p>
<p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p>
<h2 id="8-其他："><a href="#8-其他：" class="headerlink" title="8.其他："></a>8.其他：</h2><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
<p><strong>/selinux：</strong><br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
<h4 id="在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"><a href="#在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。" class="headerlink" title="在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"></a>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</h4><p><strong>/etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>
<p><strong>/bin, /sbin, /usr/bin, /usr/sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p>
<p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p>
<p><strong>/var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p>
]]></content>
      <categories>
        <category>课外拓展</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基础命令行</title>
    <url>/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="hexo的基础命令行："><a href="#hexo的基础命令行：" class="headerlink" title="hexo的基础命令行："></a>hexo的基础命令行：</h1><h2 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<ul>
<li>启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></li>
<li><code>hexo s</code> 是 <code>hexo server</code> 的缩写，命令效果一致。</li>
<li>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可。</li>
<li>对 Hexo 根目录 <code>_config.yml</code> 的修改，需要重启本地服务器后才能预览效果。</li>
<li>预览草稿文章 <code>hexo s --drafts</code></li>
</ul>
<h2 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;title&quot;</span></span><br><span class="line">hexo <span class="keyword">new</span>  draft <span class="string">&quot;草稿文章&quot;</span></span><br><span class="line">hexo <span class="keyword">new</span> page</span><br></pre></td></tr></table></figure>
<ul>
<li>新建一个title.md博客文章</li>
<li>draft 为草稿文档，不会展现在博客上，可用<code>hexo publish &quot;草稿文章&quot;</code> 发布成正式文章</li>
<li><code>hexo new page</code> 创建一个文件夹</li>
</ul>
<h2 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<ul>
<li>自动生成网站静态文件，并部署到设定的仓库。</li>
<li><code>hexo d</code> 是 <code>hexo deploy</code> 的缩写，命令效果一致。</li>
</ul>
<h2 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<ul>
<li>清除缓存文件 db.json 和已生成的静态文件 public 。</li>
<li>网站显示异常时可以执行这条命令试试</li>
</ul>
<h2 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成网站静态文件到默认设置的 public 文件夹。</p>
<ul>
<li>便于查看网站生成的静态文件或者手动部署网站；</li>
<li>如果使用自动部署，不需要先执行该命令；</li>
<li><code>hexo g</code> 是 <code>hexo generate</code> 的缩写，命令效果一致。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<p>部署发布，命令可用&amp;&amp;连接</p>
<p>原创封面</p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/c++cover.jpg" alt="c++cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/Linux-cover.jpg" alt="Linux-cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80cover-1.jpg" alt="网页基础cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80cover-2.jpg" alt="网页基础cover-2"><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E6%9C%AA%E5%88%86%E7%B1%BBcover.jpg" alt="未分类cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E7%BA%BF%E6%80%A7%E8%A1%A8cover.jpg" alt="线性表cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E7%BA%BF%E6%80%A7%E8%A1%A8cover-2.jpg" alt="线性表cover-2"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E8%99%9A%E5%B9%BBcover.jpg" alt="虚幻cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/Java-cover.jpg" alt="Java-cover"></p>
<p><img src="/2021/01/17/hexo%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E8%A1%8C/%E5%BD%AC%E5%BD%AC%E5%89%8D%E8%BE%88cover.jpg" alt="彬彬前辈cover"></p>
]]></content>
      <categories>
        <category>其他内容</category>
        <category>hexo使用</category>
      </categories>
      <tags>
        <tag>hexo使用</tag>
      </tags>
  </entry>
</search>
