<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-22T10:26:21.978Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zweiwings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网页设计学习-3</title>
    <link href="http://example.com/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://example.com/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-04-22T07:00:56.000Z</published>
    <updated>2021-04-22T10:26:21.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="css格式定义"><a href="#css格式定义" class="headerlink" title="css格式定义"></a>css格式定义</h3><pre><code>选择器类型&#123;    属性1:值;    属性2:值;    …………&#125;</code></pre><h3 id="head部分插入"><a href="#head部分插入" class="headerlink" title="head部分插入"></a>head部分插入</h3><pre><code class="html">方法1：&lt;link href=&quot;相对地址&quot; type=&quot;text/css&quot; rel=&quot;stylesheeet&quot;&gt;方法2：&lt;style type=&quot;text/css&quot;&gt;        @import url(&quot;相对地址&quot;);      &lt;/style&gt;</code></pre><p>注：也可以在当前网页内以css的方式写入本网页的样式，但是该样式仅作用于该网页，而且夹杂于内容中，故不推荐使用</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器：p、hn等标签"><a href="#标签选择器：p、hn等标签" class="headerlink" title="标签选择器：p、hn等标签"></a>标签选择器：p、hn等标签</h3><p>代表该标签的共性，用css修改时，将会作用于当前网页所有该标签</p><p>调用方式：直接使用定义的标签</p><p>选择器类型：指定的标签名字</p><h3 id="类选择器：以-开头"><a href="#类选择器：以-开头" class="headerlink" title="类选择器：以.开头"></a>类选择器：以.开头</h3><p>把相同类型的元素分类定义成不同的样式，用css修改时，将改变这一类的所有元素样式</p><p>调用方式：class=”类选择器的名字”（多个效果可用空格隔开）</p><p>选择器类型：.类选择器名</p><p><strong>注意：</strong></p><ul><li>不要试图用一个类名，把某个标签的所有样式写完，一个标签应该多携带几个类</li><li>每个类要尽可能的小，以达到公共性</li></ul><h3 id="id选择器：以-开头"><a href="#id选择器：以-开头" class="headerlink" title="id选择器：以#开头"></a>id选择器：以#开头</h3><p>代表某一元素的个性，用css修改时，只改变当前元素的样式</p><p>调用方式：id=”id选择器的名字”</p><p>选择器类型：#id选择器的名字</p><p>注：id选择器在文档中只能使用一次，而类选择器可以使用多次</p><h3 id="通配符选择器：“-”"><a href="#通配符选择器：“-”" class="headerlink" title="通配符选择器：“*”"></a>通配符选择器：“*”</h3><p>作用于所有的标签样式，用css修改时会改变所有使用该css的网页样式</p><p>使用方式：不需要调用，在css文件链接时直接附加</p><h3 id="并集选择器：“，”"><a href="#并集选择器：“，”" class="headerlink" title="并集选择器：“，”"></a>并集选择器：“，”</h3><p>表达“或”的含义，部分样式相同或完全相同时使用</p><p>使用方式：在选择器名处使用【如：（h1，h3）】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS操作&quot;&gt;&lt;a href=&quot;#CSS操作&quot; class=&quot;headerlink&quot; title=&quot;CSS操作&quot;&gt;&lt;/a&gt;CSS操作&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计学习" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-5</title>
    <link href="http://example.com/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/"/>
    <id>http://example.com/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/</id>
    <published>2021-04-16T13:07:44.000Z</published>
    <updated>2021-04-20T12:51:58.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚幻文件夹结构"><a href="#虚幻文件夹结构" class="headerlink" title="虚幻文件夹结构"></a>虚幻文件夹结构</h1><h2 id="本地工程文件夹"><a href="#本地工程文件夹" class="headerlink" title="本地工程文件夹"></a>本地工程文件夹</h2><p>惯例为【Config】、【Content】、【DerivedDataCache】、【Intermediate】、【Saved】、【Script】六个文件夹，和一个后缀名为.uproject的文件（该文件为工程本体，在引擎中打开工程使用该文件）</p><h3 id="【Config】"><a href="#【Config】" class="headerlink" title="【Config】"></a>【Config】</h3><h3 id="【Content】"><a href="#【Content】" class="headerlink" title="【Content】"></a>【Content】</h3><h3 id="【DerivedDataCache】"><a href="#【DerivedDataCache】" class="headerlink" title="【DerivedDataCache】"></a>【DerivedDataCache】</h3><h3 id="【Intermediate】"><a href="#【Intermediate】" class="headerlink" title="【Intermediate】"></a>【Intermediate】</h3><h3 id="【Saved】"><a href="#【Saved】" class="headerlink" title="【Saved】"></a>【Saved】</h3><h3 id="【Script】"><a href="#【Script】" class="headerlink" title="【Script】"></a>【Script】</h3><h2 id="导入素材文件夹"><a href="#导入素材文件夹" class="headerlink" title="导入素材文件夹"></a>导入素材文件夹</h2><p>惯例为【Animations】、【Materials】、【Meshes】、【Map（Scenes）】、【Textures】五个文件夹，有时也有会将【Materials】、【Textures】、【Meshes】放在一个【character】文件夹下的构成</p><h3 id="【Animations】"><a href="#【Animations】" class="headerlink" title="【Animations】"></a>【Animations】</h3><p>【Animations】为该素材包内包括的动画序列，根据固定的骨骼执行，执行动画的网格体可以替换预览并实际替换使用</p><h3 id="【Materials】"><a href="#【Materials】" class="headerlink" title="【Materials】"></a>【Materials】</h3><p>【Materials】为该素材包内所用到的所有材质，一般通过【材质】蓝图修改或直接使用</p><h3 id="【Meshes】"><a href="#【Meshes】" class="headerlink" title="【Meshes】"></a>【Meshes】</h3><p>【Meshes】为该素材包内用到的所有骨架模型（骨骼网格体）、物理模型（物理资产）、骨骼，骨架模型是没有碰撞体积的，而物理模型能够表现受力（例如场景中运行时会受重力，和玩家角色重叠时会发生移动）</p><h3 id="【Map（scenes）】"><a href="#【Map（scenes）】" class="headerlink" title="【Map（scenes）】"></a>【Map（scenes）】</h3><p>【Map（Scenes）】为该素材包的场景地图，一般会有一个Overview场景，用于预览所有模型，动画，地形等该素材包的素材</p><h3 id="【Textures】"><a href="#【Textures】" class="headerlink" title="【Textures】"></a>【Textures】</h3><p>【Textures】为该素材包的所有贴图，包括材质贴图，法线贴图，场景贴花等，通常在【材质】蓝图中找到需要更改的属性，再对应的更改贴图以达到更改材质的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚幻文件夹结构&quot;&gt;&lt;a href=&quot;#虚幻文件夹结构&quot; class=&quot;headerlink&quot; title=&quot;虚幻文件夹结构&quot;&gt;&lt;/a&gt;虚幻文件夹结构&lt;/h1&gt;&lt;h2 id=&quot;本地工程文件夹&quot;&gt;&lt;a href=&quot;#本地工程文件夹&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-1</title>
    <link href="http://example.com/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://example.com/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-04-16T11:55:41.000Z</published>
    <updated>2021-04-16T12:50:31.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.下载并安装jdk，jre，建议放置同一文件夹下</p><p>2.计算机-右键菜单-左侧高级系统设置-环境变量中，在下方系统变量内创建</p><p>JAVA_HOME——填写jdk文件夹内部绝对路径（如：D:/Java/Jdk）</p><p>CLASSPATH——填写下列内容（注：不能忘记开头的点和每个目录和目录下文件名后的分号）</p><pre><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></pre><p>找到系统变量的Path——新建以下内容（这里末尾没有分号）</p><pre><code>%JAVA_HOME%\bin</code></pre><p>以上Java环境变量配置完成，在cmd中输入java和javac出现对应命令使用方法说明则配置成功</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感：Java和c#一样区分大小写，使用时必须确保大小写完全一致</li><li>类名：类名首字母应该大写，由多个单词组成时，每个单词首字母大写</li><li>方法名：方法名以小写字母开头，由多个单词组成时，后面的每个单词首字母大写</li><li>源文件名：源文件名必须和类名相同，文件名后缀为.java</li><li>主方法入口:（类似c#中的main函数）程序由<strong>public static void main(String[] args)</strong> 开始执行</li><li>注释：可使用//和/**/进行单行注释和多行注释</li></ul><h2 id="标识符定义与修饰符"><a href="#标识符定义与修饰符" class="headerlink" title="标识符定义与修饰符"></a>标识符定义与修饰符</h2><h3 id="标识符定义"><a href="#标识符定义" class="headerlink" title="标识符定义"></a>标识符定义</h3><p>【包含类名、变量名以及方法名】</p><ul><li>应以字母，$，或下划线开头，字符组合也只能在前三种的基础上添加数字</li><li>关键字不能用作标识符，且标识符区分大小写</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table><thead><tr><th align="left">类别</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left">class</td><td align="left">类</td></tr><tr><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">super</td><td align="left">父类，超类</td></tr><tr><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">null</td><td align="left">空</td></tr></tbody></table><h2 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h2><pre><code class="java">public class HelloWorld &#123;    /* 第一个Java程序     * 它将输出字符串 Hello World     */    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;); // 输出 Hello World    &#125;&#125;</code></pre><p>以上程序的文件名必须为HelloWorld，与类名相同</p><p>在cmd中进入目标文件所在位置，并输入javac HelloWorld.java，即可编译得到同目录下后缀名为.class的同名文件，再输入java HelloWorld（这里没有后缀名），即可运行该程序</p><p>对以上Hello World的入口说明（即方法/函数创建）：</p><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296">https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门教程&quot;&gt;&lt;a href=&quot;#入门教程&quot; class=&quot;headerlink&quot; title=&quot;入门教程&quot;&gt;&lt;/a&gt;入门教程&lt;/h1&gt;&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java学习" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-4</title>
    <link href="http://example.com/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/"/>
    <id>http://example.com/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/</id>
    <published>2021-04-15T13:07:44.000Z</published>
    <updated>2021-04-23T12:57:16.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI智能"><a href="#AI智能" class="headerlink" title="AI智能"></a>AI智能</h1><h2 id="寻路导航创建"><a href="#寻路导航创建" class="headerlink" title="寻路导航创建"></a>寻路导航创建</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在主面板左上角的“放置actor”面板中找到“导航网格体边界体积”，放入场景中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/1.png" alt="1"></p><p>调整体积大小，将需要建构导航的场景放入该体积</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/2.png" alt="2"></p><p>点击后生成类似如图的绿色地面区域，这片区域为AI导航有效的区域</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/3.png" alt="3"></p><h3 id="实例：实现敌对NPC追踪角色移动"><a href="#实例：实现敌对NPC追踪角色移动" class="headerlink" title="实例：实现敌对NPC追踪角色移动"></a>实例：实现敌对NPC追踪角色移动</h3><p>思路：使用AI控制器沿创建好的导航移动敌对NPC，目标为玩家控制的角色，并循环操作</p><p>关卡蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/8.png" alt="8"></p><p>敌对NPC角色蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/4.png" alt="4"></p><p>（AI未完待续）</p><h1 id="动画序列与蓝图"><a href="#动画序列与蓝图" class="headerlink" title="动画序列与蓝图"></a>动画序列与蓝图</h1><h2 id="过场动画制作"><a href="#过场动画制作" class="headerlink" title="过场动画制作"></a>过场动画制作</h2><p>创建一个过场动画的关卡序列，命名并打开操作界面</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/9.png" alt="9"></p><p>新建一个相机剪切轨道，并且绑定用于拍摄过场动画的电影摄像机actor（或是直接在场景中选中指定相机，通过actor到sequencer直接添加），将相机移动到起始位置，添加变换轨道（或其他轨道）并在起始位置添加关键帧</p><p>制作动画时，其他actor也可添加移动轨道，详细在下一个子目录“动画轨道”中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/10.png" alt="10"></p><p>多次移动相机到指定位置，并在轨道上添加相应的关键帧（场景中能够看到相机移动的轨迹呈现），最后调整动画结束的准线，结束修改并保存</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/12.png" alt="12"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/11.png" alt="11"></p><p>当拍摄多个动画后，可将需要拼接的动画放入一个新的关卡序列中，上下移动调整轨道，左右移动调整播放顺序，并将结束准线对齐</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/13.png" alt="13"></p><p>渐变效果可通过添加渐变轨道完成，改变渐变轨道的值（1为全黑，0为透明）并建立多个关键帧</p><h2 id="动画轨道"><a href="#动画轨道" class="headerlink" title="动画轨道"></a>动画轨道</h2><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/14.png" alt="14"></p><p>Actor到Sequencer：创建一个控制actor的轨道，在场景中选中的actor会优先显示在顶端</p><p>添加文件夹：可为多个轨道分类，放置于不同的文件夹下（好像没什么用的样子）</p><p>音频轨道：可在动画播放同时添加音频资产的播放</p><p>事件轨道：分为触发器和中继器（后者不常用），触发器轨道中添加了关键帧后，右键新建末端可新建图表事件，当时间轴移动到指定位置执行该事件</p><p>相机剪切轨道：用于添加相机轨道，使用actor到sequencer添加时也会自动创建</p><p>镜头轨道：用于拼接多个镜头的轨道，也可以实现多个动画序列之间的拼接</p><h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p>打开某个骨骼/网格体/动画序列/物理模型时，可在右上角看到动画蓝图标识</p><p><strong><em>【注：此处以第三人称游戏模板的小白人为例】</em></strong></p><p>打开默认的动画图表【AnimGraph】，找到默认状态机，双击打开</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/5.png" alt="5"></p><p>状态机内部蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-1.png" alt="6-1"></p><p>Entry为一个输入/起始点，Idle/Run节点为走或跑时，JumpStart、Loop、End分别为跳跃的开始，腾空，落地过程，四个节点分别播放不同的动画，双箭头为四个节点互相切换的条件（右键添加状态可添加节点，通过节点引线引出的新节点与原节点之间自带转换条件）</p><p>Idle/Run节点内部：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-2.png" alt="6-2"></p><p>此处混合空间播放器节点下方为一段动画，具有三个白色关键帧（第一个与绿色关键帧重合），由绿色关键帧的位置（speed的大小）决定播放的动画，而在动画播放时，绿色关键帧如果未到达下一个白色关键帧，将循环播放上一个白色关键帧的动画</p><p>JumpStart、Loop、End节点内部：</p><p><strong><em>【注：因为结构相同故而使用JumpStart作为范例】</em></strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-3.png" alt="6-3"></p><p>由Idle/Run节点到JumpStart与从JumpLoop到JumpEnd节点的切换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-5.png" alt="6-5"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-6.png" alt="6-6"></p><p>前者：判断角色是否在空中，如果是，转换到下一个节点（即JumpStart节点）</p><p>后者：判断角色是否不在空中，如果是，转换到下一个节点（即JumpEnd节点）</p><p>由JumpStart到JumpLoop与由JumpEnd到Idle/Run节点的转换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-4.png" alt="6-4"></p><p>判断前一个节点（JumpStart或JumpEnd）中动画资产播放的剩余时间是否小于0.1，如果是，则转换到下一个节点（JumpLoop或Idle/Run）</p><p>动画蓝图事件图表：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/7.png" alt="7"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI智能&quot;&gt;&lt;a href=&quot;#AI智能&quot; class=&quot;headerlink&quot; title=&quot;AI智能&quot;&gt;&lt;/a&gt;AI智能&lt;/h1&gt;&lt;h2 id=&quot;寻路导航创建&quot;&gt;&lt;a href=&quot;#寻路导航创建&quot; class=&quot;headerlink&quot; title=&quot;寻路导航创</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-4</title>
    <link href="http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/"/>
    <id>http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</id>
    <published>2021-04-14T12:10:46.000Z</published>
    <updated>2021-04-23T12:06:46.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code>typedef struct &#123;    Elemtype *base;                //储存空间的基址指针    int front;                    //定义一个头指针    int rear;                    //定义一个尾指针&#125;SQqueue;</code></pre><p><strong>注：此处front和rear指针仅仅设为了int类型，而并非真正的指针类型，所表述的是队头队尾元素所在的位置下标</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code>bool initqueue(SQqueue &amp;sq)&#123;    sq.base=new Elemtype[MAXSIZE];            //为队列分配空间    if(!sq.base) return false;                //没能分配成功，返回失败    sq.front=sq.rear=0;                        //头尾指针置为零，队列为空    return true;&#125;</code></pre><h2 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h2><pre><code>int queuelength(SQqueue &amp;sq)&#123;    return (sq.rear-sq.front+MAXSIZE)%MAXSIZE;&#125;</code></pre><p>注：在没有特殊注明的情况下，所说队列都为循环队列，front指向队头元素，rear指向队尾元素的后一个元素，为区分队空与队满，此处少用一个元素空间，即队列空间大小为m-1个元素时队满，故而当队列满足“rear=front“时队空，当队列满足”(rear+1)%MAXSIZE=front“时队满。</p><h2 id="入队（从队尾插入）"><a href="#入队（从队尾插入）" class="headerlink" title="入队（从队尾插入）"></a>入队（从队尾插入）</h2><pre><code>bool enterqueue(SQqueue &amp;sq,Elemtype e)          //传址需要操作的表，传值入队元素&#123;    if((sq.rear+1)%MAXSIZE==sq.front) return false;    //判断队满时返回失败    sq.base[sq.rear]=e;                     //让队尾元素的后一个元素等于e    sq.rear=(sq.rear+1)%MAXSIZE;         //队尾指针后移    return true；                        //返回成功入队&#125;</code></pre><h2 id="出队（从队头删除）"><a href="#出队（从队头删除）" class="headerlink" title="出队（从队头删除）"></a>出队（从队头删除）</h2><pre><code>bool deletequeue(SQqueue &amp;sq,Elemtype &amp;e)&#123;    if(sq.front==sq.rear) return false;        //若队空，则返回出队失败    e=sq.base[sq.front];                    //用e获得出队的队头元素    sq.front=(sq.front+1)%MAXSIZE;            //队头指针后移    return true;                            //返回成功出队&#125;</code></pre><h2 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h2><pre><code>Elemtype gethead(SQqueue &amp;sq)//仅返回表的队头元素，不修改头指针&#123;    if(sq.front!=sq.rear)             //判断队列非空    return     sq.base[sq.front];        //返回队头元素&#125;</code></pre><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-4-队列操作-20-分"><a href="#R7-4-队列操作-20-分" class="headerlink" title="R7-4 队列操作 (20 分)"></a>R7-4 队列操作 (20 分)</h2><p>请实现一个MyQueue类，实现出队，入队，求队列长度.</p><p>实现入队函数 void push(int x); 实现出队函数 int pop(); 实现求队列长度函数 int size();</p><p>输入格式:<br>每个输入包含1个测试用例。每个测试用例第一行给出一个正整数 n (n &lt;= 10^6) ，接下去n行每行一个数字，表示一种操作： 1 x ： 表示从队尾插入x，0&lt;=x&lt;=2^31-1。 2 ： 表示队首元素出队。 3 ： 表示求队列长度。</p><p>输出格式:<br>对于操作2,若队列为空，则输出 “Invalid”,否则请输出队首元素。 对于操作3，请输出队列长度。 每个输出项最后换行。</p><p>输入样例:</p><pre><code>5321 10032</code></pre><p>输出样例:</p><pre><code>0Invalid1100</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *base;    int front;    int rear;&#125;SQueue;bool init(SQueue &amp;sq)&#123;    sq.base=new int[50];    if(!sq.base) return false;    sq.front=0;    sq.rear=0;    return true;&#125;int length(SQueue &amp;sq)&#123;    return (sq.rear-sq.front+50)%50;&#125;bool enter(SQueue &amp;sq,int a)&#123;    if((sq.rear+1)%50==sq.front) return false;    sq.base[sq.rear]=a;    sq.rear=(sq.rear+1)%50;    return true;&#125;bool out(SQueue &amp;sq,int &amp;a)&#123;    if(sq.front==sq.rear) return false;    a=sq.base[sq.front];    sq.front=(sq.front+1)%50;    return true;&#125;int main()&#123;    SQueue L;    init(L);    int n,i,j,k;    cin&gt;&gt;n;    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;j;        switch(j)        &#123;            case 1:                cin&gt;&gt;k;                enter(L,k);                break;            case 2:                if(out(L,k)) cout&lt;&lt;k&lt;&lt;endl;                else cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;                break;            case 3:                cout&lt;&lt;length(L)&lt;&lt;endl;                break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;顺序队列&quot;&gt;&lt;a href=&quot;#顺序队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列&quot;&gt;&lt;/a&gt;顺序队列&lt;/h1&gt;&lt;p&gt;队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-3</title>
    <link href="http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/"/>
    <id>http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</id>
    <published>2021-04-14T07:37:35.000Z</published>
    <updated>2021-04-23T11:23:20.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>【Elemtype为数据类型】</p><p>顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相较普通顺序表简单。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="c++">typedef struct &#123;    Elemtype *base;                    //定义栈底指针    Elemtype *top;                    //定义栈顶指针    int maxsize;                    //定义最大栈的最大容量&#125;SQstack;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="c++">bool initstack(SQstack &amp;sq)            //传址需要初始化的表&#123;    sq.base=new Elemtype[MAXSIZE];    //分配大小为MAXSIZE的空间，并返回首地址给表的栈底指针    if(!sq.base) return false;      //若分配失败则返回    sq.top=sq.base;                    //栈顶指针等于栈底指针，表示空栈    sq.maxsize=MAXSIZE;                //记录栈的最大容量为MAXSIZE    return true;                    //返回创建成功&#125;</code></pre><h2 id="入栈（从栈顶插入）"><a href="#入栈（从栈顶插入）" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><pre><code class="c++">bool Push(SQstack &amp;sq,Elemtype e)        //传址需要操作的栈，传值需要入栈的值&#123;    if(sq.top-sq.base&gt;=sq.maxsize) return false;    //若栈顶指针与栈底指针的差为最大空间（即栈满），返回入栈失败    *sq.top=e;    //栈顶指针总是指在栈顶元素的下一个位置，故而直接赋值    sq.top++;                            //栈顶指针后移    return true;                        //返回入栈成功&#125;</code></pre><h2 id="出栈（从栈顶删除）"><a href="#出栈（从栈顶删除）" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><pre><code class="c++">bool Pop(SQstack &amp;sq,Elemtype &amp;e)            //传址需要操作的表和出栈的元素&#123;    if(sq.top==sq.base) return false;    //若栈顶指针与栈底指针相同（即栈空），则返回失败    sq.top--;    //栈顶指针总是指在栈顶元素的下一个位置，故而栈顶指针后移    e=*sq.top;                                //将出栈的元素传给e    return true;&#125;</code></pre><h2 id="取栈顶（取值）"><a href="#取栈顶（取值）" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><pre><code class="c++">Elemtype gettop(SQstack &amp;sq)//传址需要操作的表，返回栈顶元素，该操作只取栈顶，不修改栈顶指针&#123;    if(sq.top!=sq.base)            //若该栈非空    &#123;    return *(sq.top-1);            //取栈顶指针的前一个位置，即栈顶元素向外传递    &#125;&#125;</code></pre><h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>【Elemtype为数据类型】</p><p>在无法估计栈数据量时，通常采用链式栈，而且因为栈的主要操作是插入和删除，所以用链表的头部作栈顶更加方便。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><pre><code class="c++">typedef struct Lnode&#123;    Elemtype data;            //定义链表结点的数据域    struct Lnode *next;        //定义指向下一节点的指针域&#125;*Linkstack;</code></pre><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="c++">bool initstack(Linkstack &amp;ls)&#123;    ls=NULL;    //由于栈不需要对栈顶以外的元素操作，故而不需要设置头结点来使表头操作与表中表尾一致    return true;            //返回初始化成功&#125;</code></pre><h2 id="入栈（从栈顶插入）-1"><a href="#入栈（从栈顶插入）-1" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><pre><code class="c++">bool Push(Linkstack &amp;ls,Elemtype e)        //传址需要操作的表，传值需要插入的元素&#123;    Lnode *p;    p=new Lnode;                //重新分配一个结点空间，首地址赋给p    p-&gt;data=e;                    //新结点的数据域为e    p-&gt;next=ls;                    //新结点的指针域指向头指针ls，即将新结点作头插    ls=p;                        //头指针前移    return true;                //返回入栈成功&#125;</code></pre><h2 id="出栈（从栈顶删除）-1"><a href="#出栈（从栈顶删除）-1" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><pre><code class="c++">bool Pop(Linkstack &amp;ls，Elemtype &amp;e)   //传址需要操作的表和出栈的元素&#123;    if(ls==NULL) return false;        //栈空则返回删除失败    e=ls-&gt;data;                        //e接收出栈元素    Lnode *p=ls;                    //定义一个p指针指向原栈顶元素    ls=ls-&gt;next;                    //让头指针后移    delete p;                        //删除p指向的结点    return true;                    //返回删除完成&#125;</code></pre><h2 id="取栈顶（取值）-1"><a href="#取栈顶（取值）-1" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><pre><code class="c++">Elemtype gettop(Linkstack &amp;ls)    //传址需要操作的表&#123;    if(ls!=NULL)                //栈非空    return ls-&gt;data;            //返回栈顶元素的值，栈顶指针不变&#125;</code></pre><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-1-堆栈操作合法性-20-分"><a href="#R7-1-堆栈操作合法性-20-分" class="headerlink" title="R7-1 堆栈操作合法性 (20 分)"></a>R7-1 堆栈操作合法性 (20 分)</h2><p>假设以S和X分别表示入栈和出栈操作。如果根据一个仅由S和X构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入S和X序列，判断该序列是否合法。</p><p>输入格式:<br>输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由S和X构成的序列。序列保证不为空，且长度不超过100。</p><p>输出格式:<br>对每个序列，在一行中输出YES如果该序列是合法的堆栈操作序列，或NO如果不是。</p><p>输入样例：</p><pre><code>4 10SSSXXSXXSXSSSXXSXXSSSSSSSSSSSXSSXXXXXXXXXXXSSSXXSXXX</code></pre><p>输出样例：</p><pre><code class="：">YESNONONO</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct&#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq,int m)&#123;    sq.base=new char[m];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=m;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return false;    sq.top--;    return true;&#125;bool push(SQstack &amp;sq,char e)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=e;    sq.top++;    return true;&#125;int main()&#123;    int n,m,i,j=0;    bool flag=true;    cin&gt;&gt;n&gt;&gt;m;    string str;    SQstack L;    for(i=0;i&lt;n;i++)    &#123;        init(L,m);        cin&gt;&gt;str;        flag=true;        for(j=0;str[j]!=&#39;\0&#39;;j++)        &#123;            if(str[j]==&#39;S&#39;)             &#123;                flag=push(L,str[j]);            &#125;            if(str[j]==&#39;X&#39;)             &#123;                flag=pop(L);            &#125;        &#125;    if(L.base==L.top&amp;&amp;flag==true) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="R7-2-回文判断-20-分"><a href="#R7-2-回文判断-20-分" class="headerlink" title="R7-2 回文判断 (20 分)"></a>R7-2 回文判断 (20 分)</h2><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p><p>输入格式:<br>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p><p>输出格式:<br>若字符序列是回文，输出“YES”；否则，输出“NO”。</p><p>输入样例:</p><pre><code>abdba</code></pre><p>输出样例:</p><pre><code>YES</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct &#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq)&#123;    sq.base=new char[20];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=20;    return true;&#125;bool push(SQstack &amp;sq,char a)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=a;    sq.top++;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return false;    sq.top--;    return true;&#125;bool gettop(SQstack &amp;sq,int &amp;a)&#123;    if(sq.base==sq.top) return false;    a=*(sq.top-1);    return true;&#125;int main()&#123;    SQstack L;    init(L);    string str;    int i,n=0,a;    bool flag=true;    cin&gt;&gt;str;    n=str.size();    if(n%2==0)    &#123;        for(i=0;i&lt;n;i++)        &#123;            if(i&lt;n/2) push(L,str[i]);            else             &#123;                gettop(L,a);                if(str[i]==a) pop(L);                else                 &#123;                    flag=false;                    break;                &#125;            &#125;        &#125;    &#125;    else    &#123;        for(i=0;i&lt;n;i++)        &#123;            if(i==(n-1)/2);            else             &#123;                if(i&lt;(n-1)/2) push(L,str[i]);                else                 &#123;                    gettop(L,a);                    if(str[i]==a) pop(L);                    else                     &#123;                        flag=false;                        break;                    &#125;               &#125;        &#125;    &#125;    &#125;            if(flag==true) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125;</code></pre><h2 id="R7-3-括号匹配-20-分"><a href="#R7-3-括号匹配-20-分" class="headerlink" title="R7-3 括号匹配 (20 分)"></a>R7-3 括号匹配 (20 分)</h2><p>检查一段C语言代码的小括号( )、 中括号 [ ] 和大括号{ } 是否匹配。</p><p>输入格式:<br>在一行中输入一段C语言代码，长度不超过1000个字符（行末以换行符结束）。</p><p>输出格式:<br>第一行输出左括号的数量和右括号的数量，中间以一个空格间隔。<br>若括号是匹配的，在第二行打印YES，否则打印NO。</p><p>输入样例1:</p><pre><code>for(int i=0; i&lt;v; i++)&#123; visited[i] = 0; for(int j=0; j&lt;v; j++) scanf(&quot;%d&quot;,&amp;(g-&gt;Adj[i][j])); &#125;</code></pre><p>输出样例1:</p><pre><code>8 8YES</code></pre><p>输入样例2:</p><pre><code>for(int i=0; i&lt;v; i++) a(i]=0;</code></pre><p>输出样例2:</p><pre><code>2 2NO</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct&#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq)&#123;    sq.base=new char[500];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=500;    return true;&#125;bool push(SQstack &amp;sq,char a)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=a;    sq.top++;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return true;    sq.top--;    return true;&#125;bool gettop(SQstack &amp;sq,char &amp;a)&#123;    if(sq.top==sq.base) return false;    a=*(sq.top-1);    return true;&#125;int main()&#123;    SQstack L;    init(L);    char a=&#39;1&#39;;    bool flag=true;    int i,left=0,right=0,k=0;    char str[500];    for(i=0;i&lt;500;i++)    &#123;        cin&gt;&gt;str[i];        k++;    &#125;    for(i=0;i&lt;k;i++)    &#123;        if(str[i]==&#39;(&#39;||str[i]==&#39;[&#39;||str[i]==&#39;&#123;&#39;)        &#123;            left++;            push(L,str[i]);        &#125;        else        &#123;        if(str[i]==&#39;)&#39;||str[i]==&#39;]&#39;||str[i]==&#39;&#125;&#39;)        &#123;            right++;            gettop(L,a);            if((str[i]==&#39;)&#39;&amp;&amp;a==&#39;(&#39;)||(str[i]==&#39;]&#39;&amp;&amp;a==&#39;[&#39;)||(str[i]==&#39;&#125;&#39;&amp;&amp;a==&#39;&#123;&#39;))            &#123;                pop(L);            &#125;            else flag=false;        &#125;        &#125;    &#125;    if(L.top!=L.base) flag=false;    if(left==0&amp;&amp;right==0) flag=true;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;    if(flag) cout&lt;&lt;&quot;YES&quot;;    else cout&lt;&lt;&quot;NO&quot;;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;p&gt;顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-3</title>
    <link href="http://example.com/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/"/>
    <id>http://example.com/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/</id>
    <published>2021-04-13T12:28:08.000Z</published>
    <updated>2021-04-20T14:43:07.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础功能实现"><a href="#基础功能实现" class="headerlink" title="基础功能实现"></a>基础功能实现</h1><h2 id="人物操作功能"><a href="#人物操作功能" class="headerlink" title="人物操作功能"></a>人物操作功能</h2><h3 id="疾跑"><a href="#疾跑" class="headerlink" title="疾跑"></a>疾跑</h3><p>思路:在按下对应键（暂定shift）时，更改人物行走最大速度</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/1.png" alt="1"></p><h3 id="射击（创建发射物）"><a href="#射击（创建发射物）" class="headerlink" title="射击（创建发射物）"></a>射击（创建发射物）</h3><p>思路：在按下对应键（暂定鼠标左键）时，生成一个发射物</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/2.png" alt="2"></p><h3 id="过肩视角"><a href="#过肩视角" class="headerlink" title="过肩视角"></a>过肩视角</h3><p>思路：在按下对应键时（暂定鼠标右键），让视角缓缓变成过肩视角</p><p>玩家角色蓝图：（时间轴具体操作参考之前的节点介绍）</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/3.png" alt="3"></p><h3 id="★线检★"><a href="#★线检★" class="headerlink" title="★线检★"></a>★线检★</h3><p><strong><em>【注：案例的线检中“线”的长度为1000单位】</em></strong></p><p>思路：在actor正前方的创造一根不可见的线检测前方的物体，输出被检测到的物体，以便实现判断交互</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/4.png" alt="4"></p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p><strong><em>【注：案例中的”医疗包”为触碰即获得并消失，“门”为被线检到（最大距离为线的长度），并且按下F键时，实现“开门”，物体2为人物处于更小的范围或其他范围内，并按下F键时，实现拾取】</em></strong></p><p>思路：</p><ol><li>利用使用线检和类型转换判断物体属于什么类型，或判断开始重叠，然后执行对应的操作</li><li>在按下对应键时（暂定F键），判断可交互性，并判断线检检测到的物体，执行对应的自定义事件</li><li>在要交互的物体蓝图中设置其交互时执行的具体操作，即定义自定义事件</li></ol><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/5.png" alt="5"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/6.png" alt="6"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/9.png" alt="9"></p><p>“医疗包”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/10.png" alt="10"></p><p>“门”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/7.png" alt="7"></p><p>“物品2”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/8.png" alt="8"></p><h2 id="界面HUD"><a href="#界面HUD" class="headerlink" title="界面HUD"></a>界面HUD</h2><h3 id="显示HUD"><a href="#显示HUD" class="headerlink" title="显示HUD"></a>显示HUD</h3><p>思路：创建HUD控件之后，显示到视口</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/11.png" alt="11"></p><h3 id="显示交互按钮及其名称"><a href="#显示交互按钮及其名称" class="headerlink" title="显示交互按钮及其名称"></a>显示交互按钮及其名称</h3><p>指定/创建绑定函数：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/14.png" alt="14"></p><p><strong><em>（注：在文本、百分比、可视性等多个数据都可以使用函数绑定返回值来实现动态显示）</em></strong></p><p>思路：</p><ol><li>判断当前物体类型，按钮子项的文本函数返回不同的文本</li><li>判断当前物体是否为可交互物，可交互显示按钮，不可交互隐藏按钮</li></ol><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/12.png" alt="12"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/13.png" alt="13"></p><h3 id="显示角色血条"><a href="#显示角色血条" class="headerlink" title="显示角色血条"></a>显示角色血条</h3><p>思路：HUD中创建一个进度条，进度-百分比使用函数绑定，读取玩家角色的变量HP并返回</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/15.png" alt="15"></p><h3 id="制作标题及设置页面控件"><a href="#制作标题及设置页面控件" class="headerlink" title="制作标题及设置页面控件"></a>制作标题及设置页面控件</h3><p>标题页面控件：</p><ul><li><strong>事件构造时——“显示光标”，并”设置输入模式仅UI“</strong></li><li>开始——点击button时，执行“打开关卡”节点</li><li>退出——点击button时，执行“退出游戏”节点</li><li>设置——点击button时，创建“设置页面控件”，并“添加到视口”，将原来的标题控件“从父项中移除”</li></ul><p>设置页面控件：</p><p><strong><em>注：虚幻本身具有调节各种画质的设置，仅需要调用这套设置即可</em></strong></p><p>组合框设置初始显示值（显示当前抗锯齿与视图距离为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/17.png" alt="17"></p><p>组合框设置（后期处理质量设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/18.png" alt="18"></p><p>滑条操作（分辨率缩放设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/19.png" alt="19"></p><p>返回按钮：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/20.png" alt="20"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础功能实现&quot;&gt;&lt;a href=&quot;#基础功能实现&quot; class=&quot;headerlink&quot; title=&quot;基础功能实现&quot;&gt;&lt;/a&gt;基础功能实现&lt;/h1&gt;&lt;h2 id=&quot;人物操作功能&quot;&gt;&lt;a href=&quot;#人物操作功能&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页设计学习-2</title>
    <link href="http://example.com/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://example.com/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2021-04-13T05:51:17.000Z</published>
    <updated>2021-04-20T12:38:13.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表单结构"><a href="#表单结构" class="headerlink" title="表单结构"></a>表单结构</h1><p>表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介</p><h2 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h2><ul><li><h3 id="表单标签-form"><a href="#表单标签-form" class="headerlink" title="表单标签-form"></a>表单标签-form</h3><pre><code class="html">&lt;form action=&quot;url&quot; method=&quot;get/post&quot; name=&quot;value&quot;&gt;    填入表单域和表单按钮等&lt;/form&gt;</code></pre><p><strong>action：</strong>表示接受并处理表单数据的服务器程序的url地址</p><p><strong>method：get</strong>为默认，表单数据和URL一起发送，提交的数据显示在浏览器地址栏中，保密性差，有数据量限制；<strong>post</strong>保密性好，并且无数据量限制，表单数据和URL分开发送，保密性好</p><p><strong>name：</strong>指定表单名称，以区分一个页面中的多个表单</p></li></ul><ul><li><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单常用控件</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>预览</th></tr></thead><tbody><tr><td>input type=“date”</td><td>日期选择框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/8.png" alt="8"></td></tr><tr><td>input type=“text”</td><td>单行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/1.png" alt="1"></td></tr><tr><td>input type=“password”</td><td>密码输入框（输入的文字用*表示）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/2.png" alt="2"></td></tr><tr><td>input type=“radio”</td><td>单选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/3.png" alt="3"></td></tr><tr><td>input type=”checkbox“</td><td>复选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/7.png" alt="7"></td></tr><tr><td>input type=“hidden”</td><td>隐藏域（不显示，供开发使用）</td><td>——————————</td></tr><tr><td>input type=“file”</td><td>文件域（上传文件）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/4.png" alt="4"></td></tr><tr><td>select</td><td>列表框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/5.png" alt="5"></td></tr><tr><td>textarea</td><td>多行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-2/6.png" alt="6"></td></tr></tbody></table></li></ul><p>  <strong>表单域常用属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>控件名称（公共属性，与每个表单域对应）</td></tr><tr><td>type</td><td>控件类型，如radio，text等</td></tr><tr><td>size</td><td>指定控件的宽度</td></tr><tr><td>value</td><td>用于设定输入默认值（公共属性，可用来指定输入区域默认值）</td></tr><tr><td>maxlength</td><td>在单行文本时允许输入的最大字符数</td></tr><tr><td>src</td><td>插入图像的地址</td></tr></tbody></table><ul><li><h3 id="表单按钮"><a href="#表单按钮" class="headerlink" title="表单按钮"></a>表单按钮</h3><p><strong>普通按钮:触发提交表单的动作，配合JavaScript使用</strong></p><pre><code class="html">&lt;input type=&quot;button&quot; name=&quot;name值&quot;/&gt;</code></pre><p><strong>提交按钮：将表单中的信息提交给表单中action指向的文件</strong></p><pre><code class="html">&lt;input type=&quot;submit&quot; name=&quot;button_name&quot; id=&quot;button_id&quot; value=&quot;提交&quot;&gt;</code></pre><p><strong>图片式提交按钮：指可以在按钮位置上放置图片，这幅图片具有提交按钮的功能</strong></p><pre><code class="html">&lt;input type=&quot;image&quot; /&gt;</code></pre><p><strong>重置按钮：指清除已填写的表单内容，恢复为默认内容，重新填写</strong></p><pre><code class="html">&lt;input type=&quot;reset&quot; /&gt;</code></pre></li></ul><h1 id="H5结构性标签"><a href="#H5结构性标签" class="headerlink" title="H5结构性标签"></a>H5结构性标签</h1><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>网页页眉的结构标签，位于网页的最上端，一般header标签至少包含但不局限于一个标题，还可以包括hgroup标签，包括表格内容，网页封面，logo图案，搜索表单和nav等。</p><h2 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h2><p>网页中的导航条，是navigator的缩写，常用无序列表的形式加上css外观配置实现，一般置于header下方。</p><p>nav标签可以应用于传统导航条，侧边栏导航，页内导航，翻页操作等场合</p><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>用于对网页中的内容进行分区分块，定义文档中的节。一般情况下，section标签常由标题和内容组成。</p><p><strong>注意：</strong></p><ul><li>section标签表示一段专题性的内容，一般会带有标题，没有标题的区块不要用section定义</li><li>根据实际情况来看，若是article标签，aside标签或是nav标签更符合使用条件，那么不要使用section标签</li><li>当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div标签而不是section</li></ul><h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><p>一个特殊的section标签，比section具有更明确的语义，代表一个独立的，完整的相关内容块，可独立于页面其他内容使用</p><p><strong>注意：</strong></p><ul><li>article标签会有标题部分，通常可以包含header，有时也会包含footer</li><li>article可以嵌套，内层的article对外层的article标签有着隶属关系，如博客的文章可以用article显示，一些评论也可以以article的形式嵌入其中</li></ul><h2 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h2><p>aside标签用来装载非正文的内容，被视为页面里单独的一个部分，作为页面或站点全局的附属信息部分，例如广告，友链，侧边栏，导航条等等，可以被article包含在内</p><h2 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h2><p>footer定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说作者和日期。</p><p>作为页面页脚时，一般包括版权，相关文件和链接</p><p>footer和header标签使用基本一样，可以在一个页面中多次使用，也可以在article或section中添加，相当于该区段的页脚</p><h2 id="框架示例："><a href="#框架示例：" class="headerlink" title="框架示例："></a>框架示例：</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;叮叮书店&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;div id=&quot;logo&quot; style=&quot;&quot;&gt;        &lt;header class=&quot;container&quot;&gt;            &lt;div id=&quot;logo&quot;&gt;                &lt;h1&gt;网站logo·叮叮书店(div)&lt;/h1&gt;            &lt;/div&gt;            &lt;div id=&quot;search&quot;&gt;                &lt;form&gt;                    &lt;input type=&quot;search&quot;/&gt;                    &lt;input type=&quot;button&quot; name=&quot;search&quot; value=&quot;搜索&quot;/&gt;                &lt;/form&gt;            &lt;/div&gt;        &lt;/header&gt;        &lt;/div&gt;        &lt;div id=&quot;nav&quot; style=&quot;&quot;&gt;            &lt;nav&gt;                &lt;div&gt;                    &lt;ul&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书籍分类&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;特刊降价&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                    &lt;/ul&gt;                &lt;/div&gt;                &lt;div id=&quot;cart&quot;&gt;&lt;a href=&quot;#&quot;&gt;购物车&lt;/a&gt;&lt;/div&gt;            &lt;/nav&gt;        &lt;/div&gt;        &lt;div&gt;        &lt;main&gt;        &lt;div id=&quot;adv&quot;&gt;            此处用于添加广告        &lt;/div&gt;        &lt;section id=&quot;recommend&quot;&gt;            &lt;h2&gt;本周推荐&lt;/h2&gt;            &lt;section class=&quot;recommend-book&quot;&gt;                &lt;h3&gt;书1标题&lt;/h3&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;div class=&quot;cover-1&quot;&gt;&lt;img src=&quot;img/prod2.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-1&quot;&gt;&lt;p&gt;&lt;mark&gt;书1&lt;/mark&gt;简介&lt;/p&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;section class=&quot;recommend-book&quot;&gt;                &lt;h3&gt;书2标题&lt;/h3&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;div class=&quot;cover-1&quot;&gt;&lt;img src=&quot;img/prod3.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-1&quot;&gt;&lt;p&gt;书2简介&lt;/p&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;        &lt;/section&gt;        &lt;section id=&quot;new&quot;&gt;            &lt;h2&gt;最近新书&lt;/h2&gt;            &lt;div class=&quot;content&quot;&gt;            &lt;section class=&quot;new-book&quot;&gt;                &lt;h3&gt;书3标题&lt;/h3&gt;            &lt;div class=&quot;effect-1&quot;&gt;                &lt;div class=&quot;cover-2&quot;&gt;&lt;img src=&quot;img/prod4.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-2&quot;&gt;                    &lt;h3&gt;书3标题&lt;/h3&gt;                    &lt;p&gt;书3简介&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;section class=&quot;new-book&quot;&gt;                &lt;h3&gt;书4标题&lt;/h3&gt;            &lt;div class=&quot;effect-1&quot;&gt;                &lt;div class=&quot;cover-2&quot;&gt;&lt;img src=&quot;img/prod1.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-2&quot;&gt;                    &lt;h3&gt;书4标题&lt;/h3&gt;                    &lt;p&gt;书4简介&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;/div&gt;        &lt;/section&gt;        &lt;section id=&quot;sale&quot;&gt;            &lt;h2&gt;最近促销&lt;/h2&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;section id=&quot;sale-book&quot;&gt;                    &lt;h3&gt;书5标题&lt;/h3&gt;                    &lt;div class=&quot;effort-1&quot;&gt;                        &lt;div class=&quot;pic&quot;&gt;&lt;img src=&quot;img/prod1.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;sale&quot;&gt;&lt;img src=&quot;img/sale.jpg&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/section&gt;                &lt;section id=&quot;sale-book&quot;&gt;                    &lt;h3&gt;书6标题&lt;/h3&gt;                    &lt;div class=&quot;effort-1&quot;&gt;                        &lt;div class=&quot;pic&quot;&gt;&lt;img src=&quot;img/prod3.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;sale&quot;&gt;&lt;img src=&quot;img/sale.jpg&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/section&gt;            &lt;/div&gt;        &lt;/section&gt;        &lt;/main&gt;        &lt;/div&gt;        &lt;div&gt;        &lt;aside&gt;            &lt;div id=&quot;advert&quot;&gt;&lt;img src=&quot;img/ad1.jpg&quot;&gt;&lt;img src=&quot;img/ad2.jpg&quot;&gt;&lt;img src=&quot;img/ad3.jpg&quot;&gt;&lt;/div&gt;            &lt;section id=&quot;best-selling&quot;&gt;                &lt;h2&gt;畅销图书&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书1&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling1.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书1名&lt;/a&gt;&lt;strong&gt;书1现价&lt;/strong&gt;&lt;del&gt;书1原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书2&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling2.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书2名&lt;/a&gt;&lt;strong&gt;书2现价&lt;/strong&gt;&lt;del&gt;书2原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书3&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling3.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书3名&lt;/a&gt;&lt;strong&gt;书3现价&lt;/strong&gt;&lt;del&gt;书3原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书4&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling4.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书4名&lt;/a&gt;&lt;strong&gt;书4现价&lt;/strong&gt;&lt;del&gt;书4原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书5&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling5.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书5名&lt;/a&gt;&lt;strong&gt;书5现价&lt;/strong&gt;&lt;del&gt;书5原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;div id=&quot;classify-partner&quot;&gt;            &lt;section id=&quot;classify&quot;&gt;                &lt;h2&gt;图书分类&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;编程语言&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;数据库&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;图形图像&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页制作&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;考试认证&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;section id=&quot;partner&quot;&gt;                &lt;h2&gt;合作伙伴&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国电子商务研究中心&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;清华大学出版社&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国人民大学出版社&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国社会科学出版社&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;/div&gt;            &lt;section id=&quot;about&quot;&gt;                &lt;h2&gt;关于书店&lt;/h2&gt;                &lt;div class=&quot;picture&quot;&gt;&lt;img src=&quot;img/about.gif&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;content&quot;&gt;                    &lt;p&gt;书店介绍&lt;/p&gt;                &lt;/div&gt;            &lt;/section&gt;        &lt;/aside&gt;        &lt;/div&gt;        &lt;div id=&quot;footer-wrapper&quot;&gt;        &lt;footer class=&quot;container&quot;&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务条款&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;隐私策略&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/footer&gt;        &lt;/div&gt;        &lt;div id=&quot;copyright&quot; class=&quot;container&quot;&gt;            &lt;div&gt;copyright内容&lt;img src=&quot;img/vcss.gif&quot;&gt;&lt;/div&gt;            &lt;address&gt;通讯地址：            电话：            &lt;/address&gt;        &lt;/div&gt;    &lt;/div&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表单结构&quot;&gt;&lt;a href=&quot;#表单结构&quot; class=&quot;headerlink&quot; title=&quot;表单结构&quot;&gt;&lt;/a&gt;表单结构&lt;/h1&gt;&lt;p&gt;表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介&lt;/p&gt;
&lt;h2 id=&quot;表单的组成&quot;&gt;&lt;a href=&quot;#表单的</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计学习" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-2</title>
    <link href="http://example.com/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/"/>
    <id>http://example.com/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/</id>
    <published>2021-04-09T10:28:08.000Z</published>
    <updated>2021-04-20T14:28:18.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><p>普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可</p><h2 id="材质域（常用）"><a href="#材质域（常用）" class="headerlink" title="材质域（常用）"></a>材质域（常用）</h2><p>材质的类型一般由材质域区分（材质界面左下角中，细节页的材质栏）</p><ul><li><h3 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h3><p>普通的基本材质，如木质、铁质、玻璃等覆盖在表面的东西</p></li><li><h3 id="延迟贴花"><a href="#延迟贴花" class="headerlink" title="延迟贴花"></a>延迟贴花</h3><p>类似等同于喷漆，混合模式只能是半透明，如同投影一样覆盖在物体表面，本质是Actor组件，但可以作为只有一个贴花组件的Actor放入场景</p></li><li><h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用于UI显示，需要新建媒体播放器，使用媒体纹理生成材质，更改材质域为“用户界面”，在用户UI中添加图像时便可以使用该材质放入外观-笔刷中。</p><p>注：使用生成的材质时，需要在UI图表中添加默认值为该材质源媒体播放器的媒体播放器变量，并且事件构造中通过该变量添加对应播放器的“打开源”，如下图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/8.png" alt="8"></p></li></ul><p>左二接口接入媒体播放器（仅作为媒介），而左三接口则接入具体的视频媒体</p><h2 id="混合模式（常用）"><a href="#混合模式（常用）" class="headerlink" title="混合模式（常用）"></a>混合模式（常用）</h2><ul><li><h3 id="不透明"><a href="#不透明" class="headerlink" title="不透明"></a>不透明</h3><p>整个材质完全不透光，一般作为底层材质</p></li><li><h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><p>材质呈现半透明，可以和下层叠加，一般是作为贴花使用</p></li></ul><h2 id="材质节点引脚（常用）"><a href="#材质节点引脚（常用）" class="headerlink" title="材质节点引脚（常用）"></a>材质节点引脚（常用）</h2><ul><li><h3 id="基础颜色"><a href="#基础颜色" class="headerlink" title="基础颜色"></a>基础颜色</h3><p>材质的基本图像，可以是纯色或贴图，是整个材质的主外观</p></li><li><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>一般叫做金属度，针对金属材质，设置金属的质感，反光光泽等</p></li><li><h3 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h3><p>基本用于非金属表面，一般输入一张比标准贴图亮的贴图，用于扩大光照面和暗面的对比，也可以直接输入一个具体的值，改变整体的反光强度，类似对比度</p></li><li><h3 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h3><p>决定材质的粗糙程度，0为完全光滑的镜面反射，1为完全粗糙的漫反射</p></li><li><h3 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h3><p>控制材质发光部位，设置自发光颜色或强度</p></li><li><h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>法线，输入一张法线贴图，用于记录材质不同位置的凹凸感</p></li><li><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>输入一个很小的数，影响折射率，可以实现透明玻璃之类的折射，<strong>但效果不怎么样</strong></p></li></ul><h2 id="材质快捷键节点"><a href="#材质快捷键节点" class="headerlink" title="材质快捷键节点"></a>材质快捷键节点</h2><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/1.png" alt="1"></p><p>快捷键：1+Left</p><p>具体作用：创建一个常数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/3.png" alt="3"></p><p>快捷键：3+Left</p><p>具体作用：创建一个常量颜色值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/2.png" alt="2"></p><p>快捷键：s+Left</p><p>具体作用：创建一个变量数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/6.png" alt="6"></p><p>快捷键：V+Left</p><p>具体作用：创建一个颜色变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/5.png" alt="5"></p><p>快捷键：U+Left</p><p>具体作用：创建一个UV缩放节点，用于缩放贴图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/4.png" alt="4"></p><p>快捷键：A+Left</p><p>具体作用：将两种颜色或贴图叠加在一起</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/7.png" alt="7"></p><p>快捷键：M+Left</p><p>具体作用：将两种颜色或贴图混合在一起，一般用选定颜色乘白色贴图进行染色</p><h2 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h2><p>由材质生成的材质实例将材质蓝图中的变量节点显示于右面接口，通过改变接口值来更加直观的实时改变材质的颜色等各种属性，能够实现一个材质创造一堆材质实例的操作</p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>同c的结构体变量类型相同，可以设置一个结构体变量中包含多个普通类型变量，并设置默认值，不能使用自身类型的变量嵌套</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/9.png"></p><p>在蓝图中使用时，通过make节点创建结构体并连接set对应的结构体变量，可初始化的设定其各个变量的值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/11.png" alt="11"></p><p>使用break节点拆分结构体，可以得到其中指定的单个变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/10.png" alt="10"></p><h2 id="蓝图函数库"><a href="#蓝图函数库" class="headerlink" title="蓝图函数库"></a>蓝图函数库</h2><p>类似于头文件，但并不只是函数声明，而是完整的函数编辑，对于同一个文件，可以在左侧边栏里添加多个函数，而且所定义的所有函数均为全局函数</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/12.png" alt="12"></p><p>和c与c++的函数不同，虚幻引擎的函数可以有多个输入，多个输出</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/13.png" alt="13"></p><p>反应在引用该函数的蓝图上就是对应变量的接口</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/14.png" alt="14"></p><h2 id="蓝图宏库"><a href="#蓝图宏库" class="headerlink" title="蓝图宏库"></a>蓝图宏库</h2><p>类似于函数库，但创建与普通蓝图相似，用于创建自定义节点，通常选择创建actor或是object</p><p>默认的宏库中只有一个新建宏0和没有接口的输入输出节点，可选择输入输出节点后在右下角细节面板添加</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/15.png" alt="15"></p><p>不同于函数的是，设置宏的输入输出时，额外可以设置的还有执行引脚</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/22.png" alt="22"></p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/20.png" alt="20"></p><p>若在蓝图宏库中写入以上内容，则在其他蓝图中引用宏时能够得到下面节点</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/21.png" alt="21"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型会将数据定义成具体的内容，例如bool型中，0定义为了false，1定义为了true，创建面板如下，可通过右侧的“新”添加新的枚举值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/16.png" alt="16"></p><p>在蓝图中设置枚举变量也和其他变量类型的操作相同</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/17.png" alt="17"></p><p>用switch连上枚举类型的话，可以用于判断枚举类型，切换流程</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/18.png" alt="18"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>相当于编辑器里的Beginplay（事件开始运行），事件面板中的内容在编辑器中不会运行，只有测试时才会执行，但构造函数里的内容编辑器中也会执行，并且不断更新，只要改动就会产生实时变化。</p><p>简要来说，在蓝图中写入“设置actor位置”无法在场景中看到actor位置变化，但在选项卡中改动x，y，z数值却会直接改变actor位置，后者就属于构造函数中的内容</p><h2 id="媒体播放器"><a href="#媒体播放器" class="headerlink" title="媒体播放器"></a>媒体播放器</h2><p>媒体播放器仅仅是视频文件的播放载体，放入媒体播放器的文件仅仅是预览，具体文件播放的内容需要在蓝图或场景中设置（详细的使用在前面“材质-用户界面”有讲）</p><p><strong>注：UE4支持的视频文件格式应该是.avi，音频文件是.wav，导入时需要注意</strong></p><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><p>如字面意思，用于体现物体物理状态的材质，主要是设定摩擦力</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/23.png" alt="23"></p><p>物理材质可以在材质面板中赋给某个特定的材质，改变使用这个材质的所有模型的物理材质，也可以在场景中赋予单个模型，后者为物理材质的重载，会针对选定模型覆盖原有的物理材质</p><h2 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="控件蓝图"><a href="#控件蓝图" class="headerlink" title="控件蓝图"></a>控件蓝图</h3><ul><li><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>默认新建的控件蓝图中会生成一个画布面板，可以通过多个面板与面板的排列或是互相之间的嵌套完成一整套hud或是UI的设置</p></li><li><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一般只使用可编辑文本和文本框，可编辑文本允许玩家/用户编辑，没有背景，而文本框是开发者设定的文字，显示上有背景；</p><p>其中没有备注的均为单行，不能换行，而标注了多行，也仅仅是多行文本框支持换行，并不意味着自动换行</p><p><strong>右侧的细节面板中（以文本框为例）</strong></p><p>【锚点栏】</p><p>1.锚点主要针对屏幕比例不同时，设定UI位置的参考系</p><p>2.大小到内容是使整个控件大小和内容（比如文字长度）相同</p><p>3.Zorder是上下层数，重叠时最上层数值最大</p><p>【内容栏】文本为固定出现的文本，而提示文本则是仅文本框为空才出现的内容</p><p>【外观栏】</p><p>1.支持更换文本框的背景图片，悬停为鼠标悬停，聚焦指鼠标点击</p><p>2.填充指缩进部分，数值越大，缩进越多</p><p>3.字体轮廓设置时可以选择对投影应用轮廓，让阴影部分也具有描边</p><p>4.删除线可导入图片作为删除线</p><p>5.阴影偏移能够设定阴影与文字的位置差，相当于调整投影的光的角度</p><p>【行为栏】</p><p>1.不勾选“已启用”则显示控件，但不能交互（未开放或不能按的按钮）</p><p>2.可视性：针对可见和占据空间及子项能否交互分类，详情鼠标悬停在选项上</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>导入字体格式一般为otf，ttf也可行，对同种字体同时导入多个文件时，需要否定引擎导入时的新建（否则会每个文件导入一个字体资产），另外自行新建字体资产，分配字体族系</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/24.png" alt="24"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;材质&quot;&gt;&lt;a href=&quot;#材质&quot; class=&quot;headerlink&quot; title=&quot;材质&quot;&gt;&lt;/a&gt;材质&lt;/h1&gt;&lt;p&gt;普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可&lt;/p&gt;
&lt;h2 id=&quot;材质域（常用）&quot;&gt;&lt;a href=&quot;#材质域（常用）&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-1</title>
    <link href="http://example.com/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/"/>
    <id>http://example.com/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/</id>
    <published>2021-04-02T11:43:30.000Z</published>
    <updated>2021-04-20T14:28:02.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键节点："><a href="#快捷键节点：" class="headerlink" title="快捷键节点："></a>快捷键节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/1.png" alt="1"></p><p>节点名：延迟</p><p>呼出方式：（快捷键）D+left</p><p>具体作用：实现程序暂停，延迟一段时间继续执行后续节点</p><p>接口：Duration——延迟时长，单位为秒</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/2.png" alt="2"></p><p>节点名：分支</p><p>呼出方式：（快捷键）B+left</p><p>具体作用：实现程序因布尔值变化而条件分歧</p><p>接口：Condition——决定选择支的布尔值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/3.png" alt="3"></p><p>节点名：序列</p><p>呼出方式：（快捷键）S+left</p><p>具体作用：使多个分支同时进行</p><p>接口：Then——同时进行的分支接口</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/4.png" alt="4"></p><p>节点名：For each loop</p><p>呼出方式：（快捷键）F+left</p><p>具体作用：根据数组元素的个数执行循环</p><p>接口：array——需要遍历的数组</p><p>Loop body——循环体</p><p>Array Element——当前数组元素的值</p><p>Array Index——当前数组元素的下标</p><p>Completed——循环出口</p><h1 id="普通节点："><a href="#普通节点：" class="headerlink" title="普通节点："></a>普通节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/5.png" alt="5"></p><p>节点名：获取类的所有actor</p><p>呼出方式：右键查询（使用节点名或get all actor）</p><p>具体作用：获取场景中所有某类的实例</p><p>接口：Actor Class——需要获取的类</p><p>Out Actors——选中类的所有actor的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/6.png" alt="6"></p><p>节点名：自定义事件（事件名称）</p><p>呼出方式：右键查询（使用节点名或custom event）</p><p>具体作用：定义一个自定义事件</p><p>接口：无</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/11.png" alt="11"></p><p>节点名：（事件名称）</p><p>呼出方式：右键查询（使用节点名查找引用）</p><p>具体作用：引用一个在某蓝图中定义好的自定义事件</p><p>接口：无</p><h1 id="时间轴与变换节点："><a href="#时间轴与变换节点：" class="headerlink" title="时间轴与变换节点："></a>时间轴与变换节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/10.png" alt="10"></p><p>节点名：时间轴</p><p>呼出方式：右键查询（使用节点名或timeline）</p><p>具体作用：创建时间轴（用于播放动画等）</p><p>接口：play——正放</p><p>play from start——从头正放</p><p>stop——暂停</p><p>Reverse——倒放</p><p>Reverse from End——从最后倒放</p><p>Set New Time——跳转到特定时间轴</p><p>New Time——设定跳转到的特定时间轴（需要Set New Time启用）</p><p>Update——在时间轴移动时不断执行</p><p>Finished——时间轴结束后执行（无论正放倒放）</p><p>Direction——为时间轴进行方向，可在update或finished后接入switch判断正放倒放</p><p>*创建时间轴和圆滑曲线化：</p><p>通常使用浮点型轨道（f+），键入轨道名称后会出现相应接口，返回时间轴窗口创建关键帧，在两个不同关键帧间会形成对应时间和值的变化直线（折线），最后修改时间轴总长度等于有效变化直线的时间，若同时将两个或以上的关键帧插值改为“用户”型，可通过调整其切线使整个变化折线变为曲线，更加圆滑的完成值的变化</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/12.png" alt="12"></p><p>节点名：拆分变换</p><p>呼出方式：右键查找（使用节点名或break）</p><p>具体作用：将一个变换过程拆分成L、R、S三者</p><p>接口：In Transform——需要拆分的变换</p><p>Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/13.png" alt="13"></p><p>节点名：创建变换</p><p>呼出方式：右键查找（使用节点名或make）</p><p>具体作用：合并L、R、S三者为一个变换过程</p><p>接口：Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p>Return value——变换的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/15.png" alt="15"></p><p>节点名：插值</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个值随时间变化中特定比例处的值</p><p>接口：A——变化开始时值的初始量</p><p>B——变化结束时值的终点量</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/16.png" alt="16"></p><p>节点名：插值（向量）</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个向量随时间变化中特定比例处的值</p><p>接口：A——变化开始时向量的初始值</p><p>B——变化结束时向量的终点值</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/14.png" alt="14"></p><p>节点名：已限制映射范围</p><p>呼出方式：右键查找（使用节点名或Clamp）</p><p>具体作用：将基准值实现In A~In B的变化，并且按In和Out的A、B比例缩放</p><p>接口：Value——输入的基准值</p><p>In Range A——输入的初始比例</p><p>In Range B——输入的终点比例</p><p>Out Range A——输出的初始比例</p><p>Out Range B——输出的终点比例</p><p>Return Value——返回变化且缩放后的值</p><p>注：上文所提到的普通插值可视作In A=0.0，In B=1.0的该节点</p><h1 id="运算节点："><a href="#运算节点：" class="headerlink" title="运算节点："></a>运算节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/17.png" alt="17"></p><p>节点名：限制（浮点）</p><p>呼出方式：右键查找（使用节点名或clamp）</p><p>具体作用：将数据限制在范围内，范围外的数小于min的输出min，大于max输出max</p><p>接口：Value——输入值</p><p>Min——范围的最小值</p><p>Max——范围的最大值</p><p>Return Value——数据限制后的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/18.png" alt="18"></p><p>节点名：截断</p><p>呼出方式：右键查找（使用节点名）/将浮点数据直接接入整数接口</p><p>具体作用：将数据向0舍入，截断小数部分</p><p>注：1.6舍入为1，但-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/19.png" alt="19"></p><p>节点名：底部</p><p>呼出方式：右键查找（使用节点名或floor）</p><p>具体作用：将数据向负无穷舍入，下舍到前一个整数</p><p>注：1.6舍入为1，但-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/20.png" alt="20"></p><p>节点名：顶部</p><p>呼出方式：右键查找（使用节点名）</p><p>具体作用：将数据向正无穷/向上舍入到下一个整数</p><p>注：1.6舍入为2，而-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/21.png" alt="21"></p><p>节点名：舍入</p><p>呼出方式：右键查找（使用节点名或round）</p><p>具体作用：将数据舍入到最近的整数</p><p>注：1.6舍入为2，而-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/22.png" alt="22"></p><p>节点名：（dot）</p><p>呼出方式：右键查找（点乘积）</p><p>具体作用：计算向量点乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/23.png" alt="23"></p><p>节点名：（cross）</p><p>呼出方式：右键查找（叉乘积）</p><p>具体作用：计算向量叉乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/24.png" alt="24"></p><p>节点名：范围内随机浮点（其他数据类型也可）</p><p>呼出方式：右键查找（使用节点名或random float）</p><p>具体作用：生成随机浮点数</p><p>接口：min——最小值</p><p>max——最大值</p><p>return value——范围内的随机数</p><h1 id="选择节点："><a href="#选择节点：" class="headerlink" title="选择节点："></a>选择节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/7.png" alt="7"></p><p>节点名：切换整型</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：利用整数切换引脚流程</p><p>接口：Selection——作为切换标准的整型</p><p>Default——不满足其他引脚时的默认执行引脚</p><p>注：除切换为整型以外，其他类型的数据也可使用switch查找对应类型的切换</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/9.png" alt="9"></p><p>节点名：开启字符串【翻译可能有误】</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：输入指定字符串选择完全相同的引脚执行</p><p>接口：Selection——输入作为判断依据的字符</p><p>Default——不满足其他引脚时的默认执行引脚</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/8.png" alt="8"></p><p>节点名：选择</p><p>呼出方式：右键查询（使用节点名或select）</p><p>具体作用：通过输入的内容得到已设定的返回值</p><p>接口：Option 0，Option 1——设置给出的index值得到的返回值</p><p>Index——可以接入任何类型的通配符</p><p>Return value——返回值的出口</p><h1 id="控制器节点："><a href="#控制器节点：" class="headerlink" title="控制器节点："></a>控制器节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/26.png" alt="26"></p><p>节点名：设置仅输入模式游戏</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在游戏界面中心</p><p>接口：Player Controller——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/25.png" alt="25"></p><p>节点名：设置仅输入模式UI</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在某个UI上</p><p>接口：Player Controller——接玩家控制器</p><p>In Widget to Focus——将光标锁定在该接口指定的UI上</p><p>In Mouse Lock Mode——设置系统光标状态</p><p>注：In Mouse Lock Mode接口分不锁定、捕获时锁定、固定锁定、锁定为全屏；捕获时锁定指运行窗口在最前端时将系统光标锁定在程序窗口内，直到win键强行解锁；固定锁定指一直将系统光标锁定在程序窗口内，直到win键强行解锁；锁定为全屏指仅全屏时锁定光标。</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/31.png" alt="31"></p><p>节点名：获取玩家控制器/角色/pawn</p><p>呼出方式：右键查询（使用节点名或蓝色引脚牵出搜索get player）</p><p>具体作用：得到一个玩家控制器的返回值</p><p>接口：Player Index——玩家控制器的序号</p><p>Return Value——返回玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/33.png" alt="33"></p><p>节点名：（set）</p><p>呼出方式：右键查询（show mouse）[需要取消情境关联]</p><p>具体作用：设置鼠标的显示</p><p>接口：Show Mouse Cursor——是否显示鼠标</p><p>目标——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/32.png" alt="32"></p><p>节点名：生成Actor</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：凭空创建一个actor</p><p>接口：Class——生成的actor类型</p><p>Spawn Transform——指定actor初始变换（生成位置、缩放、旋转度）</p><p>Collision Handing Override——判断生成的条件（和碰撞体积有关）</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/27.png" alt="27"></p><p>节点名：销毁Actor</p><p>呼出方式：右键查询（使用节点名或destroy）</p><p>具体作用：销毁目标Actor</p><p>接口：目标——被销毁的对象</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/30.png" alt="30"></p><p>节点名：构建</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：创建一个UI</p><p>接口：Class——UI的类型</p><p>Owning Player——指定UI属于哪一个玩家</p><p>Return Value——生成的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/29.png" alt="29"></p><p>节点名：添加到视口</p><p>呼出方式：右键查询（使用节点名或牵引构建ui的返回值引脚，输入add to）</p><p>具体作用：让创建的UI显示到用户界面</p><p>接口：目标——接已创建的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/28.png" alt="28"></p><p>节点名：从父项中移除</p><p>呼出方式：右键查询（使用节点名或remove from parent）</p><p>具体作用：移除目标控件</p><p>接口：目标——需要移除的控件</p><h1 id="数组节点"><a href="#数组节点" class="headerlink" title="数组节点"></a>数组节点</h1><p>创建数组：在创建好的变量左侧图标上右键，能够创建一个同类型变量的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/34.png" alt="34"></p><p>节点名：获取数组元素（上为复制，下为引用）</p><p>呼出方式：右键查询（使用节点名或数组引线查询get）</p><p>具体作用：获取数组中指定下标的元素</p><p>接口：（数组接口）——该元素所在数组</p><p>（整数型接口）——需要获取的数组元素下标</p><p>（右值）——返回值（复制返回值，引用返回地址）</p><p>注：该节点分为复制和引用两种方式，同c/c++中函数的传值和引用传址，复制会生成副本，引起的变化不改变数组本身，而引用则可以改变数组内元素的值，但操作不当易使数据受损</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/35.png" alt="35"></p><p>节点名：创建数组</p><p>呼出方式：右键查询（使用节点名或从set左值牵引查询make）</p><p>具体作用：创建一个数组</p><p>接口：左侧——设置序号下的数组值</p><p>右侧——得到数组变量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/36.png" alt="36"></p><p>节点名：（set）</p><p>呼出方式：有引出变量的情况下，输入set查询</p><p>具体作用：设置数组</p><p>接口：左侧——被设置的对象变量数组</p><p>右侧——接已经创建的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/37.png" alt="37"></p><p>节点名：设置阵列元素</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询set）</p><p>具体作用：设置数组单个元素的值</p><p>接口：Target Array——接该元素所在数组</p><p>Index——指定的数组元素的序号</p><p>Item——为该数组元素所赋的值</p><p>Size to Fit——当index大于数组大小时，数组将扩展</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/38.png" alt="38"></p><p>节点名：查找项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：查找与给定值相等的数组下标</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/39.png" alt="39"></p><p>节点名：为有效索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：判断能否查找到指定元素</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——能否找到的bool值返回</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/40.png" alt="40"></p><p>节点名：添加</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在数组最后添加一个元素</p><p>接口：左侧——数组与需要添加的值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/41.png" alt="41"></p><p>节点名：插入</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在指定下标处插入一个元素，其他元素自动后移</p><p>接口：左侧——数组与需要查找的给定值，以及需要插入的位置序号</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/42.png" alt="42"></p><p>节点名：长度</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：返回数组长度</p><p>接口：左侧——数组</p><p>右侧——数组长度返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/43.png" alt="43"></p><p>节点名：清空</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：清空整个数组</p><p>接口：左侧——需要清空的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/44.png" alt="44"></p><p>节点名：移除项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除等于这个值的元素</p><p>接口：左侧——数组与需要移除的给定值</p><p>右侧——返回是否成功移除</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/45.png" alt="45"></p><p>节点名：移除索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除这个下标的元素</p><p>接口：左侧——数组和元素下标</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快捷键节点：&quot;&gt;&lt;a href=&quot;#快捷键节点：&quot; class=&quot;headerlink&quot; title=&quot;快捷键节点：&quot;&gt;&lt;/a&gt;快捷键节点：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%9</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-2</title>
    <link href="http://example.com/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/"/>
    <id>http://example.com/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</id>
    <published>2021-03-30T06:14:43.000Z</published>
    <updated>2021-04-21T08:34:44.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-单链表"><a href="#线性表-单链表" class="headerlink" title="线性表-单链表"></a>线性表-单链表</h1><p>【Elemtype为数据类型】</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="链表结点结构体创建"><a href="#链表结点结构体创建" class="headerlink" title="链表结点结构体创建"></a>链表结点结构体创建</h3><pre><code>typedef struct LNode        //创建结点类型&#123;    elemtype data;         //结点中包含数据域    struct LNode *next;    //结点中包含指向下一个结点的指针&#125;*Linklist                 //将该类型定义为一个链表（常使用指针方式价）</code></pre><h3 id="尾插法创建"><a href="#尾插法创建" class="headerlink" title="尾插法创建"></a>尾插法创建</h3><pre><code class="c++">void create(Linklist &amp;L,int n)//传址需要创建的表L，以及初始表长n&#123;    L=new Lnode;        //为L新分配一个地址    L-&gt;next=NULL;        //将L的next设为空（前两步为初始化）    Lnode *E=L;            //令新指针指向L指向的头结点    int i,a;    Lnode *p;            //定义另一个指向结点的指针p    for(i=1;i&lt;=n;i++)        &#123;     cin&gt;&gt;a;            //输入数据a     p=new Lnode;        //令p指向新建结点     p-&gt;data=a;            //将新建结点的数据域赋值为a     E-&gt;next=p;            //令E的next指向p指向的结点     p-&gt;next=NULL;        //p的next指向空     E=p;                //指针E后移，指向p指向的结点    &#125;&#125;</code></pre><h3 id="头插法创建"><a href="#头插法创建" class="headerlink" title="头插法创建"></a>头插法创建</h3><pre><code>void create(Linklist &amp;L，int n)//传址需要创建的表L，以及初始表长n&#123;    L=new LNode;    L-&gt;next=NULL;    int i,a;    struct LNode *p;    cin&gt;&gt;a;    for(i=1;a!=-1;i++)    &#123;    p=new LNode;    p-&gt;data=a;    p-&gt;next=L-&gt;next;    L-&gt;next=p;    cin&gt;&gt;a;    &#125;&#125;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>注：初始化应当在尾插和头插法前使用，或者不使用</p><pre><code class="c++">bool init(Linklist &amp;L)       //传址创建的链表&#123;    L=new LNode;            //新生成一个结点，让头指针指向头结点    L-&gt;next=NULL;          //为统一操作，头结点仅作为首元结点的前驱，数据域不放入数据，且指针域指向空    return true;           //返回值提示完成初始化&#125;</code></pre><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>单链表的取值需要顺序遍历，耗时较长，故而不适合频繁获取特定位置的值</p><pre><code class="c++">bool getelem(Linklist &amp;L,int i,elemtype &amp;e)//传址数据所在的表，并且传值需要取值的元素序号i，将得到的值传给e&#123;    int j;    LNode *p=L-&gt;next;               //令p指向首元结点    for(j=1;j&lt;i&amp;&amp;p!=NULL;j++)       //j作为计数器，确定遍历到的位置，当p指针指向空或j==i时结束循环    &#123;        p=p-&gt;next;                  //让p指向p的下一个结点，实现p后移    &#125;                               //结束循环时，j==i，p指向的结点为第i-1个结点     if(p==NULL) return false;       //如果p指针指向空，则返回取值失败    e=p-&gt;next-&gt;data;                //否则，将p指向结点的下一个结点的数据域赋给e    return true;                   //返回取值完成&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>单链表的查找同顺序表一样，需要遍历整个表，比较每个数据域和待查找值，若相同则返回其序号，若始终不相同则返回查找失败</p><pre><code class="c++">bool find(Linklist &amp;L,LNode *&amp;p,elemtype a)//传址需要查找的表，查找成功时用于指向查找结果的指针p，同时传值需要查找的数据a&#123;    int j;    p=L-&gt;next;    for(j=1;p-&gt;next!=NULL;j++)      //j作为计数器，确定遍历到的位置，当p指针指向为空时结束循环    &#123;        if(p-&gt;data==a) break;       //查找到与数据a相同的数据域，提前退出循环        p=p-&gt;next;                  //p指针继续后移，继续遍历整个链表    &#125;    if(p-&gt;next==NULL&amp;&amp;p-&gt;data!=a)   return false;      //如果p指针已经指向尾结点，且尾结点数据域域不等于a，则查找失败    //p指针直接能够返回需要查找的节点，不需要另外设置返回    return true;                   //返回查找成功&#125;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时，需要先让新结点连接需要插入位置前驱的后一个结点，再让前驱的next指针指向新结点，否则会直接丢失后面数据的地址</p><pre><code class="c++">bool insert(Linklist &amp;L,int i，elem e)//传址链表，需要插入的位置i，需要插入的元素值e&#123;    int j;    Lnode *p=L-&gt;next;                //使p指针指向首元结点    Lnode *s=new Lnode;              //新建一个结点，并用s指针指向它    s-&gt;data=e;                       //将新建结点的数据域赋为e    for(j=0;j&lt;i-1&amp;&amp;p!=NULL;j++)          //当j移动到需要插入位置的前驱时或者链表结束时结束循环    &#123;        p=p-&gt;next;                   //让p指向下一个结点    &#125;    if(p==NULL) return false;        //如果p指向不合法位置则返回插入失败    s-&gt;next=p-&gt;next;                 //否则让s的next指针指向p的下一个结点    p-&gt;next=s;                       //并让p的next指针指向s    return true;                     //返回成功插入&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="c++">bool del(Linklist &amp;L,int i)&#123;    int j;    Lnode *p=L-&gt;next;                //使p指向首元结点    for(j=0;j&lt;i-1&amp;&amp;p!=NULL)               //当j移动到需要删除位置的前驱或链表结束时结束循环    &#123;        p=p-&gt;next;                  //让p指向p的下一个结点    &#125;    if(p=NULL) return false;        //p指向不合法位置时，返回删除失败    p-&gt;next=p-&gt;next-&gt;next;          //让p的next指针等于p下一个结点的next    return true;                    //返回删除成功&#125;</code></pre><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-3-单链表的创建及遍历-20-分"><a href="#R7-3-单链表的创建及遍历-20-分" class="headerlink" title="R7-3 单链表的创建及遍历 (20 分)"></a>R7-3 单链表的创建及遍历 (20 分)</h3><p>读入n值及n个整数，建立单链表并遍历输出。</p><p>输入格式:<br>读入n及n个整数。</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><pre><code>210 5</code></pre><p>输出样例:<br>在这里给出相应的输出。例如：</p><pre><code>10 5</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode *next;&#125;*Linklist;void create(Linklist &amp;L,int n)&#123;    L=new Lnode;    L-&gt;next=NULL;    if(n&gt;0)     &#123;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;i&lt;=n;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;    &#125;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;        if(L-&gt;next==NULL) return 0;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist list;    int n;    cin&gt;&gt;n;    create(list,n);    putout(list);    return 0;&#125;</code></pre><h3 id="R7-1-两个有序链表序列的合并-20-分"><a href="#R7-1-两个有序链表序列的合并-20-分" class="headerlink" title="R7-1 两个有序链表序列的合并 (20 分)"></a>R7-1 两个有序链表序列的合并 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><pre><code>1 3 5 -12 4 6 8 10 -1</code></pre><p>输出样例:</p><pre><code>1 2 3 4 5 6 8 10</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode* next;&#125;*Linklist;bool init(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;    return true;&#125;void create(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;a!=-1;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;&#125;bool addit(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)&#123;    struct Lnode *p1=l1-&gt;next,*p2=l2-&gt;next, *p3;    l3=l1;    p3=l3;    while(p1&amp;&amp;p2)    &#123;            if(p1-&gt;data&lt;=p2-&gt;data)            &#123;                p3-&gt;next=p1;                p3=p1;                p1=p1-&gt;next;            &#125;            else &#123;                p3-&gt;next=p2;                p3=p2;                p2=p2-&gt;next;            &#125;    &#125;    p3-&gt;next=p1?p1:p2;    return true;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;                if(L-&gt;next==NULL) &#123;        cout&lt;&lt;&quot;NULL&quot;; return 0;&#125;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist L1,L2,L3;    create(L1);    create(L2);    init(L3);    addit(L1,L2,L3);    putout(L3);    return 0;&#125;</code></pre><h3 id="R7-2-两个有序链表序列的交集-20-分"><a href="#R7-2-两个有序链表序列的交集-20-分" class="headerlink" title="R7-2 两个有序链表序列的交集 (20 分)"></a>R7-2 两个有序链表序列的交集 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><pre><code>1 2 5 -12 4 5 8 10 -1</code></pre><p>输出样例:</p><pre><code>2 5</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode* next;&#125;*Linklist;bool init(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;    return true;&#125;void create(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;a!=-1;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;&#125;bool find(Linklist &amp;L,int a)&#123;    int j;    struct Lnode *p;    p=L-&gt;next;    for(j=1;p-&gt;next!=NULL;j++)          &#123;        if(p-&gt;data==a) break;               p=p-&gt;next;                     &#125;    if(p-&gt;next==NULL&amp;&amp;p-&gt;data!=a)   return false;                  return true;  &#125;bool cutit(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)&#123;    struct Lnode *p1=l1-&gt;next,*p2=l2-&gt;next,*p3=l3;    while(p1&amp;&amp;p2)    &#123;        if(p1-&gt;data&lt;p2-&gt;data)        &#123;            p1=p1-&gt;next;        &#125;        else        if(p1-&gt;data==p2-&gt;data)        &#123;            p3-&gt;next=p1;            p3=p3-&gt;next;            p1=p1-&gt;next;            p2=p2-&gt;next;        &#125;        else        if(p1-&gt;data&gt;p2-&gt;data)        &#123;            p2=p2-&gt;next;        &#125;    &#125;    if(p3-&gt;next!=NULL) p3-&gt;next=NULL;    return true;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;        if(L-&gt;next==NULL) &#123;        cout&lt;&lt;&quot;NULL&quot;; return 0;&#125;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist L1,L2,L3;    create(L1);    create(L2);    init(L3);    cutit(L1,L2,L3);    putout(L3);    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表-单链表&quot;&gt;&lt;a href=&quot;#线性表-单链表&quot; class=&quot;headerlink&quot; title=&quot;线性表-单链表&quot;&gt;&lt;/a&gt;线性表-单链表&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; clas</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-1</title>
    <link href="http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
    <id>http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</id>
    <published>2021-03-24T11:02:30.000Z</published>
    <updated>2021-04-08T12:22:00.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-顺序表"><a href="#线性表-顺序表" class="headerlink" title="线性表-顺序表"></a>线性表-顺序表</h1><p>【Elemtype为数据类型】</p><h2 id="创建（初始化）"><a href="#创建（初始化）" class="headerlink" title="创建（初始化）"></a>创建（初始化）</h2><p>以数组的形式创建顺序表</p><pre><code>typedef struct      //理解为将定义的结构体改称为&#123;&#125;后的名字，如SQlist&#123;    Elemtype *elem； //定义顺序表具有首元素地址    int length;     //定义顺序表具有表长这一属性&#125;SQlist;</code></pre><p>初始化设置顺序表的最大存储空间，以及初始化其表长为0</p><pre><code>bool initList(SQlist &amp;sq)     //将需要初始化的表传址&#123;    sq.elem=new maxsize;        //为顺序表分配maxsize的空间作为最大上限    if(!sq.elem) return false;      //如果空间分配失败，直接返回提示错误    sq.length=0;                    //如果分配空间成功，则继续初始化表长为0    return true;                    //返回参数提示顺序表初始化成功&#125;</code></pre><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>顺序表能够随机存取，故而方便存取指定位置的值，即可以随机存取</p><pre><code>bool getelem(SQlist &amp;sq,int i，elemtype &amp;a)  //将需要初始化的表传址，并且传值需要获取的是第i个值，返回的值传给a&#123;    if(i&lt;1||i&gt;sq.length) return false;    //如果i为非法位置，返回提示错误    a=sq.elem[i];                 //否则返回第i个元素给a    return true;                  //返回提示执行正常&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序表的查找就是顺序比较表内元素和待查找元素，相同查找成功，始终不同查找失败</p><pre><code>int find(SQlist &amp;sq,elemtype a)//传址需要查找的表，并传值需要查找的数值a,返回查找到的序号为int类型&#123;    int i;    for(i=0;i&lt;sq.length;i++)    &#123;    if(sq.elem[i]==a) return i;    //如果查找到了，返回该值在表中的序号，此处为数组下标，若返回第几个元素序号，则需要i+1    &#125;    return -1;            //查找失败，返回负数&#125;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>顺序表为紧邻的线性表，故而插入时需要向后移动较多元素，并且需要从最后一个元素开始向后移动，以免数据被覆盖</p><pre><code>bool insert(SQlist &amp;sq,elemtype a,int i)//将元素a的值插入表中第i个位置，传址需要做插入的表，以及传值a，i&#123;    int j;    if(i&lt;1||i&gt;sq.length+1) return false;//如果i值不合法，则不作插入    if(sq.length==maxsize) return false;//如果表长已经达到最大，则判断表满，不作插入    for(j=sq.length-1;j&gt;=i-1;j--)    //让j为最后一个元素的角标，循环递减，并且当j等于插入位置i的前驱时，停止循环    &#123;        sq.elem[j+1]=sq.elem[j];        //给j+1角标的空间赋值当前j角标的值，实现后移    &#125;    sq.elem[i-1]=a;                     //赋值第i个位置，即角标为i-1的空间为a    sq.length++;                        //表长增加    return true;                        //返回插入成功&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>顺序表的删除是将待删除位置后面的全部往前覆盖，向前移动较多元素，并且需要从待删除位置的后一个开始移动，以免覆盖数据</p><pre><code>bool delete(SQlist &amp;sq,int i)//传址需要删除元素的顺序表，并且传值需要删除的元素位置&#123;    int j;    if(i&lt;1||i&gt;sq.length) return false;   //如果i值不合法，则不作插入    for(j=i;j&lt;=sq.length-1;j++)    //将i位置之后的所有元素都向前移，并且循环在将最后一个元素移动到表长减一后的位置停止    &#123;        sq.elem[j-1]=sq.elem[j];        //被删位置后的元素全部前移    &#125;    sq.length--;                        //表长减少    return true;&#125;</code></pre><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-1-顺序表的建立及遍历-20-分"><a href="#R7-1-顺序表的建立及遍历-20-分" class="headerlink" title="R7-1 顺序表的建立及遍历 (20 分)"></a>R7-1 顺序表的建立及遍历 (20 分)</h3><p>读入n值及n个整数，建立顺序表并遍历输出。</p><p>输入格式:<br>读入n及n个整数</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><pre><code>4-3 10 20 78</code></pre><p>输出样例:<br>在这里给出相应的输出。例如：</p><pre><code>-3 10 20 78</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *a;    int length;&#125;List;int create(List &amp;sq)&#123;    sq.a= new int[100];    if(!sq.a) return 0;    sq.length=0;    return 1;&#125;int output(List &amp;sq)&#123;    int j;    cout&lt;&lt;sq.a[0];    for(j=1;j&lt;sq.length;j++)    &#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;sq.a[j];    &#125;&#125;int main()&#123;    List sqlist;    int i,n;    cin&gt;&gt;n;    create(sqlist);    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;sqlist.a[i];        sqlist.length++;    &#125;    if(sqlist.length!=0)         output(sqlist);    return 0;&#125;</code></pre><h3 id="R7-2-jmu-ds-顺序表区间元素删除-20-分"><a href="#R7-2-jmu-ds-顺序表区间元素删除-20-分" class="headerlink" title="R7-2 jmu-ds-顺序表区间元素删除 (20 分)"></a>R7-2 jmu-ds-顺序表区间元素删除 (20 分)</h3><p>若一个线性表L采用顺序存储结构存储，其中所有的元素为整数。设计一个算法，删除元素值在[x,y]之间的所有元素，要求算法的时间复杂度为O(n)，空间复杂度为O(1)。</p><p>输入格式:<br>三行数据，第一行是顺序表的元素个数，第二行是顺序表的元素，第三行是x和y。</p><p>输出格式:<br>删除元素值在[x,y]之间的所有元素后的顺序表。</p><p>输入样例:</p><pre><code>105 1 9 10 67 12 8 33 6 23 10</code></pre><p>输出样例:</p><pre><code>1 67 12 33 2</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *a;    int length;&#125;sqlist;bool create(sqlist &amp;sq)&#123;    sq.a= new int[100];    if(!sq.a) return false;    sq.length=0;    return true;&#125;bool del(sqlist &amp;sq,int x,int y)&#123;    int j,i;    for(j=0;j&lt;sq.length;j++)    &#123;        if(sq.a[j]&gt;=x&amp;&amp;sq.a[j]&lt;=y)        &#123;            for(i=j;i&lt;sq.length;i++)            &#123;                sq.a[i]=sq.a[i+1];            &#125;            sq.length--;            j--;        &#125;    &#125;&#125;int main()&#123;    sqlist List;    int n,i,x,y;    cin&gt;&gt;n;    create(List);    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;List.a[i];        List.length++;    &#125;    cin&gt;&gt;x&gt;&gt;y;    del(List,x,y);    cout&lt;&lt;List.a[0];    for(i=1;i&lt;List.length;i++)    &#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;List.a[i];    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表-顺序表&quot;&gt;&lt;a href=&quot;#线性表-顺序表&quot; class=&quot;headerlink&quot; title=&quot;线性表-顺序表&quot;&gt;&lt;/a&gt;线性表-顺序表&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;h2 id=&quot;创建（初始化）&quot;&gt;&lt;a href=&quot;#创建（</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习-5：string头文件</title>
    <link href="http://example.com/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/"/>
    <id>http://example.com/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/</id>
    <published>2021-03-22T23:41:02.000Z</published>
    <updated>2021-04-16T10:29:01.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：string"><a href="#头文件：string" class="headerlink" title="头文件：string"></a>头文件：string</h1><h2 id="用于简化操作的常用函数"><a href="#用于简化操作的常用函数" class="headerlink" title="用于简化操作的常用函数"></a>用于简化操作的常用函数</h2><ul><li><p>string变量读取单个字符用s[i]可以读出</p></li><li><p>输入带空格的字符串，用getline(cin,a)；(a为字符串类型变量)</p></li><li><p>str.=“”——清空</p></li><li><p>str.empty()——是否为空</p></li><li><p>str.size()——str长度</p></li><li><p>swap(s1，s2)——交换s1，s2</p></li><li><p>str. insert(x,“aaa”)——在下标x处插入aaa</p></li><li><p>str.substr(x,y)——读出下标为x开始长度为y的字符串</p></li><li><p>str.erase(x,y)——移除下标x长度为y的字符</p></li><li><p>str.find(“字符或字符串”)——找str中第一次出现的下标，找不到就是-1</p></li><li><p>while((i=str.find(“a”,i))!=-1) { i++; cout&lt;&lt;i&lt;&lt;endl; }  ——读出所有a字符出现的下标</p><p>  (基本思路是找到一个就从那个下标+1继续找)</p></li><li><p>str.replace(x，y，“aa”)——用aa替换(x，y)(删掉下标x开始长度为y个，在下标为x处插入aa)</p></li></ul><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>string s——生成一个空字符串s</p><p>string s(str) ——拷贝构造函数 生成str的复制品</p><p>string s(str,stridx)——将字符串str内“始于位置stridx”的部分当作字符串的初值</p><p>string s(str,stridx,strlen) ——将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</p><p>string s(cstr) ——将C字符串作为s的初值</p><p>string s(chars,chars_len) ——将C字符串前chars_len个字符作为字符串s的初值。</p><p> string s(num,c) ——生成一个字符串，包含num个c字符</p><p> string s(beg,end) ——以区间beg;end(不包含end)内的字符作为字符串s的初值</p><p>s.~string() ——销毁所有字符，释放内存</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p> =，assign()——赋以新值</p></li><li><p>swap()——交换两个字符串的内容</p></li><li><p>+=，append()，push_back()——在尾部添加字符</p></li><li><p>insert()——插入字符</p></li><li><p>erase()——删除字符</p></li><li><p>clear()——删除全部字符</p></li><li><p>replace()——替换字符</p></li><li><p>+——串联字符串</p></li><li><p>==，!=，&lt;，&lt;=，&gt;，&gt;=，compare()——比较字符串</p></li><li><p>size(),length()——返回字符数量</p></li><li><p>max_size()——返回字符的可能最大个数</p></li><li><p>empty()——判断字符串是否为空</p></li><li><p>capacity()——返回重新分配之前的字符容量</p></li><li><p>reserve()——保留一定量内存以容纳一定数量的字符</p></li><li><p> [ ], at()——存取单一字符</p></li><li><p>“&gt;&gt;”,getline()——从stream读取某值</p></li><li><p>” &lt;&lt;“ ——将谋值写入stream</p></li><li><p>copy()——将某值赋值为一个C_string</p></li><li><p>c_str()——将内容以C_string返回</p></li><li><p> data()——将内容以字符数组形式返回</p></li><li><p>substr()——返回某个子字符串</p></li><li><p>begin() end()——提供类似STL的迭代器支持</p></li><li><p> rbegin() rend()——逆向迭代器</p></li><li><p>get_allocator()——返回配置器</p></li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;头文件：string&quot;&gt;&lt;a href=&quot;#头文件：string&quot; class=&quot;headerlink&quot; title=&quot;头文件：string&quot;&gt;&lt;/a&gt;头文件：string&lt;/h1&gt;&lt;h2 id=&quot;用于简化操作的常用函数&quot;&gt;&lt;a href=&quot;#用于简化操作的常用函</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c++学习" scheme="http://example.com/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习-4：algorithm头文件</title>
    <link href="http://example.com/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://example.com/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-03-19T12:41:02.000Z</published>
    <updated>2021-04-16T10:28:49.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：algorithm"><a href="#头文件：algorithm" class="headerlink" title="头文件：algorithm"></a>头文件：algorithm</h1><p>algorithm意为”算法”,是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><h2 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h2><ol><li><strong>容器</strong> 容器是用来存放各种数据的一个东西，<code>&lt;algorithm&gt;</code>中的算法是针对容器设计的。因此，不论数据是一些<code>int</code>，<code>char</code>还是自定义的<code>class</code>，<code>&lt;algorithm&gt;</code>中的函数都可以正确应对。<code>vector</code>是最常用的容器。</li><li><strong>迭代器</strong> 迭代器是与容器进行配套使用的。它的作用是对容器中的元素进行遍历，比如数组的指针就可以看作一种迭代器。迭代器一般支持解引用（<code>operator*()</code>）、自加（<code>operator++()</code>）、相等（<code>operator==()</code>）等操作。</li><li><strong>谓词</strong> 谓词是用来对<code>&lt;algorithm&gt;</code>中的函数进行定制操作的。谓词可以是lambda表达式或是函数/函数指针，并且<code>&lt;algorithm&gt;</code>中只有一元谓词和二元谓词，即函数只能接收一个或两个参数。对于需要额外参数的谓词可以使用lambda表达式的捕获功能。</li><li><strong><code>pair</code></strong> 部分算法会有两个返回值，<code>pair</code>有两个成员<code>first</code>和<code>second</code>，用来将两个值进行打包返回。</li></ol><h2 id="用到的主要参数说明"><a href="#用到的主要参数说明" class="headerlink" title="用到的主要参数说明"></a>用到的主要参数说明</h2><ul><li><code>beg</code>和<code>end</code>是表示元素范围的迭代器。</li><li><code>beg2</code>是第二个输入序列开始位置的迭代器，<code>end2</code>表示第二个序列末尾位置（如果有的话）。如果没有<code>end2</code>，则假定<code>beg2</code>表示的序列与<code>beg</code>和<code>end</code>表示的序列一样大。<code>beg</code>和<code>beg2</code>不必是相同的类型，但两个序列中的元素都要能调用给定的可调用对像。比如<code>beg</code>是一个<code>std::vector&lt;int&gt;::iterator</code>，而<code>beg2</code>可以是一个<code>std::deque&lt;int&gt;::iterator</code>。</li><li><code>dest</code>是表示目的序列的迭代器，目的序列必须保证能够存储算法生成的所有元素。若无法确定大小，可以调用<code>std::back_inserter()</code>函数获取目的序列的插入迭代器。</li><li><code>unaryPred</code>和<code>binayPred</code>是一元和二元谓词，其实参都是序列中的元素。</li><li><code>comp</code>是一个二元谓词，用于比较两个元素。</li><li><code>unaryOp</code>和<code>binaryOp</code>是可调用对象。</li></ul><p>此外，部分算法要求序列是有序的，默认是使用小于运算符（<code>&lt;</code>）定义的升序。若使用谓词版本，则有序是按<code>comp</code>升序。</p><h2 id="常用函数及用法"><a href="#常用函数及用法" class="headerlink" title="常用函数及用法"></a>常用函数及用法</h2><h3 id="非修改性序列操作（12个）"><a href="#非修改性序列操作（12个）" class="headerlink" title="非修改性序列操作（12个）"></a>非修改性序列操作（12个）</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul><li>对序列中的每个元素执行某操作 for_each()</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>在序列中找出某个值的第一次出现的位置 find()   利用底层元素的等于操作符，对范围内的元素与输入的值进行比较。当匹配时，结束搜索，返回该元素的一个 InputIterator 。</li><li>在序列中找出符合某谓词的第一个元素 find_if()</li><li>在序列中找出一子序列的最后一次出现的位置 find_end()</li><li>在序列中找出第一次出现指定值集中之值的位置 find_first_of()</li><li>在序列中找出相邻的一对值 adjacent_find()</li></ul><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><ul><li>在序列中统计某个值出现的次数 count()</li><li>在序列中统计与某谓词匹配的次数 count_if()</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>找出两个序列相异的第一个元素 mismatch()</li><li>两个序列中的对应元素都相同时为真 equal()</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>在序列中找出一子序列的第一次出现的位置 search()</li><li>在序列中找出一值的连续n次出现的位置 search_n()</li></ul><h3 id="修改性序列操作（27个）"><a href="#修改性序列操作（27个）" class="headerlink" title="修改性序列操作（27个）"></a>修改性序列操作（27个）</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>从序列的第一个元素起进行复制 copy()</li><li>从序列的最后一个元素起进行复制 copy_backward()</li></ul><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul><li>交换两个元素 swap()</li><li>交换指定范围的元素 swap_ranges()</li><li>交换由迭代器所指的两个元素 iter_swap()</li></ul><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><ul><li>将某操作应用于指定范围的每个元素 transform()</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li>用一个给定值替换一些值 replace()</li><li>替换满足谓词的一些元素 replace_if()</li><li>复制序列时用一给定值替换元素 replace_copy()</li><li>复制序列时替换满足谓词的元素 replace_copy_if()</li></ul><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul><li>用一给定值取代所有元素 fill()</li><li>用一给定值取代前n个元素 fill_n()</li></ul><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><ul><li>用一操作的结果取代所有元素 generate()</li><li>用一操作的结果取代前n个元素 generate_n()</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除具有给定值的元素 remove()</li><li>删除满足谓词的元素 remove_if()</li><li>复制序列时删除具有给定值的元素 remove_copy()</li><li>复制序列时删除满足谓词的元素 remove_copy_if()</li></ul><h4 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h4><ul><li>删除相邻的重复元素 unique()</li><li>复制序列时删除相邻的重复元素 unique_copy()</li></ul><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ul><li>反转元素的次序 reverse()</li><li>复制序列时反转元素的次序 reverse_copy()</li></ul><h4 id="环移"><a href="#环移" class="headerlink" title="环移"></a>环移</h4><ul><li>循环移动元素 rotate()</li><li>复制序列时循环移动元素 rotate_copy()</li></ul><h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><ul><li>采用均匀分布来随机移动元素 random_shuffle()</li></ul><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul><li>将满足某谓词的元素都放到前面 partition()</li><li>将满足某谓词的元素都放到前面并维持原顺序 stable_partition()</li></ul><h3 id="序列排序及相关操作（27个）"><a href="#序列排序及相关操作（27个）" class="headerlink" title="序列排序及相关操作（27个）"></a>序列排序及相关操作（27个）</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>以很好的平均效率排序 sort()</li><li>并维持相同元素的原有顺序 stable_sort()</li><li>将序列的前一部分排好序 partial_sort()</li><li>复制的同时将序列的前一部分排好序 partial_sort_copy()</li><li>将第n各元素放到它的正确位置 nth_element()</li></ul><h4 id="二分检索"><a href="#二分检索" class="headerlink" title="二分检索"></a>二分检索</h4><ul><li>找到大于等于某值的第一次出现 lower_bound()</li><li>找到大于某值的第一次出现 upper_bound()</li><li>找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()</li><li>在有序序列中确定给定元素是否存在 binary_search()</li></ul><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><ul><li>归并两个有序序列 merge()</li><li>归并两个接续的有序序列 inplace_merge()</li></ul><h4 id="有序结构上的集合操作"><a href="#有序结构上的集合操作" class="headerlink" title="有序结构上的集合操作"></a>有序结构上的集合操作</h4><ul><li>一序列为另一序列的子序列时为真 includes()</li><li>构造两个集合的有序并集 set_union()</li><li>构造两个集合的有序交集 set_intersection()</li><li>构造两个集合的有序差集 set_difference()</li><li>构造两个集合的有序对称差集（并-交） set_symmetric_difference()</li></ul><h4 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h4><ul><li>向堆中加入元素 push_heap()</li><li>从堆中弹出元素 pop_heap()</li><li>从序列构造堆 make_heap()</li><li>给堆排序 sort_heap()</li></ul><h4 id="最大和最小"><a href="#最大和最小" class="headerlink" title="最大和最小"></a>最大和最小</h4><ul><li>两个值中较小的 min()</li><li>两个值中较大的 max()</li><li>序列中的最小元素 min_element()</li><li>序列中的最大元素 max_element()</li></ul><h4 id="词典比较"><a href="#词典比较" class="headerlink" title="词典比较"></a>词典比较</h4><ul><li>两个序列按字典序的第一个在前 lexicographical_compare()</li></ul><h4 id="排列生成器"><a href="#排列生成器" class="headerlink" title="排列生成器"></a>排列生成器</h4><ul><li>按字典序的下一个排列 next_permutation()</li><li>按字典序的前一个排列 prev_permutation() </li></ul><p>其他详细内容：<a href="https://www.lagou.com/lgeduarticle/9665.html">https://www.lagou.com/lgeduarticle/9665.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;头文件：algorithm&quot;&gt;&lt;a href=&quot;#头文件：algorithm&quot; class=&quot;headerlink&quot; title=&quot;头文件：algorithm&quot;&gt;&lt;/a&gt;头文件：algorithm&lt;/h1&gt;&lt;p&gt;algorithm意为”算法”,是C++的标准模版库</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c++学习" scheme="http://example.com/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页设计学习-1</title>
    <link href="http://example.com/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://example.com/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-03-19T03:02:30.000Z</published>
    <updated>2021-04-12T23:40:58.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;             //编码方式为utf-8        &lt;title&gt;第一个HTML&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;            这是我的第一个html文件        &lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>以上为基本应该存在的结构框架，效果图如下：</p><p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-1/2.png" alt="2"></p><h1 id="文字段落标签"><a href="#文字段落标签" class="headerlink" title="文字段落标签"></a>文字段落标签</h1><h2 id="标题与段落标签"><a href="#标题与段落标签" class="headerlink" title="标题与段落标签"></a>标题与段落标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><pre><code class="html">&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt; //从左到右重要性递减    &lt;hn align=&quot;对齐方式&quot;&gt;标题内容&lt;/hn&gt;</code></pre><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><pre><code class="html">&lt;p align=&quot;对齐方式&quot;&gt;段落文本&lt;/p&gt;</code></pre><h3 id="水平分割线标签"><a href="#水平分割线标签" class="headerlink" title="水平分割线标签"></a>水平分割线标签</h3><pre><code class="html">&lt;hr 属性=&quot;属性值&quot;/&gt;//size设置粗细，align对齐方式，width设置宽度，color设置颜色，noshade设置3d阴影</code></pre><h3 id="换行缩进标签"><a href="#换行缩进标签" class="headerlink" title="换行缩进标签"></a>换行缩进标签</h3><pre><code class="html">&lt;br/&gt;                        //强制换行&lt;blockquote&gt;&lt;/blockquote&gt;   //缩进</code></pre><h2 id="文本的格式化标签"><a href="#文本的格式化标签" class="headerlink" title="文本的格式化标签"></a>文本的格式化标签</h2><pre><code class="html">&lt;b&gt;&lt;/b&gt;                        //粗体&lt;strong&gt;&lt;/strong&gt;            //强调，一般为粗体&lt;i&gt;&lt;/i&gt;                        //斜体&lt;em&gt;&lt;/em&gt;                    //强调，一般为斜体&lt;del&gt;&lt;/del&gt;                    //删除线&lt;ins&gt;&lt;/ins&gt;                    //加下划线&lt;sup&gt;&lt;/sup&gt;                    //上标&lt;sub&gt;&lt;/sub&gt;                    //下标</code></pre><h2 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h2><table><thead><tr><th>特殊字符</th><th>字符代码</th><th>特殊字符</th><th>字符代码</th></tr></thead><tbody><tr><td>空格</td><td>&amp;nbsp；</td><td>“</td><td>&amp;quot；</td></tr><tr><td>&lt;</td><td>&amp;lt；</td><td>©</td><td>&amp;copy；</td></tr><tr><td>&gt;</td><td>&amp;gt；</td><td>®</td><td>&amp;reg；</td></tr><tr><td>&amp;</td><td>&amp;amp；</td><td>×</td><td>&amp;times；</td></tr></tbody></table><h1 id="图像与超链接标签"><a href="#图像与超链接标签" class="headerlink" title="图像与超链接标签"></a>图像与超链接标签</h1><h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><pre><code class="html">&lt;img src=&quot;图像URL&quot;/&gt;</code></pre><h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><h3 id="创建超链接"><a href="#创建超链接" class="headerlink" title="创建超链接"></a>创建超链接</h3><pre><code class="html">&lt;a href=&quot;资源地址&quot; target=&quot;窗口名称&quot; title=&quot;链接提示&quot;&gt;链接对象&lt;/a&gt;</code></pre><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ol><li>绝对路径：网络主页上所存在的，或是文件在硬盘上的真实路径。</li><li>相对路径：以当前文件为起点，进行相对文件的查找。</li></ol><pre><code class="html">./          //指当前文件所在目录下（可省略）../         //指当前文件所在目录的上一目录下</code></pre><h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>锚点定义：</p><pre><code class="html">&lt;a name=&quot;锚点名称&quot;&gt;文字&lt;/a&gt;//或将name改做id</code></pre><p>跳转锚点：</p><pre><code class="html">&lt;a href=&quot;锚点名称&quot;&gt;链接的文字&lt;/a&gt;</code></pre><h3 id="影像地图"><a href="#影像地图" class="headerlink" title="影像地图"></a>影像地图</h3><pre><code class="html">&lt;img src=&quot;图像地址&quot; usemap=&quot;#影像地图名称&quot;&gt;   //使用影像地图&lt;map name=&quot;影像地图名称&quot;&gt;                      //定义影像地图    &lt;area shape=&quot;热区形状&quot; coords=&quot;热区坐标&quot; href=&quot;链接地址&quot;&gt;    &lt;!--此处可以添加多个area--&gt;&lt;/map&gt;</code></pre><p><strong>shape与coords的附加说明：</strong></p><ul><li>shape=”circle“，coords=”x,y,z“（x,y定义圆心位置，z为半径)</li><li>shape=“polygon”，coords=“x1,y1,x2,y2……”（每个顶点的坐标都要写入）</li><li>shape=“rectangle”，coords=“x1,y1,x2,y2”（一个顶点的坐标和其对角顶点坐标）</li></ul><h1 id="表格与列表标签"><a href="#表格与列表标签" class="headerlink" title="表格与列表标签"></a>表格与列表标签</h1><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格的定义范例"><a href="#表格的定义范例" class="headerlink" title="表格的定义范例"></a><strong>表格的定义范例</strong></h3><pre><code class="html">&lt;table&gt;    &lt;tr&gt;                                //表格的第一个横行        &lt;th&gt;此处表头字体自动加粗&lt;/th&gt;         //具体到行内的一个单元格        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;                                //表格的第二个横行        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><pre><code class="html">&lt;caption&gt;定义表格的标题&lt;/caption&gt;&lt;thead&gt;定义表格的表头&lt;/thead&gt;&lt;tbody&gt;对表格中的主体内容进行分组&lt;/tbody&gt;&lt;tfoot&gt;对表格中的页脚内容进行分组&lt;/tfoot&gt;// 后三个标签应该结合使用</code></pre><h3 id="表格标签”table”的属性："><a href="#表格标签”table”的属性：" class="headerlink" title="表格标签”table”的属性："></a><strong>表格标签”table”的属性：</strong></h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>width/height</td><td>表格的宽度（高度），值可以是数值或百分比，数值表示像素点数，百分比是占浏览器宽度（高度）的比例</td></tr><tr><td>align</td><td>表格相对周围元素的对齐方式</td></tr><tr><td>background</td><td>表格的背景图片</td></tr><tr><td>bgcolor</td><td>表格的背景颜色，一般后期通过样式控制，不建议使用</td></tr><tr><td>border</td><td>表格边框宽度（像素为单位）</td></tr><tr><td>bordercolor</td><td>表格边框的颜色</td></tr><tr><td>cellspacing</td><td>单元格之间的间距</td></tr><tr><td>cellpadding</td><td>单元格内容与边界之间空白距离的大小</td></tr></tbody></table><h3 id="表格设置border时，可以设置显示隐藏边框"><a href="#表格设置border时，可以设置显示隐藏边框" class="headerlink" title="表格设置border时，可以设置显示隐藏边框"></a><strong>表格设置border时，可以设置显示隐藏边框</strong></h3><table><thead><tr><th>frame</th><th>描述</th><th>frame</th><th>描述</th></tr></thead><tbody><tr><td>box</td><td>显示所有边框</td><td>alove</td><td>只显示上边框</td></tr><tr><td>void</td><td>不显示边框</td><td>below</td><td>只显示下边框</td></tr><tr><td>hsides</td><td>只显示上下边框</td><td>lhs</td><td>只显示左边框</td></tr><tr><td>vsides</td><td>只显示左右边框</td><td>rhs</td><td>只显示右边框</td></tr></tbody></table><h3 id="单元格td的设置"><a href="#单元格td的设置" class="headerlink" title="单元格td的设置"></a><strong>单元格td的设置</strong></h3><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>width/height</td><td>单元格的宽和高，接受绝对值和相对值</td><td>align</td><td>单元格内容的水平对齐方式（left、right、center等）</td></tr><tr><td>colspan</td><td>规定单元格横跨列数（纵向合并单元格）</td><td>valign</td><td>单元格内容的垂直对齐方式（top、middle、bottom等）</td></tr><tr><td>rowspan</td><td>规定单元格横跨行数（横向合并单元格）</td><td>bgcolor</td><td>单元格的背景色</td></tr></tbody></table><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul><li><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">&lt;ul type=编号类型&gt;    &lt;li&gt;第一项&lt;/li&gt;    &lt;li&gt;第二项&lt;/li&gt;    &lt;li&gt;第三项&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>type决定列表图标类型：</strong></p><ul><li><p>disc为实心圆（默认）</p></li><li><p>circle为空心圆</p></li><li><p>square为方块</p></li></ul></li></ul><ul><li><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">&lt;ol type=&quot;编号类型&quot; start=value&gt;    &lt;li&gt;第一项&lt;/li&gt;    &lt;li&gt;第二项&lt;/li&gt;    &lt;li&gt;第三项&lt;/li&gt;&lt;/ol&gt;</code></pre><p><strong>type决定列表序号样式：</strong></p><ul><li><strong>type=1：</strong>1,2,3,4,5……</li><li><strong>type=A：</strong>A,B,C,D,E……</li><li><strong>type=a：</strong>a,b,c,d,e……</li><li><strong>type=I：</strong>I,II,III,IV,V……</li><li><strong>type=i：</strong>i,ii,iii,iv,v……</li></ul><p><strong>reversed属性为true时，可以实现倒序排列，start指定第一项的序号</strong></p></li></ul><ul><li><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3></li></ul><pre><code class="html">&lt;dl&gt;    &lt;dt&gt;第一项&lt;/dt&gt;&lt;dd&gt;注释一&lt;/dd&gt;    &lt;dt&gt;第二项&lt;/dt&gt;&lt;dd&gt;注释二&lt;/dd&gt;    &lt;dt&gt;第三项&lt;/dt&gt;&lt;dd&gt;注释三&lt;/dd&gt;&lt;/dl&gt;</code></pre><ul><li><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3></li></ul><pre><code class="html">&lt;ul type=&quot;circle&quot;&gt;    &lt;li&gt;北京&lt;/li&gt;    &lt;li&gt;上海        &lt;ol start=&quot;6&quot; type=&quot;1&quot; reversed=&quot;true&quot;&gt;        &lt;li&gt;浦东新区&lt;/li&gt;        &lt;li&gt;徐汇区&lt;/li&gt;        &lt;li&gt;长宁区&lt;/li&gt;        &lt;li&gt;普陀区&lt;/li&gt;        &lt;/ol&gt;    &lt;/li&gt;    &lt;li&gt;广州&lt;/li&gt;    &lt;li&gt;深圳&lt;/li&gt;&lt;/ul&gt;</code></pre><p>以上代码为无序列表嵌套有序列表，效果图如下</p><p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构标签&quot;&gt;&lt;a href=&quot;#结构标签&quot; class=&quot;headerlink&quot; title=&quot;结构标签&quot;&gt;&lt;/a&gt;结构标签&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;l</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计学习" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-4</title>
    <link href="http://example.com/2021/02/19/Linux%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://example.com/2021/02/19/Linux%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-02-19T11:33:01.000Z</published>
    <updated>2021-04-16T10:32:15.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令大全："><a href="#常用命令大全：" class="headerlink" title="常用命令大全："></a>常用命令大全：</h1><h2 id="日常使用命令"><a href="#日常使用命令" class="headerlink" title="日常使用命令"></a>日常使用命令</h2><p>开关机命令<br>1、shutdown –h now：立刻进行关机</p><p>2、shutdown –r now：现在重新启动计算机</p><p>3、reboot：现在重新启动计算机</p><p>4、su -：切换用户；passwd：修改用户密码</p><p>5、logout：用户注销</p><h2 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h2><p>1、tab = 补全</p><p>2、ctrl + l -：清屏，类似clear命令</p><p>3、ctrl + r -：查找历史命令（history）；ctrl+c = 终止</p><p>4、ctrl+k = 删除此处至末尾所有内容</p><p>5、ctrl+u = 删除此处至开始所有内容</p><p>6、linux中的帮助命令：man、info、–help【[root@localhost ~]# man ls；[root@localhost ~]# info ls；[root@localhost ~]# ls –help】。退出帮助的话，按快捷键q</p><h2 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h2><p>1、ls</p><p>ls命令是列出目录内容的意思（List Directtory Contents）。运行它就是列出文件夹的内容，可能是文件也可能是文件夹。</p><p>  ls -l命令以详情模式(long listing fashion)列出文件夹的内容。</p><p>  ls -a命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件。</p><p>  注意：在Linux中，文件以“.”开头就是隐藏文件，并且每个文件，文件夹，设备或者命令都是以文件对待。</p><p>  2、lsblk</p><p>  lsblk就是列出块设备。除了RAM外，以标准的树状输出格式，整齐地显示块设备。</p><p>  lsblk -l命令以列表格式显示块设备(而不是树状格式)。</p><p>  注意：lsblk是最有用和最简单的方式来了解新插入的USB设备的名字，特别是当你在终端上处理磁盘/块设备时。</p><p>  3、uname</p><p>  “uname”命令就是Unix Name的简写。显示机器名，操作系统和内核的详细信息。</p><p>  注意：uname显示内核类别，uname -a显示详细信息。</p><p>  4、history</p><p>  “history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史。</p><p>  5、sudo</p><p>  “sudo”(super userdo)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p><p>  注意：sudo允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。</p><p>  并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事。</p><p>  6、chmod</p><p>  “chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p><p>  7、chown</p><p>  “chown”命令就是改变文件拥有者和所在用户组。每个文件都属于一个用户组和一个用户。在你的目录下，使用”ls -l”,你就会看到像这样的东西。</p><p>  8、apt</p><p>  Debian系列以“apt”命令为基础，“apt”代表了Advanced Package Tool。APT是一个为Debian系列系统（Ubuntu，Kubuntu等等）开发的高级包管理器，在Gnu/Linux系统上，它会为包自动地，智能地搜索，安装，升级以及解决依赖。例如：apt-get install mplayer</p><p>  9、cal</p><p>  “cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份。</p><p>  10、date</p><p>  “date”命令使用标准的输出打印当前的日期和时间，也可以深入设置。</p><h3 id="系统常用操作命令"><a href="#系统常用操作命令" class="headerlink" title="系统常用操作命令"></a>系统常用操作命令</h3><h4 id="1、指定运行级别"><a href="#1、指定运行级别" class="headerlink" title="1、指定运行级别"></a>1、指定运行级别</h4><p>命令：init[0123456]</p><p>运行级别：（0：关机；1：单用户；2：多用户状态没有网络服务；3：多用户状态有网络服务；4：系统未使用保留给用户；5：图形界面；6：系统重启）。</p><p> 常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab的id:5:inittab：这一行的数字。</p><p> 在启动引导界面的时候按e进入编辑，在进入grub引界面时，请输入e再选中第二个选项按e，再最后输入1[单用户级别]，然后按b进入单用户模式。</p><p> *：可通过此方法进行linux用户密码的修改。</p><h4 id="2、文件显示命令"><a href="#2、文件显示命令" class="headerlink" title="2、文件显示命令"></a>2、文件显示命令</h4><p>more：显示文件内容，带分页；</p><p>less：显示文件内容带分页；</p><p> grep：在文件中查询内容，grep –n “查找内容” 文件名；</p><p> | [管道命令]：在linux和unix系统中 | 就是管道命令，把上一个命令的结果交给 | 的后面的命令进行处理。</p><p> 例：grep –n “查找内容” 文件名 | more</p><p> cat：把文件串连接后输出到屏幕或加 &gt; fileName 到另一个档案。</p><p> head：格式：head [-n|c num]fileName，说明：显示文件头部内容。没有参数时，显示最前10行。</p><p> tail：格式：tail [-n|c num]fileName，说明：显示文件尾部内容。没有参数时，显示最后10行。</p><p> cut：格式：cut -cnum1-num2 filename，说明：显示每行从开头算起第 num1 到 num2 的字符。</p><h4 id="3、文件搜索命令find"><a href="#3、文件搜索命令find" class="headerlink" title="3、文件搜索命令find"></a>3、文件搜索命令find</h4><p>find：搜索文件及目录</p><p>在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而find命令可以解决上述问题。</p><p>  1、在特定的目录下搜索并显示指定名称的文件和目录。</p><p>  find / -name man：意思是说从根目录开始搜索名称为man的文件或目录。</p><p>  2、搜索一段时间内被存取/变更的文件或目录</p><p>  find / home–amin -10：十分钟内存取的文件或目录</p><p>  find / home–atime -10：十小时内存取的文件或目录</p><p>  find / home–cmin -10：十分钟内更改过的文件或目录</p><p>  find / home–ctime -10：十小时内更改过的文件或目录</p><p>  3、搜索指定大小的文件</p><p>  find / home–size +10k：意思是说查找/home目录下大小为10K的文件。</p><h4 id="4、重定向命令"><a href="#4、重定向命令" class="headerlink" title="4、重定向命令"></a>4、重定向命令</h4><p>重定向命令：管道定向命令“&gt;”为覆盖，“&gt;&gt;”追加写在原文件内容后面。</p><p>ls –l &gt;a.txt 列表的内容写入文件a.txt中（覆盖写）。</p><p>  ls –al&gt;&gt; aa.txt 列表的内容追加到文件aa.txt的末尾。</p><h4 id="5、其他命令"><a href="#5、其他命令" class="headerlink" title="5、其他命令"></a>5、其他命令</h4><p>who：格式：who - [husfV] [user]。说明：显示有哪些用户登录到系统中，显示的信息包含用户ID，使用的终端，上线时间，呆滞时间，CPU使用量，动作等等。相关命令 : who am i：显示当前用户是谁。</p><p>sleep：格式：sleep [–help] [–version] number[smhd]。说明 : sleep 可以用来将当前动作延迟一段时间。</p><p>  kill：格式：kill [ -s signal ] pid … 或 kill -l [ signal ]。说明：kill送出一个特定的信号 (signal) 给进程号为 pid 的进程。根据该信号而做特定的动作，若没有指定，默认是送出终止(TERM)信号。</p><p>  ps：格式：ps [options] [–help]。说明：显示进程的名称、占用资源、状态等。</p><p>  top：说明：显示CPU的使用率、内存大小、内存使用率、进程状态等。</p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd … 返回上一级目录<br>cd …/… 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’ I n s t a l l e d − S i z e ; 10 t {Installed-Size;10}t Installed−Size;10t{Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><p><strong>使用 “+” 设置权限，使用 “-” 用于取消</strong></p><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位</p><p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-” 用于取消<br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性</p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 49: …所有空白行 sed ‘/ *#̲/d; /^/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode …HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令大全：&quot;&gt;&lt;a href=&quot;#常用命令大全：&quot; class=&quot;headerlink&quot; title=&quot;常用命令大全：&quot;&gt;&lt;/a&gt;常用命令大全：&lt;/h1&gt;&lt;h2 id=&quot;日常使用命令&quot;&gt;&lt;a href=&quot;#日常使用命令&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-3</title>
    <link href="http://example.com/2021/02/10/Linux%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://example.com/2021/02/10/Linux%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-02-10T10:29:59.000Z</published>
    <updated>2021-04-16T10:32:00.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>/</strong> 写起，例如： /usr/share/doc 这个目录。</p></li><li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>/</strong> 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： <strong>cd ../man</strong> 这就是相对路径的写法。</p></li></ul><hr><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将家目录下的所有文件列出来(含属性与隐藏档)</p><pre><code>[root@www ~]# ls -al ~</code></pre><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code> cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..</code></pre><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@www ~]# pwd [-P]</code></pre><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><pre><code>[root@www ~]# pwd/root   &lt;== 显示出目录啦～</code></pre><p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p><pre><code>[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到/tmp底下尝试创建数个新目录看看：</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#39;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><pre><code>[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><pre><code> rmdir [-p] 目录名称</code></pre><p>选项与参数：</p><ul><li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li></ul><p>删除 runoob 目录</p><pre><code>[root@www tmp]# rmdir runoob/</code></pre><p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p><pre><code>[root@www tmp]# ls -l   &lt;==看看有多少目录存在？drwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#39;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><pre><code>[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#39;? n  &lt;==n不覆盖，y为覆盖</code></pre><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><pre><code> rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><pre><code>[root@www tmp]# rm -i bashrcrm: remove regular file `bashrc&#39;? y</code></pre><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><pre><code>[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><pre><code>[root@www tmp]# mv mvtest mvtest2</code></pre><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><pre><code>cat [-AbEnTv]</code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 /etc/issue 这个文件的内容：</p><pre><code>[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \r on an \m</code></pre><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code>[root@www ~]# tac /etc/issueKernel \r on an \mCentOS release 6.4 (Final)</code></pre><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><pre><code>nl [-bnw] 文件</code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 /etc/issue 的内容</p><pre><code>[root@www ~]# nl /etc/issue     1  CentOS release 6.4 (Final)     2  Kernel \r on an \m</code></pre><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><pre><code>[root@www ~]# more /etc/man_db.config ## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....--More--(28%)  &lt;== </code></pre><p>在 more 这个程序的运行过程中：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p><pre><code>[root@www ~]# less /etc/man.config## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....:   &lt;== 这里可以等待你输入命令！</code></pre><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><pre><code>head [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><pre><code>[root@www ~]# head /etc/man.config</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre><code>[root@www ~]# head -n 20 /etc/man.config</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><pre><code>tail [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><pre><code>[root@www ~]# tail /etc/man.config# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：[root@www ~]# tail -n 20 /etc/man.config</code></pre><h2 id="Linux-链接概念"><a href="#Linux-链接概念" class="headerlink" title="Linux 链接概念"></a>Linux 链接概念</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，<strong>ln</strong> 命令产生硬链接。</p><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a><strong>硬连接</strong></h3><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a><strong>软连接</strong></h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><h3 id="可以得到以下全部结论："><a href="#可以得到以下全部结论：" class="headerlink" title="可以得到以下全部结论："></a>可以得到以下全部结论：</h3><p>1).删除符号连接f3,对f1,f2无影响</p><p>2).删除硬连接f2，对f1,f3也无影响</p><p>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效</p><p> 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-文件与目录管理&quot;&gt;&lt;a href=&quot;#Linux-文件与目录管理&quot; class=&quot;headerlink&quot; title=&quot;Linux 文件与目录管理&quot;&gt;&lt;/a&gt;Linux 文件与目录管理&lt;/h1&gt;&lt;p&gt;我们知道Linux的目录结构为树状结构，最顶级的目录</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-2</title>
    <link href="http://example.com/2021/02/09/Linux%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://example.com/2021/02/09/Linux%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2021-02-09T11:29:59.000Z</published>
    <updated>2021-04-16T10:30:48.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-远程登录"><a href="#Linux-远程登录" class="headerlink" title="Linux 远程登录"></a>Linux 远程登录</h1><p>Linux 一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的 Linux 服务器。</p><p>这时我们就需要远程登录到Linux服务器来管理维护系统。</p><p>Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22。</p><p>Window 系统上 Linux 远程登录客户端有 SecureCRT, Putty, SSH Secure Shell 等</p><h2 id="使用密钥认证机制远程登录linux"><a href="#使用密钥认证机制远程登录linux" class="headerlink" title="使用密钥认证机制远程登录linux"></a>使用密钥认证机制远程登录linux</h2><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。</p><p>SSH 为建立在应用层和传输层基础上的安全协议。</p><p>该工具可以生成三种格式的key ：SSH-1(RSA) SSH-2(RSA) SSH-2(DSA) ，我们采用默认的格式即 SSH-2(RSA)。Number of bits in a generated key 这个是指生成的key的大小，这个数值越大，生成的key就越复杂，安全性就越高。</p><h3 id="1）创建目录-root-ssh-并设置权限"><a href="#1）创建目录-root-ssh-并设置权限" class="headerlink" title="1）创建目录 /root/.ssh 并设置权限"></a>1）创建目录 /root/.ssh 并设置权限</h3><p>[root@localhost ~]# mkdir /root/.ssh mkdir 命令用来创建目录，以后会详细介绍，暂时只了解即可。</p><p>[root@localhost ~]# chmod 700 /root/.ssh chmod 命令是用来修改文件属性权限的，以后会详细介绍。</p><h3 id="2）创建文件-root-ssh-authorized-keys"><a href="#2）创建文件-root-ssh-authorized-keys" class="headerlink" title="2）创建文件 / root/.ssh/authorized_keys"></a>2）创建文件 / root/.ssh/authorized_keys</h3><p>[root@localhost ~]# vim /root/.ssh/authorized_keys vim 命令是编辑一个文本文件的命令，同样在后续章节详细介绍。</p><h3 id="3）打开刚才生成的public-key-文件"><a href="#3）打开刚才生成的public-key-文件" class="headerlink" title="3）打开刚才生成的public key 文件"></a>3）打开刚才生成的public key 文件</h3><p>建议使用写字板打开，这样看着舒服一些，复制从AAAA开头至 “—- END SSH2 PUBLIC KEY —-“ 该行上的所有内容，粘贴到/root/.ssh/authorized_keys 文件中，要保证所有字符在一行。（可以先把复制的内容拷贝至记事本，然后编辑成一行载粘贴到该文件中）。</p><p>在这里要简单介绍一下，如何粘贴，用vim打开那个文件后，该文件不存在，所以vim会自动创建。按一下字母”i”然后同时按shift + Insert 进行粘贴（或者单击鼠标右键即可），前提是已经复制到剪切板中了。粘贴好后，然后把光标移动到该行最前面输入 <strong>ssh-rsa</strong> </p><h3 id="4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth"><a href="#4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth" class="headerlink" title="4）再设置putty选项，点窗口左侧的SSh –&gt; Auth"></a>4）再设置putty选项，点窗口左侧的SSh –&gt; Auth</h3><p>单击窗口右侧的Browse… 选择刚刚生成的私钥， 再点Open ，此时输入root，就不用输入密码就能登录了。</p><p>如果在前面你设置了Key Passphrase ，那么此时就会提示你输入密码的。为了更加安全建议大家要设置一个Key Passphrase。</p><h2 id="终端利用ssh登录远程服务器"><a href="#终端利用ssh登录远程服务器" class="headerlink" title="终端利用ssh登录远程服务器"></a><strong>终端利用ssh登录远程服务器</strong></h2><p>安装ssh：</p><pre><code>yum install ssh</code></pre><p>启动ssh：</p><pre><code>service sshd start</code></pre><p>登录远程服务器：</p><pre><code>ssh -p 50022 my@127.0.0.1输入密码：my@127.0.0.1:</code></pre><p><strong>-p</strong> 后面是端口</p><p><strong>my</strong> 是服务器用户名</p><p><strong>127.0.0.1</strong> 是服务器 ip</p><p>回车输入密码即可登录</p><h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p><p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change ownerp) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p><pre><code>[root@www /]# ls -ltotal 64dr-xr-xr-x   2 root root 4096 Dec 14  2012 bindr-xr-xr-x   4 root root 4096 Apr 19  2012 boot……</code></pre><p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p><p><img src="/2021/02/09/Linux%E5%AD%A6%E4%B9%A0-2/pic-2.png" alt="pic-2"></p><p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p><p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p><p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p><h1 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h1><pre><code>[root@www /]# ls -ltotal 64drwxr-xr-x 2 root  root  4096 Feb 15 14:46 crondrwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql……</code></pre><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h3><p>Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。</p><p>与 chown的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><h4 id="语法1："><a href="#语法1：" class="headerlink" title="语法1："></a>语法1：</h4><pre><code>chgrp [-R] 属组名 文件名</code></pre><h4 id="参数选项："><a href="#参数选项：" class="headerlink" title="参数选项："></a>参数选项：</h4><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h4 id="语法2："><a href="#语法2：" class="headerlink" title="语法2："></a>语法2：</h4><pre><code>chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</code></pre><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p><p>　　-f或–quiet或–silent 　不显示错误信息。</p><p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p><p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p><p>　　-v或–verbose 　显示指令执行过程。</p><p>　　–help 　在线帮助。</p><p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p><p>　　–version 　显示版本信息。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="实例1：改变文件的群组属性："><a href="#实例1：改变文件的群组属性：" class="headerlink" title="实例1：改变文件的群组属性："></a>实例1：改变文件的群组属性：</h5><pre><code>chgrp -v bin log2012.log</code></pre><p>输出：</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log</code></pre><p>“log2012.log” 的所属组已更改为 bin</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</code></pre><p>说明： 将log2012.log文件由root群组改为bin群组</p><h5 id="实例2：根据指定文件改变文件的群组属性"><a href="#实例2：根据指定文件改变文件的群组属性" class="headerlink" title="实例2：根据指定文件改变文件的群组属性"></a>实例2：根据指定文件改变文件的群组属性</h5><pre><code>chgrp --reference=log2012.log log2013.log</code></pre><p>输出：</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log[root@localhost test]#  chgrp --reference=log2012.log log2013.log [root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</code></pre><p>说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p><h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>Linux chown（英文全拼：<strong>change owner</strong>）命令用于设置文件所有者和文件关联组的命令。</p><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 </p><p>只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 chgrp 命令。</p><h4 id="语法1：-1"><a href="#语法1：-1" class="headerlink" title="语法1："></a>语法1：</h4><pre><code>chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名</code></pre><h4 id="语法2：-1"><a href="#语法2：-1" class="headerlink" title="语法2："></a>语法2：</h4><pre><code>chown [-cfhvR] [--help] [--version] user[:group] file...</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数 :"></a><strong>参数</strong> :</h4><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li><li>-c : 显示更改的部分的信息</li><li>-f : 忽略错误信息</li><li>-h :修复符号链接</li><li>-v : 显示详细的处理信息</li><li>-R : 处理指定目录以及其子目录下的所有文件</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>把 /var/run/httpd.pid 的所有者设置 root：</p><pre><code>chown root /var/run/httpd.pid</code></pre><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p><pre><code>chown runoob:runoobgroup file1.txt</code></pre><p>将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p><pre><code>chown -R runoob:runoobgroup *</code></pre><p>把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者：</p><pre><code>chown :512 /home/runoob</code></pre><p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p><pre><code>[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre><p>将install.log的拥有者与群组改回为root：</p><pre><code>[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre><h3 id="3、chmod：更改文件9个属性"><a href="#3、chmod：更改文件9个属性" class="headerlink" title="3、chmod：更改文件9个属性"></a>3、chmod：更改文件9个属性</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><pre><code>chmod [-cfvR] [--help] [--version] mode file...</code></pre><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>mode : 权限设定字串，格式如下 :</p><pre><code>[ugoa...][[+-=][rwxX]...][,...]</code></pre><h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul><h4 id="其他参数说明："><a href="#其他参数说明：" class="headerlink" title="其他参数说明："></a>其他参数说明：</h4><ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作</li><li>-f : 若该文件权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><h4 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h4><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p><table><thead><tr><th align="left">who</th><th align="left">用户类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>u</code></td><td align="left">user</td><td align="left">文件所有者</td></tr><tr><td align="left"><code>g</code></td><td align="left">group</td><td align="left">文件所有者所在组</td></tr><tr><td align="left"><code>o</code></td><td align="left">others</td><td align="left">所有其他用户</td></tr><tr><td align="left"><code>a</code></td><td align="left">all</td><td align="left">所用用户, 相当于 <em>ugo</em></td></tr></tbody></table><h5 id="operator-的符号模式表"><a href="#operator-的符号模式表" class="headerlink" title="operator 的符号模式表:"></a>operator 的符号模式表:</h5><table><thead><tr><th align="left">Operator</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">为指定的用户类型增加权限</td></tr><tr><td align="left"><code>-</code></td><td align="left">去除指定用户类型的权限</td></tr><tr><td align="left"><code>=</code></td><td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table><h5 id="permission-的符号模式表"><a href="#permission-的符号模式表" class="headerlink" title="permission 的符号模式表:"></a>permission 的符号模式表:</h5><table><thead><tr><th align="left">模式</th><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td align="left">读</td><td align="left">设置为可读权限</td></tr><tr><td align="left"><code>w</code></td><td align="left">写</td><td align="left">设置为可写权限</td></tr><tr><td align="left"><code>x</code></td><td align="left">执行权限</td><td align="left">设置为可执行权限</td></tr><tr><td align="left"><code>X</code></td><td align="left">特殊执行权限</td><td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td align="left"><code>s</code></td><td align="left">setuid/gid</td><td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td align="left"><code>t</code></td><td align="left">粘贴位</td><td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table><h4 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h4><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><table><thead><tr><th align="left">#</th><th align="left">权限</th><th align="left">rwx</th><th align="left">二进制</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">读 + 写 + 执行</td><td align="left">rwx</td><td align="left">111</td></tr><tr><td align="left">6</td><td align="left">读 + 写</td><td align="left">rw-</td><td align="left">110</td></tr><tr><td align="left">5</td><td align="left">读 + 执行</td><td align="left">r-x</td><td align="left">101</td></tr><tr><td align="left">4</td><td align="left">只读</td><td align="left">r–</td><td align="left">100</td></tr><tr><td align="left">3</td><td align="left">写 + 执行</td><td align="left">-wx</td><td align="left">011</td></tr><tr><td align="left">2</td><td align="left">只写</td><td align="left">-w-</td><td align="left">010</td></tr><tr><td align="left">1</td><td align="left">只执行</td><td align="left">–x</td><td align="left">001</td></tr><tr><td align="left">0</td><td align="left">无</td><td align="left">—</td><td align="left">000</td></tr></tbody></table><p>例如， 765 将这样解释：</p><ul><li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li><li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li><li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li></ul><h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h4><p>将文件 file1.txt 设为所有人皆可读取 :</p><pre><code>chmod ugo+r file1.txt</code></pre><p>将文件 file1.txt 设为所有人皆可读取 :</p><pre><code>chmod a+r file1.txt</code></pre><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><pre><code>chmod ug+w,o-w file1.txt file2.txt</code></pre><p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p><pre><code>chmod u+x ex1.py</code></pre><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><pre><code>chmod -R a+r *</code></pre><p>此外chmod也可以用数字来表示权限如 :</p><pre><code>chmod 777 file</code></pre><p>语法为：</p><pre><code>chmod abc file</code></pre><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p>r=4，w=2，x=1</p><ul><li>若要 rwx 属性则 4+2+1=7；</li><li>若要 rw- 属性则 4+2=6；</li><li>若要 r-x 属性则 4+1=5。</li></ul><pre><code>chmod a=rwx file</code></pre><p>和</p><pre><code>chmod 777 file</code></pre><p>效果相同</p><pre><code>chmod ug=rwx,o=x file</code></pre><p>和</p><pre><code>chmod 771 file</code></pre><p>效果相同</p><p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p><h4 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h4><table><thead><tr><th align="left"><code>命令</code></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>chmod a+r *file*</code></td><td align="left">给file的所有用户增加读权限</td></tr><tr><td align="left"><code>chmod a-x *file*</code></td><td align="left">删除file的所有用户的执行权限</td></tr><tr><td align="left"><code>chmod a+rw *file*</code></td><td align="left">给file的所有用户增加读写权限</td></tr><tr><td align="left"><code>chmod +rwx *file*</code></td><td align="left">给file的所有用户增加读写执行权限</td></tr><tr><td align="left"><code>chmod u=rw,go= *file*</code></td><td align="left">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td></tr><tr><td align="left"><code>chmod -R u+r,go-r *docs*</code></td><td align="left">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td></tr><tr><td align="left"><code>chmod 664 *file*</code></td><td align="left">对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td></tr><tr><td align="left"><code>chmod 0755 *file*</code></td><td align="left">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code> 没有特殊模式。</td></tr><tr><td align="left"><code>chmod 4755 *file*</code></td><td align="left"><code>4</code>设置了设置<a href="https://www.runoob.com/wiki/%E7%94%A8%E6%88%B7ID">用户ID</a>位，剩下的相当于 u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)。</td></tr><tr><td align="left"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td><td align="left">删除可执行权限对path/以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td></tr><tr><td align="left"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td><td align="left">允许所有用户浏览或通过目录path/</td></tr></tbody></table><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux 文件的基本权限就有九个，分别是 <strong>owner/group/others(拥有者/组/其他)</strong> 三种身份各有自己的 <strong>read/write/execute</strong> 权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—</strong> 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p><pre><code> chmod [-R] xyz 文件或目录</code></pre><p>选项与参数：</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</p><pre><code>[root@www ~]# ls -al .bashrc-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc[root@www ~]# chmod 777 .bashrc[root@www ~]# ls -al .bashrc-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre><p>那如果要将权限变成 <em>-rwxr-xr–</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。</p><h4 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h4><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>user：用户</li><li>group：组</li><li>others：其他</li></ul><p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p><p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p><table><thead><tr><th>chmod</th><th>u g o a</th><th>+(加入) -(除去) =(设定)</th><th>r w x</th><th>文件或目录</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 <strong>chmod u=rwx,g=rx,o=r 文件名</strong> 来设定:</p><pre><code>#  touch test1    // 创建 test1 文件# ls -al test1    // 查看 test1 默认权限-rw-r--r-- 1 root root 0 Nov 15 10:32 test1# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限# ls -al test1-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre><p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p><pre><code>#  chmod  a-x test1# ls -al test1-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-远程登录&quot;&gt;&lt;a href=&quot;#Linux-远程登录&quot; class=&quot;headerlink&quot; title=&quot;Linux 远程登录&quot;&gt;&lt;/a&gt;Linux 远程登录&lt;/h1&gt;&lt;p&gt;Linux 一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-1</title>
    <link href="http://example.com/2021/01/26/Linux%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://example.com/2021/01/26/Linux%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-01-26T01:38:45.000Z</published>
    <updated>2021-04-20T12:33:50.856Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h1 id="Linux-应用领域"><a href="#Linux-应用领域" class="headerlink" title="Linux 应用领域"></a>Linux 应用领域</h1><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><h1 id="Linux-和-Windows的区别"><a href="#Linux-和-Windows的区别" class="headerlink" title="Linux 和 Windows的区别"></a>Linux 和 Windows的区别</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p><table><thead><tr><th align="left"></th><th align="left">Windows</th><th align="left">Linux</th></tr></thead><tbody><tr><td align="left">界面</td><td align="left">界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td align="left">图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td align="left">驱动程序</td><td align="left">驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td align="left">由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td align="left">使用</td><td align="left">使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td align="left">图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td align="left">学习</td><td align="left">系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td align="left">系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td align="left">软件</td><td align="left">每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td align="left">大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h1><p>linux启动时我们会看到许多启动信息。</p><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li>内核的引导</li><li>运行 init</li><li>系统初始化</li><li>建立终端 </li><li>用户登录系统</li></ul><h2 id="init程序的类型："><a href="#init程序的类型：" class="headerlink" title="init程序的类型："></a>init程序的类型：</h2><ul><li>SysV: init, CentOS 5之前, 配置文件： /etc/inittab</li><li>Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf</li><li>Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system</li></ul><h2 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h2><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p><p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p><h2 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a>运行init</h2><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p><p>init 程序首先是需要读取配置文件 /etc/inittab。</p><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>init进程的一大任务，就是去运行这些开机启动的程序。</p><p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p><p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><p>Linux系统有7个运行级别(runlevel)：</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p><p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p><pre><code>l5:5:wait:/etc/rc.d/rc 5</code></pre><p>这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。</p><p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p><p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p><p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p><h2 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h2><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p><p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p><pre><code>1:2345:respawn:/sbin/mingetty tty12:2345:respawn:/sbin/mingetty tty23:2345:respawn:/sbin/mingetty tty34:2345:respawn:/sbin/mingetty tty45:2345:respawn:/sbin/mingetty tty56:2345:respawn:/sbin/mingetty tty6</code></pre><p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p><p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p><h1 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h1><p>一般来说，用户的登录方式有三种：</p><ul><li>（1）命令行登录</li><li>（2）ssh登录</li><li>（3）图形界面登录</li></ul><p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p><p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p><p>这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p><p>/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h2 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p><p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space +（ F1-F6）. </p><p>如果你在图形界面下请按Alt + Shift + Ctrl + （F1-F6） 切换至命令窗口。</p><h1 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机"></a>Linux 关机</h1><p>在linux领域内<strong>大多用在服务器上，很少遇到关机的操作</strong>。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p><pre><code>sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机shutdown –h +10 十分钟后关机shutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于shutdown –h now 和 poweroff</code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p><strong>[Tab] 有『命令补全』与『文件补齐』的功能</strong></p><pre><code>[Tab]      ## 接在一串指令的第一个字的后面，则为『命令补全』[Tab]      ## 接在一串指令的第二个字以后时，则为『文件补齐』</code></pre><p>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</p><p><strong>[Ctrl]+ C 如果在Linux 底下输入了错误的指令或参数，想让当前的程序『停掉』的话，可以输入：</strong></p><pre><code>[Ctrl] + c </code></pre><p><strong>[Ctrl]-d 『键盘输入结束(End Of File, EOF 或 End Of Input)』的意思</strong></p><p>另外，他也可以用来取代 exit 的输入。</p><p>例如你想要直接离开文字接口，可以直接按下：</p><pre><code>[Ctrl] + d   ## 相当于输入 exit</code></pre><p><strong>[shift]+{[PageUP]|[Page Down]}</strong></p><pre><code>[Shift]+[Page Up]    ## 往前翻页 [Shift]+[Page Down] ## 往后翻页</code></pre><p>shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。</p><pre><code># shutdown -p now  ### 关闭机器# shutdown -H now  ### 停止机器      # shutdown -r 09:35 ### 在 09:35am 重启机器</code></pre><p>要取消即将进行的关机，只要输入下面的命令：</p><pre><code># shutdown -c</code></pre><p>halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。</p><pre><code># halt             ### 停止机器# halt -p          ### 关闭机器、关闭电源# halt --reboot    ### 重启机器</code></pre><p>poweroff 会发送一个 ACPI 信号来通知系统关机。</p><pre><code># poweroff           ### 关闭机器、关闭电源# poweroff --halt    ### 停止机器# poweroff --reboot  ### 重启机器</code></pre><p>reboot 命令 reboot 通知系统重启。</p><pre><code># reboot           ### 重启机器# reboot --halt    ### 停止机器# reboot -p        ### 关闭机器</code></pre><h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><p>登录系统后，在当前命令窗口下输入命令：</p><pre><code> ls / </code></pre><p>可显示当前层的目录。</p><p><img src="/2021/01/26/Linux%E5%AD%A6%E4%B9%A0-1/pic-1.png" alt="树状目录结构图"></p><p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p><p>文件系统的最顶层是由根目录开始的，系统使用 <strong>/</strong> 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。</p><p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <strong>.</strong> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 <strong>..</strong> 来表示。</p><ul><li> . ：代表当前的目录，也可以使用 ./ 来表示；</li><li> .. ：代表上一层目录，也可以 ../ 来代表。</li></ul><p>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p><h2 id="1-系统启动必须："><a href="#1-系统启动必须：" class="headerlink" title="1.系统启动必须："></a><strong>1.系统启动必须：</strong></h2><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p><h2 id="2-指令集合："><a href="#2-指令集合：" class="headerlink" title="2.指令集合："></a><strong>2.指令集合：</strong></h2><p><strong>/bin：</strong>存放着最常用的程序和指令</p><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p><h2 id="3-外部文件管理："><a href="#3-外部文件管理：" class="headerlink" title="3.外部文件管理："></a><strong>3.外部文件管理：</strong></h2><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p><h2 id="4-临时文件："><a href="#4-临时文件：" class="headerlink" title="4.临时文件："></a><strong>4.临时文件：</strong></h2><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p><h2 id="5-账户："><a href="#5-账户：" class="headerlink" title="5.账户："></a><strong>5.账户：</strong></h2><p><strong>/root</strong>：系统管理员的用户主目录。</p><p><strong>/home</strong>：用户的主目录，以用户的账号命名的。</p><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p><h2 id="6-运行过程中要用："><a href="#6-运行过程中要用：" class="headerlink" title="6.运行过程中要用："></a><strong>6.运行过程中要用：</strong></h2><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p><h2 id="7-扩展用的："><a href="#7-扩展用的：" class="headerlink" title="7.扩展用的："></a><strong>7.扩展用的：</strong></h2><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p><h2 id="8-其他："><a href="#8-其他：" class="headerlink" title="8.其他："></a>8.其他：</h2><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre><p><strong>/selinux：</strong><br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><h4 id="在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"><a href="#在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。" class="headerlink" title="在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"></a>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</h4><p><strong>/etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p><strong>/bin, /sbin, /usr/bin, /usr/sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p><p><strong>/var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。&lt;/p&gt;
&lt;p&gt;Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Li</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习-3</title>
    <link href="http://example.com/2021/01/22/c++%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://example.com/2021/01/22/c++%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-01-22T10:26:10.000Z</published>
    <updated>2021-04-16T10:28:38.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h2><p>在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p><h3 id="1、插入器-lt-lt"><a href="#1、插入器-lt-lt" class="headerlink" title="1、插入器(&lt;&lt;)"></a><strong>1、插入器(&lt;&lt;)</strong></h3><p>　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’/n’;就表示把字符串”Write Stdout”和换行字符(‘/n’)输出到标准输出流。</p><h3 id="2、析取器-gt-gt"><a href="#2、析取器-gt-gt" class="headerlink" title="2、析取器(&gt;&gt;)"></a><strong>2、析取器(&gt;&gt;)</strong></h3><p>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p><p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream。下面就把此类的文件操作过程一一道来。</p><h3 id="3、打开文件"><a href="#3、打开文件" class="headerlink" title="3、打开文件"></a><strong>3、打开文件</strong></h3><p>　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><p>　　void open(const char* filename,int mode,int access);</p><p>　　参数：</p><p>　　filename：　　要打开的文件名<br>　　mode：　　　　要打开文件的方式<br>　　access：　　　打开文件的属性<br>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p><p>　　ios::app：　　　以追加的方式打开文件<br>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性<br>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文<br>　　ios::in：　　　 文件以输入方式打开<br>　　ios::out：　　　文件以输出方式打开<br>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　<br>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败<br>　　ios::trunc：　　如果文件存在，把文件长度设为0<br>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p><p>　　打开文件的属性取值是：</p><p>　　0：普通文件，打开访问<br>　　1：只读文件<br>　　2：隐含文件<br>　　4：系统文件<br>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p><p>　　例如：以二进制输入方式打开文件c:/config.sys</p><p>　　fstream file1;<br>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p><p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p><p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p><p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p><p>　　fstream file1(“c://config.sys”);</p><p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p><p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件<br>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p><p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p><h3 id="4、关闭文件"><a href="#4、关闭文件" class="headerlink" title="4、关闭文件"></a>4、关闭文件</h3><p>　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p><h3 id="5、读写文件"><a href="#5、读写文件" class="headerlink" title="5、读写文件"></a>5、读写文件</h3><p>　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p><h4 id="1、文本文件的读写"><a href="#1、文本文件的读写" class="headerlink" title="1、文本文件的读写"></a>1、文本文件的读写</h4><p>　　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p><p>　　file2&lt;&lt;”I Love You”;//向文件写入字符串”I Love You”<br>　　int i;<br>　　file1&gt;&gt;i;//从文件输入一个整数值。</p><p>　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p><p>　　操纵符 功能 输入/输出<br>　　dec 格式化为十进制数值数据 输入和输出<br>　　endl 输出一个换行符并刷新此流 输出<br>　　ends 输出一个空字符 输出<br>　　hex 格式化为十六进制数值数据 输入和输出<br>　　oct 格式化为八进制数值数据 输入和输出<br>　　setpxecision(int p) 设置浮点数的精度位数 输出</p><p>　　比如要把123当作十六进制输出：file1&lt;</p><h4 id="2、二进制文件的读写"><a href="#2、二进制文件的读写" class="headerlink" title="2、二进制文件的读写"></a>2、二进制文件的读写</h4><h5 id="①put"><a href="#①put" class="headerlink" title="①put()"></a>①put()</h5><p>　　put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(‘c’);就是向流写一个字符’c’。</p><h5 id="②get"><a href="#②get" class="headerlink" title="②get()"></a>②get()</h5><p>　　get()函数比较灵活，有3种常用的重载形式：</p><p>　　一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p><p>　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p><p>　　还有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=’/n’)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’/n’。例如：</p><p>　　file2.get(str1,127,’A’);//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p><h5 id="③读写数据块"><a href="#③读写数据块" class="headerlink" title="③读写数据块"></a>③读写数据块</h5><p>　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p><p>　　read(unsigned char *buf,int num);<br>　　write(const unsigned char *buf,int num);</p><p>　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p><p>　　例：</p><p>　　unsigned char str1[]=”I Love You”;<br>　　int n[5];<br>　　ifstream in(“xxx.xxx”);<br>　　ofstream out(“yyy.yyy”);<br>　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中<br>　　in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换<br>　　in.close();out.close();</p><h3 id="6、检测EOF"><a href="#6、检测EOF" class="headerlink" title="6、检测EOF"></a>6、检测EOF</h3><p>　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p><p>　　例：　　if(in.eof())ShowMessage(“已经到达文件尾！”);</p><h3 id="7、文件定位"><a href="#7、文件定位" class="headerlink" title="7、文件定位"></a>7、文件定位</h3><p>　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p><p>　　istream &amp;seekg(streamoff offset,seek_dir origin);<br>　　ostream &amp;seekp(streamoff offset,seek_dir origin);</p><p>　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p><p>　　ios::beg：　　文件开头<br>　　ios::cur：　　文件当前位置<br>　　ios::end：　　文件结尾<br>　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p><p>　　例：</p><p>　　file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节<br>　　file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</p><h3 id="8-BCB提供的文件操作函数"><a href="#8-BCB提供的文件操作函数" class="headerlink" title="8.BCB提供的文件操作函数"></a>8.BCB提供的文件操作函数</h3><p>总共分为三类：</p><p>1、文件名函数</p><p>2、文件管理函数</p><p>3、文件I/O函数</p><h4 id="1、文件名函数"><a href="#1、文件名函数" class="headerlink" title="1、文件名函数"></a>1、文件名函数</h4><p>　　文件名函数可以对文件的名称、所在子目录、驱动器和扩展名等进行操作。下表列出这些函数及其功能。</p><p>　　函数 说明<br>　　ExpandFileName() 返回文件的全路径(含驱动器、路径)<br>　　ExtractFileExt() 从文件名中抽取扩展名<br>　　ExtractFileName() 从文件名中抽取不含路径的文件名<br>　　ExtractFilePath() 从文件名中抽取路径名<br>　　ExtractFileDir() 从文件名中抽取目录名<br>　　ExtractFileDrive() 从文件名中抽取驱动器名<br>　　ChangeFileExt() 改变文件的扩展名<br>　　ExpandUNCFileName() 返回含有网络驱动器的文件全路径<br>　　ExtractRelativePath() 从文件名中抽取相对路径信息<br>　　ExtractShortPathName() 把文件名转化为DOS的8·3格式<br>　　MatchesMask() 检查文件是否与指定的文件名格式匹配</p><p>　　下面就把这些函数作一一介绍：</p><h5 id="⑴ExpandFileName"><a href="#⑴ExpandFileName" class="headerlink" title="⑴ExpandFileName()"></a><strong>⑴ExpandFileName()</strong></h5><p>　　功能：返回文件的全路径(含驱动器、路径)</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExpandFileName(Application-&gt;ExeName));//显示你的程序文件名，如C:/MyBCB/Sample1.EXE</p><h5 id="⑵ExtractFileExt"><a href="#⑵ExtractFileExt" class="headerlink" title="⑵ExtractFileExt()"></a><strong>⑵ExtractFileExt()</strong></h5><p>　　功能：从文件名中抽取扩展名</p><p>　　参数：FileName:要处理的文件名（全路径）</p><p>　　例：ShowMessage(ExtractFileExt(Application-&gt;ExeName));//显示”.exe”</p><h5 id="⑶ExtractFileName"><a href="#⑶ExtractFileName" class="headerlink" title="⑶ExtractFileName()"></a><strong>⑶ExtractFileName()</strong></h5><p>　　功能：从文件名中抽取不含路径的文件名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileExt(“c://Winnt//SOL.EXE”));//显示”SOL.EXE”</p><h5 id="⑷ExtractFilePath"><a href="#⑷ExtractFilePath" class="headerlink" title="⑷ExtractFilePath()"></a><strong>⑷ExtractFilePath()</strong></h5><p>　　功能：从文件名中抽取路径名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFilePath(“Winnt//SOL.EXE”));//显示”Winnt/“</p><h5 id="⑸ExtractFileDir"><a href="#⑸ExtractFileDir" class="headerlink" title="⑸ExtractFileDir()"></a><strong>⑸ExtractFileDir()</strong></h5><p>　　功能：从文件名中抽取目录名(和上个函数不同，不包括最后的”/“)</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileDir(“Winnt//SOL.EXE”));//显示”Winnt”,注意和上个函数的区别</p><h5 id="⑹ExtractFileDrive"><a href="#⑹ExtractFileDrive" class="headerlink" title="⑹ExtractFileDrive()"></a><strong>⑹ExtractFileDrive()</strong></h5><p>　　功能：从文件名中抽取驱动器名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileDrive(“c://Winnt//SOL.EXE”));//显示”c:”</p><h5 id="⑺ChangeFileExt"><a href="#⑺ChangeFileExt" class="headerlink" title="⑺ChangeFileExt()"></a><strong>⑺ChangeFileExt()</strong></h5><p>　　功能：更改文件名的扩展名，不是对真正的文件进行改名，只是对文件名这个字符串进行处理</p><p>　　参数：FileName:要改名的文件名，Extension：新的扩展名</p><p>　　例：ShowMessage(ChangeFileExt(“c://Winnt//SOL.EXE”,”.OOO”));//显示”c:/winnt/SOL.OOO”</p><h5 id="⑻ExpandUNCFileName"><a href="#⑻ExpandUNCFileName" class="headerlink" title="⑻ExpandUNCFileName()"></a><strong>⑻ExpandUNCFileName()</strong></h5><p>　　功能：返回含有网络驱动器的文件全路径，格式为：//机器名/共享名/文件名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExpandUNCFileName(“F://Winnt//SOL.EXE”));/<em>如果F:是映射的网络驱动器//NT40/WINNT，则显示”//NT40/WINNT/SOL.EXE”</em>/</p><h5 id="⑼ExtractRelativePath"><a href="#⑼ExtractRelativePath" class="headerlink" title="⑼ExtractRelativePath()"></a><strong>⑼ExtractRelativePath()</strong></h5><p>　　功能：从文件名中抽取相对路径信息，如”../sss/ss.asd”这种形式</p><p>　　参数：BaseName：基准文件名；DestName：目标文件名</p><p>　　例：ShowMessage(ExtractRelativePath(“D://Source//c//1.123”,”D://Source//Asm//dz.asm”));/<em>显示”../asm/dz.asm”</em>/</p><h5 id="10-ExtractShortPathName"><a href="#10-ExtractShortPathName" class="headerlink" title="(10) ExtractShortPathName()"></a><strong>(10) ExtractShortPathName()</strong></h5><p>　　功能：把文件名转换为DOS的8、3格式</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractShortPathName(“E://Program Files//Dual Wheel Mouse//4dmain.exe”));/<em>显示”E:/Progra<del>1/dualwh</del>1/4dmain.exe”</em>/</p><h5 id="⑾MatchesMask"><a href="#⑾MatchesMask" class="headerlink" title="⑾MatchesMask()"></a><strong>⑾MatchesMask()</strong></h5><p>　　功能：检查文件是否与指定的文件名格式匹配</p><p>　　参数：FileName:要处理的文件名；Mask:文件名格式，支持通配符</p><p>　　例：ShowMessage(MatchesMask(“Lxf.exe”,”*.?x?));//显示”true”</p><h4 id="2、文件管理函数"><a href="#2、文件管理函数" class="headerlink" title="2、文件管理函数"></a>2、文件管理函数</h4><p>　　这类函数包括设置和读取驱动器、子目录和文件的有关的各种操作，下表列出这类操作常用的函数及其功能。</p><p>　　函数 功能<br>　　CreateDir() 创建新的子目录<br>　　DeleteFile() 删除文件<br>　　DirectoryExists() 判断目录是否存在<br>　　DiskFree() 获取磁盘剩余空间<br>　　DiskSize() 获取磁盘容量<br>　　FileExists() 判断文件是否存在<br>　　FileGetAttr() 获取文件属性<br>　　FileGetDate() 获取文件日期<br>　　GetCurrentDir() 获取当前目录<br>　　RemoveDir() 删除目录<br>　　SetCurrentDir() 设置当前目录</p><p>　　下面就把这些函数作一一介绍：</p><h5 id="⑴CreateDir"><a href="#⑴CreateDir" class="headerlink" title="⑴CreateDir()"></a><strong>⑴CreateDir()</strong></h5><p>　　功能：建立子目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要建立的子目录的名字</p><p>　　例：Create(“ASM”);//在当前目录下建立一个名为ASM的子目录</p><h5 id="⑵DeleteFile"><a href="#⑵DeleteFile" class="headerlink" title="⑵DeleteFile()"></a><strong>⑵DeleteFile()</strong></h5><p>　　功能：删除文件，如果成功返回true，否则返回false</p><p>　　参数：FileName:要删除的文件名</p><p>　　例：if(OpenDialog1-&gt;Execute())DeleteFile(OpenDialog1-&gt;FileName);</p><h5 id="⑶DirectoryExists"><a href="#⑶DirectoryExists" class="headerlink" title="⑶DirectoryExists()"></a><strong>⑶DirectoryExists()</strong></h5><p>　　功能：检测目录是否存在，如果存在返回true，否则返回false</p><p>　　参数：Name:要检测的目录名</p><p>　　例：if(!DirectoryExists(“ASM”))CreateDir(“ASM”);//如果ASM这个目录不存在则创建之</p><h5 id="⑷DiskFree"><a href="#⑷DiskFree" class="headerlink" title="⑷DiskFree()"></a><strong>⑷DiskFree()</strong></h5><p>　　功能：检测磁盘剩余空间，返回值以字节为单位，如果指定的磁盘无效，返回-1</p><p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p><p>　　例：ShowMessage(DiskFree(0));//显示当前盘的剩余空间</p><h5 id="⑸DiskSize"><a href="#⑸DiskSize" class="headerlink" title="⑸DiskSize()"></a><strong>⑸DiskSize()</strong></h5><p>　　功能：检测磁盘容量，返回值以字节为单位，如果指定的磁盘无效，返回-1</p><p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p><p>　　例：ShowMessage(DiskFree(0));//显示当前盘的容量</p><p>　　<strong>⑹FileExists()</strong></p><p>　　功能：检测文件是否存在，如果存在返回true，否则返回false</p><p>　　参数：FileName:要检测的文件名</p><p>　　例：if(FileExists(“AAA.ASM”))DeleteFile(“AAA.ASM”);</p><h5 id="⑺FileGetAttr"><a href="#⑺FileGetAttr" class="headerlink" title="⑺FileGetAttr()"></a><strong>⑺FileGetAttr()</strong></h5><p>　　功能：取得文件属性，如果出错返回-1</p><p>　　返回值如下表，如果返回$00000006表示是一个具有隐含和系统属性的文件(4+2)</p><p>　　常量 值 含义<br>　　faReadOnly $00000001 只读文件<br>　　faHidden $00000002 隐含文件<br>　　faSysFile $00000004 系统文件<br>　　faVolumeID $00000008 卷标<br>　　faDirectory $00000010 目录<br>　　faArchive $00000020 归档文件</p><p>　　例：if(FileGetAttr(“LLL.TXT”)&amp;0x2)ShowMessage(“这是一个有隐含属性的文件”);</p><p>　　与此对应的有FileSetAttr() ，请自已查阅帮助系统</p><h5 id="⑻FileGetDate"><a href="#⑻FileGetDate" class="headerlink" title="⑻FileGetDate()"></a><strong>⑻FileGetDate()</strong></h5><p>　　功能：返回文件的建立时间到1970-1-1日0时的秒数</p><p>　　参数：Handle:用FileOpen()打开的文件句柄。</p><p>　　例：</p><p>　　int i=FileOpen(“C://autoexec.bat”,fmOpenRead);<br>　　ShowMessage(FileGetDate(i));<br>　　FileClose(i);</p><p>　　与此对应的有FileSetDate()</p><p>　　<strong>⑼GetCurrentDir()</strong></p><p>　　功能：取得当前的目录名</p><p>　　例：ShowMessage(GetCurrentDir());</p><h5 id="⑽RemoveDir"><a href="#⑽RemoveDir" class="headerlink" title="⑽RemoveDir()"></a><strong>⑽RemoveDir()</strong></h5><p>　　功能：删除目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要删除的目录名</p><p>　　例：if(DiectoryExists(“ASM”))RemoveDir(“ASM”);</p><h5 id="⑾SetCurrentDir"><a href="#⑾SetCurrentDir" class="headerlink" title="⑾SetCurrentDir()"></a><strong>⑾SetCurrentDir()</strong></h5><p>　　功能：设置当前目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要切换到的目录名</p><p>　　例：SetCurrentDir(“C://WINDOWS”);</p><h4 id="3、文件I-O函数"><a href="#3、文件I-O函数" class="headerlink" title="3、文件I/O函数"></a>3、文件I/O函数</h4><p>　　这类函数完成对文件的读写相关的操作，这种类型的操作和C的基于I/O文件操作类似，下表列出这类操作常用的函数及其功能。</p><p>　　FileOpen() 打开文件<br>　　FileClose() 关闭文件<br>　　FileRead() 读文件<br>　　FileSeek() 文件定位<br>　　FileWrite() 写文件<br>　　FileCreate() 创建文件</p><p>　　下面就对这些函数作详细介绍。</p><p>　　<strong>⑴FileOpen()</strong></p><p>　　功能：打开文件，如果成功返回其句柄，否则返回-1</p><p>　　参数：FileName:要打开的文件名；Mode：打开的方式，取值如下表，可用”或”(“|”)运算符连接。</p><p>　　常量 值 说明</p><p>　　fmOpenRead 0 以只读属性打开<br>　　fmOpenWrite 1 以只写属性打开<br>　　fmOpenReadWrite 2 以读/写属性打开<br>　　fmShareCompat 0 兼容FCB方式(汇编中有相应的DOS功能调用)<br>　　fmShareExclusive 16 共享方式：以独占方式打开，在关闭以前，别人不能访问<br>　　fmShareDenyWrite 32 共享方式：拒绝写访问<br>　　fmShareDenyRead 48 共享方式：拒绝读访问<br>　　fmShareDenyNone 64 共享方式：无限制，允许读写<br>　　例：int i=FileOpen(“C://WINDOWS//Win.ini”,fmOpenReadWrite|fmShareExclusive);</p><p>　　<strong>⑵FileClose()</strong></p><p>　　功能：关闭打开的句柄。</p><p>　　参数：Handle:要关闭的句柄</p><p>　　例：FileClose(i);</p><p>　　<strong>⑶FileRead()</strong></p><p>　　功能：读文件，返回实际读取的字节数，句柄必须首先由FileOpen或FileCreate创建。</p><p>　　参数：Handle:要读取的句柄；Buffer:存放读取的数据的缓冲区；Count:想读取的字节数</p><p>　　例：char str[400];FileRead(hnd1,str,400);</p><p>　　<strong>⑷FileSeek()</strong></p><p>　　功能：移动文件读取指针，成功返回文件指针的位置，失败返回-1</p><p>　　参数：Handle:相关联的句柄；Offset:移动的量；Orgin:移动的基准，0=文件头，1=当前位置，2=文件尾。</p><p>　　例：ShowMessage(FileSeek(hnd1,0,2));//取得文件的长度</p><p>　　<strong>⑸FileWrite()</strong></p><p>　　功能：写文件，返回实际写入的字节数，句柄必须首先由FileOpen或FileCreate创建。</p><p>　　参数：Handle:要写入的句柄；Buffer:存放写入数据的缓冲区；Count:想写入的字节数</p><p>　　例：char str[]=”I Love You”;FileWrite(hnd1,str,strlen(str));</p><p>　　<strong>⑹FileCreate()</strong></p><p>　　功能：创建文件。成功返回其句柄，否则返回-1</p><p>　　参数：FileName:要创建的文件名</p><p>　　例：if(!FileExists(“KC.C”))hnd1=FileCreate(“KC.C”);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;c-文件操作&quot;&gt;&lt;a href=&quot;#c-文件操作&quot; class=&quot;headerlink&quot; title=&quot;c++文件操作&quot;&gt;&lt;/a&gt;c++文件操作&lt;/h2&gt;&lt;p&gt;在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c++学习" scheme="http://example.com/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
