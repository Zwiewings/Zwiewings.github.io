<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="https://zwiewings.github.io/atom.xml" rel="self"/>
  
  <link href="https://zwiewings.github.io/"/>
  <updated>2021-05-14T11:05:40.064Z</updated>
  <id>https://zwiewings.github.io/</id>
  
  <author>
    <name>Zweiwings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++拓展-4:序列式容器STL array</title>
    <link href="https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/"/>
    <id>https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/</id>
    <published>2021-05-14T10:55:15.000Z</published>
    <updated>2021-05-14T11:05:40.064Z</updated>
    
    
    <summary type="html">关于序列式容器的介绍及其中STL array的用法</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-3：STL库基础</title>
    <link href="https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/"/>
    <id>https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/</id>
    <published>2021-05-13T11:24:16.000Z</published>
    <updated>2021-05-14T04:13:05.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL库基本组成"><a href="#STL库基本组成" class="headerlink" title="STL库基本组成"></a>STL库基本组成</h1><table><thead><tr><th>STL组成</th><th>含义</th></tr></thead><tbody><tr><td>容器</td><td>封装数据结构的模板类，如vector向量容器、list列表等</td></tr><tr><td>算法</td><td>许多被设计成模板的数据结构算法在命名空间中定义，大部分包含在algorithm头文件中，少部分位于numeric头文件</td></tr><tr><td>迭代器</td><td>在C++STL中，对容器中数据的读和写，是通过迭代器完成的</td></tr><tr><td>函数对象</td><td>一个将运算符重载为成员函数的类叫函数对象类，这个类的对象就是函数对象</td></tr><tr><td>适配器</td><td>可以使一个类的接口（模板的参数适配成用户指定的形式，让本来不能在一起工作的两个类工作在一起</td></tr><tr><td>内存分配器</td><td>为容器类模板提供自定义的内存申请和释放功能</td></tr></tbody></table><p>C++标准中，STL头文件被组织为13个：</p><ul><li>iterator：定义了一些迭代器模板</li><li>functional：定义一些函数对象类型和支持函数对象的功能</li><li>vector：类似数组，需要所有元素为统一类型，定义vector容器和vector对象的操作</li><li>deque：封装双端队列，定义deque容器和deque对象操作</li><li>list：封装列表，定义list容器和list对象操作</li><li>queue：封装队列（只有一端可操作，有点栈的感觉，但先进先出），定义queue容器和queue对象操作</li><li>stack：封装堆栈，定义stack容器和stack对象操作</li><li>set：封装二叉树（红黑树），定义set对象和set对象操作</li><li>map：封装加权二叉树（红黑树），定义map对象和map对象操作</li><li>algorithm：定义多种算法，例如升降序排序、查找之类的</li><li>numeric：定义了基础性的数值算法</li><li>memory</li><li>utility</li></ul><br><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>STL容器就是封装了数据结构的模板类的集合，提有三类标准容器：序列容器、排序容器和哈希容器，后两类有时也统称关联容器。</p><table><thead><tr><th>容器种类</th><th>功能</th></tr></thead><tbody><tr><td>序列容器</td><td>主要包括vector向量容器、list列表容器以及deque双端队列容器。元素在容器中的位置同元素值无关，插入元素时指定在什么位置，元素就位于什么位置。</td></tr><tr><td>排序容器</td><td>包括set集合容器、multiset多重集合容器、map映射容器、multimap多重映射容器。元素默认从小到大排列，插入元素时同样插入到合适的位置，所以在查找时具有非常好的性能。</td></tr><tr><td>哈希容器</td><td>包括4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。容器中的元素是未排序的，位置由哈希函数决定。【c++11的编译器下才能使用，VS支持，gcc/g++编译器是不支持的】</td></tr></tbody></table><br><h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>迭代器和c++的指针非常相似，可以是任何需要的类型，通过迭代器可以指向容器中的某个元素，也可以执行读写操作。</p><p>迭代器的功能强弱决定了容器是否支持STL的某种算法。</p><p>常用迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p><p>【其中输入/输出迭代器不是把数组和容器当做操作对象，而是将输入/输出流作为对象，较为特殊。】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-2">双向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-3">随机访问迭代器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>已知p是一个前向迭代器，则p支持++p，p++，*p操作，可以被复制或赋值，可以用==和！=运算符进行比较，且两个正向迭代器可以相互赋值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>具有正向迭代器的所有功能，同时具有–p或p–的操作（即一次向后移动一个位置）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>具有双向迭代器的全部功能，可以用&lt;、&gt;、&lt;=、&gt;=运算符比较，且p2-p1有意义，为p2指向元素和p1指向元素的序号差</p><p>当i为整型变量或常量时：</p><ul><li>p+=i：往后移动i个元素</li><li>p-=i：往前移动i个元素</li><li>p+i：返回p后面第i个元素的迭代器</li><li>p-i：返回p前面第i个元素的迭代器</li><li>p[i]：返回p后面第i个元素的引用</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>容器</th><th>对应迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set/multiset</td><td>双向迭代器</td></tr><tr><td>map/multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map/unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set/unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><div class="tip warning"><p>注：容器适配器stack和queue没有迭代器，其本身具有一些成员函数，用于对元素进行访问</p><p></p></div><br><h1 id="迭代器定义方式"><a href="#迭代器定义方式" class="headerlink" title="迭代器定义方式"></a>迭代器定义方式</h1><table><thead><tr><th>定义方式</th><th>格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器（反向迭代器适配器）</td><td>::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>::const_reverse_iterator 迭代器名;</td></tr></tbody></table><div class="tip warning"><p></p><p>注意事项：</p><ul><li>读取迭代器指向的元素使用和指针一样的方法：*迭代器名</li><li>反向迭代器和正向迭代器：正向迭代器使用p++时，迭代器指向容器中后一个元素，而反向迭代器使用p++时，迭代器指向前一个元素</li><li>常量迭代器和非常量迭代器：常量迭代器同c++中const声明是几乎一样的，所以只有通过非常量迭代器才能修改其指向的元素</li><li>如容器array、deque、vector同时支持4种，但并不是每个容器都适用以上4种定义迭代器的方式，如forward_list只支持正向迭代器而不支持反向迭代器</li></ul><p></p></div><p>以下为范例1：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;//需要引入vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="comment">//v被初始化为有5个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第1次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)<span class="comment">//可以通过v.size()的方式得到元素个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以像普通数组一样使用vector容器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第2次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"><span class="keyword">for</span> (i = v.begin(); i != v.end(); i++)<span class="comment">//能用v.begin()和v.end()的方式获得首末元素的地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以用*迭代器名的方式获取元素值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第3次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = v.begin();</span><br><span class="line"><span class="keyword">while</span> (i &lt; v.end())<span class="comment">//实现间隔一个元素输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i += <span class="number">2</span>;<span class="comment">//随机访问迭代器支持“+=整型”的操作</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上运行结果为：</p><div class="snote paperclip light"><p></p><p>第1次遍历v<br>1 2 3 4 5 6<br>第2次遍历v<br>1 2 3 4 5 6<br>第3次遍历v<br>1 3 5</p><p></p></div><div class="tip warning"><p></p><p>注：VisualStudio在调试时不会检查迭代器越界问题，但运行时系统会弹窗报错”cannot seek vector iterator after end”</p><p></p></div><br><p>以下为范例2：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>以下代码合法：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i != v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用”&lt;”比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i &lt; v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用下标随机访问比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于c++实际应用中的STL库组成及迭代器详细</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++拓展" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/C-%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-4</title>
    <link href="https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/"/>
    <id>https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/</id>
    <published>2021-05-13T07:10:39.000Z</published>
    <updated>2021-05-13T11:02:24.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>css中的盒模型相当于礼物的外包装盒，封装周围的HTML元素，包括外边距（margin），边框（border），内边距（padding）和实际内容（content），常用的div元素就是一种区块容器标记，可以将网页分隔为不同的部分，以实现网页的规划和布局。</p><p>纵深结构来说，盒模型自下而上为：外边距、背景颜色、背景图像、内边距、内容、边框</p><p><img src="/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/1.PNG" alt="1"></p><div class="tip important font5 fas fa-bell"><p>css代码中的宽和高（width和height）指的是如下部分：</p><p>盒子的总宽度=width+左右内边框之和+左右边框宽度之和+左右外边距之和</p><p>盒子的总高度=height+上下内边距之和+上下边框宽度之和+上下外边框之和</p></div><br><h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><p>边框主要包括边框宽度、边框样式、边框颜色、此外还有border的综合属性，在CSS3中添加了圆角边距，图片边距属性。</p><ul><li><p>边框宽度（border-width）：用于设置元素边框的宽度值</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-width</span>：上边距宽度<span class="selector-attr">[右边距宽度 下边距宽度 左边距宽度]</span>;</span><br><span class="line"></span><br><span class="line">其中，宽度由数字和单位组成，不可为负数，常以像素（<span class="selector-tag">px</span>）为单位，且设定1个值时全部应用，设定2~3个值时，省略的部分将使用对边的样式</span><br></pre></td></tr></table></figure></li><li><p>边框样式（border-style）：用于设置样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-style</span>：上边框样式<span class="selector-attr">[右边框样式 下边框样式 左边框样式]</span>;</span><br><span class="line"></span><br><span class="line">其中，设置时必须按上右下左的顺时针顺序，当设置1个值时为4边，2个值为上下/左右，3个值为上/左右/下，也可以通过形如<span class="selector-tag">border-left-style</span>的方式分别设置</span><br></pre></td></tr></table></figure><p>样式取值共9种，如下：</p><table><thead><tr><th>属性</th><th>含义</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>none</td><td>不显示边框（默认）</td><td>groove</td><td>边框带有立体感的沟槽</td></tr><tr><td>dotted</td><td>点线</td><td>ridge</td><td>边框成脊形</td></tr><tr><td>dashed</td><td>虚线</td><td>inset</td><td>使整个方框凹陷</td></tr><tr><td>solid</td><td>实线</td><td>outset</td><td>使整个方框凸起</td></tr><tr><td>double</td><td>双实线</td><td></td><td></td></tr></tbody></table></li><li><p>边框颜色（border-color）：用于定义边框的颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-color</span>:上边框颜色<span class="selector-attr">[右边框颜色 下边框颜色 左边框颜色]</span>;</span><br><span class="line"></span><br><span class="line">其中，颜色值符合定义法，有十六进制<span class="selector-id">#RRGGBB</span>和<span class="selector-tag">RGB</span>代码、<span class="selector-tag">rgb</span>(<span class="selector-tag">r</span>,<span class="selector-tag">g</span>,<span class="selector-tag">b</span>)三种，仅定义几个值的样式应用方式同上两种，可以通过形如<span class="selector-tag">border-left-color</span>的方式分别定义，（上使用<span class="selector-tag">top</span>，下使用<span class="selector-tag">bottom</span>）</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>边框综合属性（border）</p><p>border为复合属性，前三者的简写方式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">border&lt;边框宽度&gt;|&lt;边框样式&gt;|&lt;颜色&gt;;</span><br><span class="line"></span><br><span class="line">在复合属性中，边框<span class="selector-tag">border</span>同时设置4条边，如只需要1条边框应用该样式，需要通过形如<span class="selector-tag">border-left</span>的方式分别设置</span><br></pre></td></tr></table></figure></li></ul><h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><h3 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h3><p>主要用于调整内容在盒子中的值，指内容content和边框border的距离，也被称作内填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>:上内边距值<span class="selector-attr">[右内边距值 下内边距值 左内边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>边距值为数字和单位组成，不可为负值，常用像素（px）为单位，也可以是百分比，随父元素width变化而变化，和height无关</li><li>padding遵循复制原则，也可以通过形如padding-left的方式设置样式</li></ul><h3 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h3><p>margin指元素边框和相邻元素之间的距离（盒子和盒子的距离）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>:上外边距值<span class="selector-attr">[右外边距值 下外边距值 左外边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>margin为复合属性，同padding用法类似，但可以使用负值，使相邻元素重叠，若盒元素使用了宽度属性，设margin为auto时，可以实现盒元素居中</li><li>margin也遵循复制原则，可通过形如margin-left的方式设置样式</li></ul>]]></content>
    
    
    <summary type="html">关于CSS盒模型的运用</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="css" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/css/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-6</title>
    <link href="https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/"/>
    <id>https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</id>
    <published>2021-04-27T12:46:05.000Z</published>
    <updated>2021-05-12T12:20:28.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul><li>树：一个有限集，可以为空，非空时有且只有一个根结点，其余结点可以分为多个不相交的有限集（子树）</li><li>结点的度：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶子结点：度为0的结点</li><li>父结点：有子树的结点是其子树的根节点的父结点</li><li>子结点/孩子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点</li><li>兄弟结点：具有同一个父结点的各结点彼此是兄弟结点</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk。ni是ni+1的父结点。路径所包含边的个数为路径的长度</li><li>祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li><li>子孙结点：某一结点的子树中的所有结点是这个结点的子孙</li><li>结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>二叉树：一个有穷的结点集合。这个集合可以为空；若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。</p><p><strong>二叉树的五种基本形态：</strong></p><p>斜二叉树：只有左子节点或只有右子节点的二叉树，度为1，只有左子节点或右子节点</p><p>满二叉树/ 完美二叉树：除最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树</p><p>完全二叉树：有n个结点的二叉树，对树中结点从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中的位置相同（能和满二叉树完全重叠，编号相同）</p><p><strong>按从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：（顺序存储）</strong></p><ul><li>根结点的序号为1</li><li>非根结点（序号i&gt;1）的父结点的序号是：i / 2</li><li>结点（序号为i）的左孩子结点的序号是：2 * i，若2*i &gt; n，则没有左孩子</li><li>结点（序号为i）的右孩子结点的序号是：2 * i + 1，若2*i+1 &gt; n，则没有右孩子</li></ul><p><strong>普遍规律：</strong></p><p>一个二叉树第i层的最大结点数为：2i-1，i≥1</p><p>深度为k的二叉树有最大结点总数为：2k-1，k≥1</p><p>对任何非空二叉树T，叶结点个数为n0，度为1的结点个数为n1，度为2的结点个数为n2，则二叉树的总边数：N=2*n2+n1，总结点数：N′=n0+n1+n2，总叶子结点数：n0=n2+1</p><p><strong>二叉树的三种遍历：</strong></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/1.png" alt="1"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/2.png" alt="2"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/3.png" alt="3"></p><h3 id="二叉树操作"><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h3><h4 id="创建-初始化"><a href="#创建-初始化" class="headerlink" title="创建/初始化"></a>创建/初始化</h4><p>由于树的顺序表结构分配的空间通常只适用于完全二叉树，会造成普通二叉树的空间浪费，所以二叉树一般使用链式结构存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span>&#123;</span></span><br><span class="line">Elemtype data;<span class="comment">//二叉树的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">left</span>;</span><span class="comment">//二叉树的左指针，指向左子树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">Right</span>;</span><span class="comment">//二叉树的右指针，指向右子树</span></span><br><span class="line">&#125;*BTree;</span><br></pre></td></tr></table></figure><p>由于二叉树用递归算法较快，涉及到的先序、中序、后序三种输入方式时，只需要调整根节点的输入顺序即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Create</span><span class="params">(BTree &amp;T)</span><span class="comment">//传入要操作的结点T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elemtype a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;<span class="comment">//当输入为“#”时，判断二叉树创建完毕，结束递归</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        T=<span class="keyword">new</span> BTnode;<span class="comment">//创建一个新的二叉树结点</span></span><br><span class="line">        T-&gt;data=a;<span class="comment">//设置数据域为输入值</span></span><br><span class="line">        Create(T-&gt;left);<span class="comment">//递归创建T的左子树</span></span><br><span class="line">        Create(T-&gt;right);  <span class="comment">//递归创建T的右子树</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>在创建的时候，相当于也就遍历了一次二叉树，故而除却赋值之外的结构都十分相似,而且由于二叉树已经建立，可以通过二叉树的结点指针是否为空判断遍历是否结束</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下位置遍历的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//如果T为空，则结束遍历</span></span><br><span class="line">&#123;</span><br><span class="line">Traverse(T-&gt;left);<span class="comment">//递归遍历T的左子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">//输出T结点的数据</span></span><br><span class="line">Traverse(T-&gt;right);<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算深度"><a href="#计算深度" class="headerlink" title="计算深度"></a>计算深度</h4><p>二叉树深度为左右子树中深度较大者加1，故而需要递归求取左右子树的深度，再比较后加1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下求取深度的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当递归到叶子结点时，结束递归</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=depth(T-&gt;left);<span class="comment">//将左子树的深度存入m</span></span><br><span class="line">        n=depth(T-&gt;right);<span class="comment">//将右子树的深度存入n</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);<span class="comment">//如果左子树深度大于右子树则返回m+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);<span class="comment">//反之，返回n+1</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>线索二叉树将二叉树中空置的左右指针域利用起来，存储沿某种顺序遍历二叉树后继结点的地址，比二叉树多设置左右标志，当标志为1（true）时，表示有对应的子节点（左标志为1，左指针域存储左孩子的地址），否则对应指针域则存储某种顺序遍历二叉树时的下一个结点的地址</p><p><strong>其中，左指针域为线索时，指向前驱，右指针域为线索时指向后继</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> ltag,rtag;</span><br><span class="line">&#125;*DBTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序线索化"><a href="#二叉树中序线索化" class="headerlink" title="二叉树中序线索化"></a>二叉树中序线索化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBTnode *p;<span class="comment">//p为全局变量，是指向线索二叉树结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dchild</span><span class="params">(DBTree T)</span><span class="comment">//以T为根的子树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//当T不为空时</span></span><br><span class="line">&#123;</span><br><span class="line">Dchild(T-&gt;left);<span class="comment">//将左子树递归线索化</span></span><br><span class="line"><span class="keyword">if</span>(!T-&gt;left)<span class="comment">//如果左指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">T-&gt;ltag=<span class="literal">false</span>;<span class="comment">//则左标志为false，表示左指针域为线索指针域</span></span><br><span class="line">T-&gt;left=p;<span class="comment">//左指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> T-&gt;ltag=<span class="literal">true</span>;<span class="comment">//否则左标志为true，表示左指针域指向左孩子</span></span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)<span class="comment">//如果p的右指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//则右标志为false，表示右指针域为线索指针域</span></span><br><span class="line">p-&gt;right=p1;<span class="comment">//右指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p-&gt;rtag=<span class="literal">true</span>;<span class="comment">//否则右标志为true，表示右指针域指向右孩子</span></span><br><span class="line">p=T;<span class="comment">//p指向子树的根节点处</span></span><br><span class="line">Dchild(p-&gt;right);<span class="comment">//将右子树递归线索化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DOchild</span><span class="params">(DBTree &amp;T,DBTree D)</span><span class="comment">//带头结点的二叉树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T=<span class="keyword">new</span> DBTnode;<span class="comment">//创建头结点</span></span><br><span class="line">    T-&gt;Ltag=<span class="literal">true</span>;<span class="comment">//若树非空，则头结点的左孩子为树根，左标志为true</span></span><br><span class="line">    T-&gt;rtag=<span class="literal">false</span>;<span class="comment">//头结点没有右孩子，右标志为false</span></span><br><span class="line">    T-&gt;right=T;<span class="comment">//初始化时，头结点的右指针域指向自己</span></span><br><span class="line">    <span class="keyword">if</span>(!T) T-&gt;left=T;<span class="comment">//若树空，则头结点的左指针也指向自己</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    T-&gt;left=D;<span class="comment">//否则，头结点的左指针域指向原二叉树的根节点D</span></span><br><span class="line">        p=T;<span class="comment">//p指向原二叉树根节点D的前驱</span></span><br><span class="line">        Dchild(D);<span class="comment">//递归线索化二叉树D</span></span><br><span class="line">        p-&gt;right=T;<span class="comment">//递归线索化后，p指向中序遍历的最后一个结点，右指针域指向头结点</span></span><br><span class="line">        p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//p指向结点的右标志为false，表示没有右孩子</span></span><br><span class="line">        T-&gt;right=p;<span class="comment">//将头结点的右指针域指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历中序线索二叉树-非递归"><a href="#遍历中序线索二叉树-非递归" class="headerlink" title="遍历中序线索二叉树(非递归)"></a>遍历中序线索二叉树(非递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OTraverse</span><span class="params">(DBTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p=T-&gt;left;<span class="comment">//p指向头结点的左孩子，即二叉树的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)<span class="comment">//当树空或遍历结束时，将有p==T，结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="literal">true</span>) <span class="comment">//当左标志为false时，即直到没有左孩子时结束循环</span></span><br><span class="line">            p=p-&gt;left;<span class="comment">//p沿左子树向下遍历</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//输出左子树为空的结点的值</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag==<span class="literal">false</span>&amp;&amp;p-&gt;right!=T)<span class="comment">//当右标志为true，即有右孩子且p的后继不是头结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;right;<span class="comment">//p沿右子树向下遍历</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//沿右子树访问后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;right;<span class="comment">//转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于树与二叉树的概念说明，以及二叉树的创建/初始化、遍历、深度计算等代码实现</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5</title>
    <link href="https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/"/>
    <id>https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</id>
    <published>2021-04-26T11:52:16.000Z</published>
    <updated>2021-05-12T12:17:46.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串类型"><a href="#串类型" class="headerlink" title="串类型"></a>串类型</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>串的存储结构可以使用顺序和链式结构，顺序结构中又分为定长和堆式存储结构，但由于链式不如顺序结构灵活，操作简单，故而此处只写入顺序结构</p><h3 id="顺序-定长存储"><a href="#顺序-定长存储" class="headerlink" title="顺序-定长存储"></a>顺序-定长存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch[maxsize+<span class="number">1</span>];<span class="comment">//定义字符数组，串的最大长度为maxsize，多申请防止溢出的存储空间</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;Sstring;</span><br></pre></td></tr></table></figure><h3 id="顺序-堆式存储"><a href="#顺序-堆式存储" class="headerlink" title="顺序-堆式存储"></a>顺序-堆式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;<span class="comment">//如果是非空串，则按串长分配存储区，否则ch指向NULL;</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>串的模式匹配用于在主串中寻找子串，如果匹配成功，则确定相匹配的子串中第一个字符在主串s中出现的位置</p><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;<span class="comment">//否则，i回到开始匹配的位置（执行for语句的i++后移到下一个位置</span></span><br><span class="line">            j=<span class="number">0</span>;<span class="comment">//j被重置为0（然后执行for语句的j++后变为j=1）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];<span class="comment">//KMP相比BF算法节省时间的原因</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(Sstring t,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function">    <span class="comment">//求子串t的next函数值并且存进数组next</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i=<span class="number">1</span>,next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义i，j，以及next数组的第一个值</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;t.length;)<span class="comment">//i不超过子串t长度时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||t.ch[i]==t.ch[j])<span class="comment">//如果j为0或是前后两个字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(t.ch[i]!=t.ch[j])<span class="comment">//如果前后两个字符不相同</span></span><br><span class="line">                next[i]=j;<span class="comment">//令下次比较从j开始</span></span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组的顺序存储"><a href="#二维数组的顺序存储" class="headerlink" title="二维数组的顺序存储"></a>二维数组的顺序存储</h2><p>已知一维数组中a【i】的存储位置在a+i处，二维数组因主序不同分为两种存储结构（常用行序）</p><p>设每个数据元素占L个存储单元，则二维数组A[0…m-1,0…n-1]（下标从0开始，共有m行n列）中任一元素a【i】【j】的存储位置如下：</p><p><strong>行为主序的存储结构</strong>：</p><p>$$<br>LOC(i , j) = LOC(0 , 0) + (n * i + j) L<br>$$<br><strong>列为主序的存储结构：</strong><br>$$<br>LOC(i , j) = LOC(0 , 0) + (m * j + i) L<br>$$<br>其中，LOC(i,j)是a【i】【j】的存储位置</p><p>LOC（0，0）是a【0】【0】的存储位置，即二维数组A的起始存储位置、也称为基地址或基址</p><p><strong>故而总结可知：</strong><br>$$<br>LOC(i , j) = 基址 + (副序长度 * 主序标号 + 另一标号) * 数据所占存储单元<br>$$</p><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>特点：在n*n的矩阵a中，1&lt;= i，j &lt;= n<br>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。</p><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/1.png" alt="1"></p><p>上下三角中的元素均为：n(n+1) / 2<br>可以以行序为主序将元素存放在一个一维数组a[n(n+1) / 2]中，a[k]的位置可如下公式确定<br>$$<br>k=主序序号（主序序号-1）/2+副序序号-1，主序&gt;=副序<br>$$<br>注：上式的k从0开始计算</p><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/2.png" alt="2"></p><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-1.png" alt="3-1"></p><h3 id><a href="#" class="headerlink" title></a><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-2.png" alt="3-2"></h3><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/4.png" alt="4"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>一般记作LS（a1，a2，……，an），其中LS为广义表的名称，n为广义表的长度，其中的元素可以是单个数据（原子）也可以是广义表（子表），一般小写为原子，大写为子表</p><p><strong>广义表示例：</strong></p><ul><li>A=（）——空表，长度为0</li><li>B=（e）——只有一个原子，为e，长度为1</li><li>C=（a，（b，c，d））——有一个原子a和一个子表（b，c，d），共两个元素，长度为2</li><li>D=（A，B，C）——有三个子表，即三个元素，长度为3</li><li>E=（a，E）——一个递归的表，长度为2</li></ul><p>注：广义表A=（（））和广义表B=（）是不相同的，A为有一个空子表，长度为1的广义表，而B是一个空表，长度为0</p>]]></content>
    
    
    <summary type="html">关于串的存储结构、模式匹配算法与数组的特殊存储以及广义表的说明</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-3</title>
    <link href="https://zwiewings.github.io/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/"/>
    <id>https://zwiewings.github.io/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/</id>
    <published>2021-04-22T07:00:56.000Z</published>
    <updated>2021-05-12T12:20:49.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="css格式定义"><a href="#css格式定义" class="headerlink" title="css格式定义"></a>css格式定义</h3><p>css样式设置由选择器和声明部分组成，示例如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器类型&#123;</span><br><span class="line">属性1:值1;</span><br><span class="line">属性2:值2;</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，作为分隔每个属性的标志，最末尾的属性后的分号可以省略，但规范上是不省略的</p><h3 id="css样式调用"><a href="#css样式调用" class="headerlink" title="css样式调用"></a>css样式调用</h3><p>分为：行内样式表，内部样式表，链入外部样式表</p><p>以下为链入外部样式表的两种方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方法1：<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;相对地址&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheeet&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">方法2：<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> url(<span class="string">&quot;相对地址&quot;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：也可以在当前网页内以css的方式写入本网页的样式（如行内样式表和内部样式表），但是该样式仅作用于该网页，而且夹杂于内容中，故不推荐使用</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器：p、hn等标签"><a href="#标签选择器：p、hn等标签" class="headerlink" title="标签选择器：p、hn等标签"></a>标签选择器：p、hn等标签</h3><p>代表该标签的共性，用css修改时，将会作用于当前网页所有该标签</p><p>调用方式：直接使用定义的标签</p><p>选择器类型：指定的标签名字</p><h3 id="类选择器：以-开头"><a href="#类选择器：以-开头" class="headerlink" title="类选择器：以.开头"></a>类选择器：以.开头</h3><p>把相同类型的元素分类定义成不同的样式，用css修改时，将改变这一类的所有元素样式</p><p>调用方式：class=”类选择器的名字”（多个效果可用空格隔开）</p><p>选择器类型：.类选择器名</p><p><strong>注意：</strong></p><ul><li>不要试图用一个类名，把某个标签的所有样式写完，一个标签应该多携带几个类</li><li>每个类要尽可能的小，以达到公共性</li></ul><h3 id="id选择器：以-开头"><a href="#id选择器：以-开头" class="headerlink" title="id选择器：以#开头"></a>id选择器：以#开头</h3><p>代表某一元素的个性，用css修改时，只改变当前元素的样式</p><p>调用方式：id=”id选择器的名字”</p><p>选择器类型：#id选择器的名字</p><p>注：id选择器在文档中只能使用一次，而类选择器可以使用多次</p><h3 id="通配符选择器：“-”"><a href="#通配符选择器：“-”" class="headerlink" title="通配符选择器：“*”"></a>通配符选择器：“*”</h3><p>作用于所有的标签样式，用css修改时会改变所有使用该css的网页样式</p><p>使用方式：不需要调用，在css文件链接时直接附加</p><h3 id="群组选择器-并集选择器：“-”"><a href="#群组选择器-并集选择器：“-”" class="headerlink" title="群组选择器/并集选择器：“,”"></a>群组选择器/并集选择器：“,”</h3><p>表达“或”的含义，部分样式相同或完全相同时使用</p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名1,标签名2,……&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="标签指定式选择器-交集选择器"><a href="#标签指定式选择器-交集选择器" class="headerlink" title="标签指定式选择器/交集选择器"></a>标签指定式选择器/交集选择器</h3><p>表达“和”的含义，同时使用标签选择器和类选择器或者同时使用标签选择器和id选择器</p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名.类名&#123;属性表&#125;</span><br><span class="line">标签名#id&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="包含选择器-后代选择器"><a href="#包含选择器-后代选择器" class="headerlink" title="包含选择器/后代选择器"></a>包含选择器/后代选择器</h3><p>选择元素或元素组的后代，也称后代选择器，把外层标签写在前面，内层标签写在后面，中间用空格分隔</p><p>使用方式：（两个选择器中间必须有空格）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器1 选择器2&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>为拥有指定属性的html元素设置样式，不局限于class和id属性，下表以attribute代替属性选择器名</p><table><thead><tr><th align="center">选择器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[attribute]</td><td align="center">选取带有指定属性的元素</td></tr><tr><td align="center">[attribute=value]</td><td align="center">选取带有指定属性且取值为value的元素</td></tr><tr><td align="center">[attribute~=value]</td><td align="center">选取属性值中包含指定词汇的元素</td></tr><tr><td align="center">[attribute|=value]</td><td align="center">选取带有指定值开头的属性值的元素，值必须是整个单词</td></tr><tr><td align="center">[attribute^=value]</td><td align="center">匹配属性值以指定值开头的每个元素</td></tr><tr><td align="center">[attribute$=value]</td><td align="center">匹配属性值以指定值结尾的每个元素</td></tr><tr><td align="center">[attribute]*=value]</td><td align="center">匹配属性值中包含指定值的每个元素</td></tr></tbody></table><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标签名[属性选择器名]&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">选择器为<span class="selector-attr">[attribute]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here]</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">选择器为<span class="selector-attr">[attribute=value]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here=red]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><p>主要包括子元素选择器，相邻兄弟选择器，普通兄弟选择器</p><table><thead><tr><th align="center">属性名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">子元素选择器（E&gt;F）</td><td align="center">选择所有作为E元素的<strong>直接子元素</strong>F，对更深一层的元素不起作用</td></tr><tr><td align="center">兄弟相邻选择器（E+F)</td><td align="center">选择<strong>紧跟</strong>在E元素<strong>后面</strong>的F元素，选择相邻的第一个兄弟元素</td></tr><tr><td align="center">普通兄弟选择器（E~F）</td><td align="center">选择E元素之后的<strong>所有</strong>兄弟元素F，作用于多个元素</td></tr></tbody></table><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">子元素选择器：</span><br><span class="line">标签名&gt;子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签内，直接子元素的<span class="selector-tag">a</span>标签都为红色</span><br><span class="line"></span><br><span class="line">兄弟相邻选择器：</span><br><span class="line">标签名+子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签同级的紧挨的下一个<span class="selector-tag">a</span>标签为红色</span><br><span class="line"></span><br><span class="line">普通兄弟选择器：</span><br><span class="line">标签名~子元素标签名&#123;属性表&#125;</span><br><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签后的所有同级的<span class="selector-tag">a</span>标签都是红色</span><br></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="超链接伪类选择器"><a href="#超链接伪类选择器" class="headerlink" title="超链接伪类选择器"></a>超链接伪类选择器</h4><table><thead><tr><th align="center">伪类名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">a:link</td><td align="center">未访问时的超链接状态</td></tr><tr><td align="center">a:visited</td><td align="center">访问后的超链接的状态（也可用于普通非链接元素:visited）</td></tr><tr><td align="center">a:hover</td><td align="center">鼠标经过、悬停时超链接的状态</td></tr><tr><td align="center">a:active</td><td align="center">鼠标单击不动时超链接的状态（也可用于普通非链接元素:active）</td></tr></tbody></table><p><strong><em>注：</em></strong></p><ul><li><strong><em>样式必须符合link、visited、hover、active顺序</em></strong></li><li><strong><em>在css定义中，a:hover必须被置于a:link和a:visited后才有效</em></strong></li><li><strong><em>a:active必须被置于a:hover之后才有效</em></strong></li></ul><p>使用方法：（以a:link和h1为例）</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">a:link&#123;属性表&#125;       &lt;!--超链接伪类选择器--&gt;</span><br><span class="line">h1:hover&#123;属性表&#125;  &lt;!--普通非链接元素伪类选择器--&gt;</span><br></pre></td></tr></table></figure><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:root</td><td align="center">将样式绑定到页面的根元素中（即指位于文档树中最顶层结构的html标签）</td></tr><tr><td align="center">:not</td><td align="center">用于选择除某个元素之外的所有元素</td></tr><tr><td align="center">:empty</td><td align="center">指定当元素内容为空白时使用的样式</td></tr><tr><td align="center">:target</td><td align="center">对页面中某个target元素指定样式，只在用户点击链接并跳转到target元素后生效</td></tr></tbody></table><p>其中，:target使用时，前面不需要添加标签名，在锚点跳转后应用于跳转到的位置</p><h4 id="子元素伪类选择器"><a href="#子元素伪类选择器" class="headerlink" title="子元素伪类选择器"></a>子元素伪类选择器</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>:first-child</td><td>对父元素中的第一个子元素指定样式</td></tr><tr><td>:last-child</td><td>对父元素中的最后一个子元素指定样式</td></tr><tr><td>:only-child</td><td>当某个父元素中只有一个子元素时使用的样式</td></tr><tr><td>:nth-child(n)</td><td>对指定序号的子元素设置样式（正数），表示第几个子元素</td></tr><tr><td>:nth-last-child(n)</td><td>对指定序号的子元素设置样式（正数），表示倒数第几个子元素</td></tr><tr><td>:nth-child(even)</td><td>所有正数第偶数个子元素，等同于:nth-child(2n)</td></tr><tr><td>:nth-child(odd)</td><td>所有正数第奇数个子元素，等同于:nth-child(2n+1)</td></tr><tr><td>:nth-last-child(even)</td><td>所有倒数第偶数个子元素</td></tr><tr><td>:nth-last-child(odd)</td><td>所有倒数第奇数个子元素</td></tr><tr><td>:nth-of-type(n)</td><td>用于匹配属于父元素的特定类型的第n个子元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>用于匹配属于父元素的特定类型的倒数第n个子元素</td></tr></tbody></table><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是针对css中已经定义的伪元素使用的选择器，css中主要使用的伪元素为“:before”伪元素选择器和”:after”伪元素选择器</p><h4 id="before伪元素选择器"><a href="#before伪元素选择器" class="headerlink" title=":before伪元素选择器"></a>:before伪元素选择器</h4><p>用于在被选元素的内容前面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>element表示元素，“{}”中的content属性用来指定要插入的具体内容，既可以为文本也可以为图片</p><h4 id="after伪元素选择器"><a href="#after伪元素选择器" class="headerlink" title=":after伪元素选择器"></a>:after伪元素选择器</h4><p>用于在被选元素内容的后面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>如果子元素定义的样式没有和父元素冲突，那么将继承父元素的样式，可以再加以修改，并不会影响父元素</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，strong标签为em标签的父元素，em标签为strong标签的子元素</p><p><strong><em>注：</em></strong></p><ul><li><strong><em>实际开发中，通常对使用较多的字体、文本属性使用继承，在body中统一设置字体、字号、颜色、行距等</em></strong></li><li><strong><em>文本属性（如color、font-类等）具有继承性，但对于元素的布局属性、盒模型属性（如背景属性、边框属性、外边距属性、内边距属性、定位属性、布局属性、元素宽高属性等）都不能继承</em></strong></li></ul><h2 id="优先级说明"><a href="#优先级说明" class="headerlink" title="优先级说明"></a>优先级说明</h2><h3 id="基本优先级"><a href="#基本优先级" class="headerlink" title="基本优先级"></a>基本优先级</h3><ul><li>各种选择器不冲突时将全部应用</li><li>某些选择器冲突时，冲突部分将会以行内样式&gt;id选择器&gt;class选择器&gt;标签选择器的顺序优先应用</li><li>优先级相同时，在冲突部分，后定义的选择器内容将覆盖前面的选择器</li></ul><h3 id="优先级修改"><a href="#优先级修改" class="headerlink" title="优先级修改"></a>优先级修改</h3><p>在使用时，可以用!important关键字将某个选择器的优先级提到最高，但一般还是建议统筹设计</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue <span class="meta">!important</span>;</span><br><span class="line"><span class="attribute">font-style</span>:italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，p标签中的颜色被设定成了最高优先级，如果p标签的字体颜色样式与其他选择器冲突，则优先运用p标签中定义的“blue”</p><h3 id="权值计算"><a href="#权值计算" class="headerlink" title="权值计算"></a>权值计算</h3><p>如果用具体的权值描述样式的优先级，优先级从低到高如下排列：</p><ol><li>继承样式——0分</li><li>标签选择器——1分</li><li>伪元素或对象选择器——1分</li><li>类选择器——10分</li><li>属性选择器——10分</li><li>id选择器——100分</li><li>行内样式——1000分</li><li>！important——无穷大</li></ol>]]></content>
    
    
    <summary type="html">关于h5网页与css联合使用时，css文件的基础书写说明</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="css" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/css/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-6</title>
    <link href="https://zwiewings.github.io/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/"/>
    <id>https://zwiewings.github.io/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/</id>
    <published>2021-04-17T14:12:16.000Z</published>
    <updated>2021-05-12T12:19:30.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚步声与相机晃动"><a href="#脚步声与相机晃动" class="headerlink" title="脚步声与相机晃动"></a>脚步声与相机晃动</h1><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>实现角色在默认地板、木质地板和金属地板上的不同脚步声以及行走时的相机晃动</p><h2 id="函数写入位置"><a href="#函数写入位置" class="headerlink" title="函数写入位置"></a>函数写入位置</h2><p>全局函数库、玩家角色蓝图</p><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h3><p>创建相机晃动（下图为参考数值），需要勾上单一实例，保证每次使用只晃动一次</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/1.png" alt="1"></p><h3 id="脚步声"><a href="#脚步声" class="headerlink" title="脚步声"></a>脚步声</h3><ol><li><p>导入材质、脚步声</p></li><li><p>创建物理材质，表面类型需要在项目设置中先添加再修改，以下为项目设置界面</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/3.png" alt="3"></p></li><li><p>以其中一个音频为基础创建cue，并添加随机节点，实现多个同类音频随机播放（毕竟脚步声不可能每一步都是同一个声音），如图示例</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/2.png" alt="2"></p></li></ol>]]></content>
    
    
    <summary type="html">游戏场景细节制作及更多功能实现（未完）</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-5</title>
    <link href="https://zwiewings.github.io/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/"/>
    <id>https://zwiewings.github.io/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/</id>
    <published>2021-04-16T13:07:44.000Z</published>
    <updated>2021-05-12T12:19:22.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚幻文件夹结构"><a href="#虚幻文件夹结构" class="headerlink" title="虚幻文件夹结构"></a>虚幻文件夹结构</h1><h2 id="本地工程文件夹"><a href="#本地工程文件夹" class="headerlink" title="本地工程文件夹"></a>本地工程文件夹</h2><p>惯例为【Config】、【Content】、【DerivedDataCache】、【Intermediate】、【Saved】、【Script】六个文件夹，和一个后缀名为.uproject的文件（该文件为工程本体，在引擎中打开工程使用该文件）</p><h3 id="【Config】"><a href="#【Config】" class="headerlink" title="【Config】"></a>【Config】</h3><h3 id="【Content】"><a href="#【Content】" class="headerlink" title="【Content】"></a>【Content】</h3><h3 id="【DerivedDataCache】"><a href="#【DerivedDataCache】" class="headerlink" title="【DerivedDataCache】"></a>【DerivedDataCache】</h3><h3 id="【Intermediate】"><a href="#【Intermediate】" class="headerlink" title="【Intermediate】"></a>【Intermediate】</h3><h3 id="【Saved】"><a href="#【Saved】" class="headerlink" title="【Saved】"></a>【Saved】</h3><h3 id="【Script】"><a href="#【Script】" class="headerlink" title="【Script】"></a>【Script】</h3><h2 id="导入素材文件夹"><a href="#导入素材文件夹" class="headerlink" title="导入素材文件夹"></a>导入素材文件夹</h2><p>惯例为【Animations】、【Materials】、【Meshes】、【Map（Scenes）】、【Textures】五个文件夹，有时也有会将【Materials】、【Textures】、【Meshes】放在一个【character】文件夹下的构成</p><h3 id="【Animations】"><a href="#【Animations】" class="headerlink" title="【Animations】"></a>【Animations】</h3><p>【Animations】为该素材包内包括的动画序列，根据固定的骨骼执行，执行动画的网格体可以替换预览并实际替换使用</p><h3 id="【Materials】"><a href="#【Materials】" class="headerlink" title="【Materials】"></a>【Materials】</h3><p>【Materials】为该素材包内所用到的所有材质，一般通过【材质】蓝图修改或直接使用</p><h3 id="【Meshes】"><a href="#【Meshes】" class="headerlink" title="【Meshes】"></a>【Meshes】</h3><p>【Meshes】为该素材包内用到的所有骨架模型（骨骼网格体）、物理模型（物理资产）、骨骼，骨架模型是没有碰撞体积的，而物理模型能够表现受力（例如场景中运行时会受重力，和玩家角色重叠时会发生移动）</p><h3 id="【Map（scenes）】"><a href="#【Map（scenes）】" class="headerlink" title="【Map（scenes）】"></a>【Map（scenes）】</h3><p>【Map（Scenes）】为该素材包的场景地图，一般会有一个Overview场景，用于预览所有模型，动画，地形等该素材包的素材</p><h3 id="【Textures】"><a href="#【Textures】" class="headerlink" title="【Textures】"></a>【Textures】</h3><p>【Textures】为该素材包的所有贴图，包括材质贴图，法线贴图，场景贴花等，通常在【材质】蓝图中找到需要更改的属性，再对应的更改贴图以达到更改材质的效果</p>]]></content>
    
    
    <summary type="html">虚幻引擎本地工程文件夹与商城下载素材导入文件夹结构说明（未完）</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-1</title>
    <link href="https://zwiewings.github.io/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://zwiewings.github.io/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-04-16T11:55:41.000Z</published>
    <updated>2021-05-12T12:20:14.498Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.下载并安装jdk，jre，建议放置同一文件夹下</p><p>2.计算机-右键菜单-左侧高级系统设置-环境变量中，在下方系统变量内创建</p><p>JAVA_HOME——填写jdk文件夹内部绝对路径（如：D:/Java/Jdk）</p><p>CLASSPATH——填写下列内容（注：不能忘记开头的点和每个目录和目录下文件名后的分号）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure><p>找到系统变量的Path——新建以下内容（这里末尾没有分号）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure><p>以上Java环境变量配置完成，在cmd中输入java和javac出现对应命令使用方法说明则配置成功</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感：Java和c#一样区分大小写，使用时必须确保大小写完全一致</li><li>类名：类名首字母应该大写，由多个单词组成时，每个单词首字母大写</li><li>方法名：方法名以小写字母开头，由多个单词组成时，后面的每个单词首字母大写</li><li>源文件名：源文件名必须和类名相同，文件名后缀为.java</li><li>主方法入口:（类似c#中的main函数）程序由<strong>public static void main(String[] args)</strong> 开始执行</li><li>注释：可使用//和/**/进行单行注释和多行注释</li></ul><h2 id="标识符定义与修饰符"><a href="#标识符定义与修饰符" class="headerlink" title="标识符定义与修饰符"></a>标识符定义与修饰符</h2><h3 id="标识符定义"><a href="#标识符定义" class="headerlink" title="标识符定义"></a>标识符定义</h3><p>【包含类名、变量名以及方法名】</p><ul><li>应以字母，$，或下划线开头，字符组合也只能在前三种的基础上添加数字</li><li>关键字不能用作标识符，且标识符区分大小写</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table><thead><tr><th align="left">类别</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left">class</td><td align="left">类</td></tr><tr><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">super</td><td align="left">父类，超类</td></tr><tr><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">null</td><td align="left">空</td></tr></tbody></table><h2 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的文件名必须为HelloWorld，与类名相同</p><p>在cmd中进入目标文件所在位置，并输入javac HelloWorld.java，即可编译得到同目录下后缀名为.class的同名文件，再输入java HelloWorld（这里没有后缀名），即可运行该程序</p><p>对以上Hello World的入口说明（即方法/函数创建）：</p><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296">https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门教程&quot;&gt;&lt;a href=&quot;#入门教程&quot; class=&quot;headerlink&quot; title=&quot;入门教程&quot;&gt;&lt;/a&gt;入门教程&lt;/h1&gt;&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Java基础" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://zwiewings.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-4</title>
    <link href="https://zwiewings.github.io/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/"/>
    <id>https://zwiewings.github.io/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/</id>
    <published>2021-04-15T13:07:44.000Z</published>
    <updated>2021-05-12T12:19:14.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI智能"><a href="#AI智能" class="headerlink" title="AI智能"></a>AI智能</h1><h2 id="寻路导航创建"><a href="#寻路导航创建" class="headerlink" title="寻路导航创建"></a>寻路导航创建</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在主面板左上角的“放置actor”面板中找到“导航网格体边界体积”，放入场景中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/1.png" alt="1"></p><p>调整体积大小，将需要建构导航的场景放入该体积</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/2.png" alt="2"></p><p>点击后生成类似如图的绿色地面区域，这片区域为AI导航有效的区域</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/3.png" alt="3"></p><h3 id="实例：实现敌对NPC追踪角色移动"><a href="#实例：实现敌对NPC追踪角色移动" class="headerlink" title="实例：实现敌对NPC追踪角色移动"></a>实例：实现敌对NPC追踪角色移动</h3><p>思路：使用AI控制器沿创建好的导航移动敌对NPC，目标为玩家控制的角色，并循环操作</p><p>关卡蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/8.png" alt="8"></p><p>敌对NPC角色蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/4.png" alt="4"></p><p>（AI未完待续）</p><h1 id="动画序列与蓝图"><a href="#动画序列与蓝图" class="headerlink" title="动画序列与蓝图"></a>动画序列与蓝图</h1><h2 id="过场动画制作"><a href="#过场动画制作" class="headerlink" title="过场动画制作"></a>过场动画制作</h2><p>创建一个过场动画的关卡序列，命名并打开操作界面</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/9.png" alt="9"></p><p>新建一个相机剪切轨道，并且绑定用于拍摄过场动画的电影摄像机actor（或是直接在场景中选中指定相机，通过actor到sequencer直接添加），将相机移动到起始位置，添加变换轨道（或其他轨道）并在起始位置添加关键帧</p><p>制作动画时，其他actor也可添加移动轨道，详细在下一个子目录“动画轨道”中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/10.png" alt="10"></p><p>多次移动相机到指定位置，并在轨道上添加相应的关键帧（场景中能够看到相机移动的轨迹呈现），最后调整动画结束的准线，结束修改并保存</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/12.png" alt="12"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/11.png" alt="11"></p><p>当拍摄多个动画后，可将需要拼接的动画放入一个新的关卡序列中，上下移动调整轨道，左右移动调整播放顺序，并将结束准线对齐</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/13.png" alt="13"></p><p>多段动画中间可建立渐变轨道的关键帧，实现切换的淡入淡出</p><h2 id="动画轨道"><a href="#动画轨道" class="headerlink" title="动画轨道"></a>动画轨道</h2><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/14.png" alt="14"></p><p>Actor到Sequencer：创建一个控制actor的轨道，在场景中选中的actor会优先显示在顶端**<em>（创建actor后一般自带一个控制actor移动的transfrom轨道，也可以自己添加变换轨道）**</em></p><p>添加文件夹：可为多个轨道分类，放置于不同的文件夹下（好像没什么用的样子）</p><p>音频轨道：可在动画播放同时添加音频资产的播放</p><p>事件轨道：分为触发器和中继器（后者不常用），触发器轨道中添加了关键帧后，右键新建末端可新建图表事件，当时间轴移动到指定位置执行该事件</p><p>相机剪切轨道：用于添加相机轨道，使用actor到sequencer添加时也会自动创建</p><p>镜头轨道：用于拼接多个镜头的轨道，也可以实现多个动画序列之间的拼接</p><p>时间膨胀轨道：用于设置播放倍率的关键帧，实现部分慢镜头和快进</p><p>渐变轨道：添加动画的黑幕（1为全黑，0为透明），多个关键帧可实现淡入淡出</p><p><strong><em>【注：如果在单独一个元件下添加轨道，则所有轨道都作为其子元件，该元件的组件也可以实现调用为子元件，同时，在单一元件下还能够创建可视性轨道，调整特定时间下的actor是否可见。</em></strong></p><p><strong><em>特别地，对于相机actor来说，需要先获取CameraComponent子元件才能够更改具体具体属性（如：曝光补偿等）】</em></strong></p><h2 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h2><p>【需要创建蓝图类-MatineeCameraShake文件】</p><h4 id="振荡设置"><a href="#振荡设置" class="headerlink" title="振荡设置"></a>振荡设置</h4><p>振荡时长：振荡的总时长</p><p>振荡混入时间：振荡开始的时间</p><p>振荡混出时间：振荡结束的时间</p><p>旋转振荡：实现镜头的各方位旋转振荡（如决定上下振荡或者左右振荡，或者两者混合等）</p><p>位置振荡：实现镜头的移动性振荡（如决定相机位置前后振荡等）</p><p>FOV振荡：实现镜头的缩放性振荡（相机位置不变，只是镜头缩放）</p><h4 id="具体蓝图使用"><a href="#具体蓝图使用" class="headerlink" title="具体蓝图使用"></a>具体蓝图使用</h4><ol><li><p>在需要使用的蓝图流程中加入以下结点</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/15.png" alt="15"></p></li></ol><ol start="2"><li><p>在动画序列中相机组件下添加相机晃动子元件，可以拖拽缩放抖动条</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/16.png" alt="16"></p></li></ol><h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p>打开某个骨骼/网格体/动画序列/物理模型时，可在右上角看到动画蓝图标识</p><p><strong><em>【注：此处以第三人称游戏模板的小白人为例】</em></strong></p><p>打开默认的动画图表【AnimGraph】，找到默认状态机，双击打开</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/5.png" alt="5"></p><p>状态机内部蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-1.png" alt="6-1"></p><p>Entry为一个输入/起始点，Idle/Run节点为走或跑时，JumpStart、Loop、End分别为跳跃的开始，腾空，落地过程，四个节点分别播放不同的动画，双箭头为四个节点互相切换的条件（右键添加状态可添加节点，通过节点引线引出的新节点与原节点之间自带转换条件）</p><p>Idle/Run节点内部：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-2.png" alt="6-2"></p><p>此处混合空间播放器节点下方为一段动画，具有三个白色关键帧（第一个与绿色关键帧重合），由绿色关键帧的位置（speed的大小）决定播放的动画，而在动画播放时，绿色关键帧如果未到达下一个白色关键帧，将循环播放上一个白色关键帧的动画</p><p>JumpStart、Loop、End节点内部：</p><p><strong><em>【注：因为结构相同故而使用JumpStart作为范例】</em></strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-3.png" alt="6-3"></p><p>由Idle/Run节点到JumpStart与从JumpLoop到JumpEnd节点的切换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-5.png" alt="6-5"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-6.png" alt="6-6"></p><p>前者：判断角色是否在空中，如果是，转换到下一个节点（即JumpStart节点）</p><p>后者：判断角色是否不在空中，如果是，转换到下一个节点（即JumpEnd节点）</p><p>由JumpStart到JumpLoop与由JumpEnd到Idle/Run节点的转换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-4.png" alt="6-4"></p><p>判断前一个节点（JumpStart或JumpEnd）中动画资产播放的剩余时间是否小于0.1，如果是，则转换到下一个节点（JumpLoop或Idle/Run）</p><p>动画蓝图事件图表：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/7.png" alt="7"></p>]]></content>
    
    
    <summary type="html">AI寻路导航与动画序列、动画蓝图节点讲解与制作</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-4</title>
    <link href="https://zwiewings.github.io/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/"/>
    <id>https://zwiewings.github.io/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</id>
    <published>2021-04-14T12:10:46.000Z</published>
    <updated>2021-05-12T12:17:37.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">Elemtype *base;&#x2F;&#x2F;储存空间的基址指针</span><br><span class="line">int front;&#x2F;&#x2F;定义一个头指针</span><br><span class="line">int rear;&#x2F;&#x2F;定义一个尾指针</span><br><span class="line">&#125;SQqueue;</span><br></pre></td></tr></table></figure><p><strong>注：此处front和rear指针仅仅设为了int类型，而并非真正的指针类型，所表述的是队头队尾元素所在的位置下标</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool initqueue(SQqueue &amp;sq)</span><br><span class="line">&#123;</span><br><span class="line">sq.base&#x3D;new Elemtype[MAXSIZE];&#x2F;&#x2F;为队列分配空间</span><br><span class="line">if(!sq.base) return false;&#x2F;&#x2F;没能分配成功，返回失败</span><br><span class="line">sq.front&#x3D;sq.rear&#x3D;0;&#x2F;&#x2F;头尾指针置为零，队列为空</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int queuelength(SQqueue &amp;sq)</span><br><span class="line">&#123;</span><br><span class="line">return (sq.rear-sq.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在没有特殊注明的情况下，所说队列都为循环队列，front指向队头元素，rear指向队尾元素的后一个元素，为区分队空与队满，此处少用一个元素空间，即队列空间大小为m-1个元素时队满，故而当队列满足“rear=front“时队空，当队列满足”(rear+1)%MAXSIZE=front“时队满。</p><h2 id="入队（从队尾插入）"><a href="#入队（从队尾插入）" class="headerlink" title="入队（从队尾插入）"></a>入队（从队尾插入）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool enterqueue(SQqueue &amp;sq,Elemtype e)  &#x2F;&#x2F;传址需要操作的表，传值入队元素</span><br><span class="line">&#123;</span><br><span class="line">if((sq.rear+1)%MAXSIZE&#x3D;&#x3D;sq.front) return false;    &#x2F;&#x2F;判断队满时返回失败</span><br><span class="line">sq.base[sq.rear]&#x3D;e; &#x2F;&#x2F;让队尾元素的后一个元素等于e</span><br><span class="line">sq.rear&#x3D;(sq.rear+1)%MAXSIZE; &#x2F;&#x2F;队尾指针后移</span><br><span class="line">return true；&#x2F;&#x2F;返回成功入队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队（从队头删除）"><a href="#出队（从队头删除）" class="headerlink" title="出队（从队头删除）"></a>出队（从队头删除）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool deletequeue(SQqueue &amp;sq,Elemtype &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">if(sq.front&#x3D;&#x3D;sq.rear) return false;&#x2F;&#x2F;若队空，则返回出队失败</span><br><span class="line">e&#x3D;sq.base[sq.front];&#x2F;&#x2F;用e获得出队的队头元素</span><br><span class="line">sq.front&#x3D;(sq.front+1)%MAXSIZE;&#x2F;&#x2F;队头指针后移</span><br><span class="line">return true;&#x2F;&#x2F;返回成功出队</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Elemtype gethead(SQqueue &amp;sq)</span><br><span class="line">&#x2F;&#x2F;仅返回表的队头元素，不修改头指针</span><br><span class="line">&#123;</span><br><span class="line">if(sq.front!&#x3D;sq.rear) &#x2F;&#x2F;判断队列非空</span><br><span class="line">return sq.base[sq.front];&#x2F;&#x2F;返回队头元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-4-队列操作-20-分"><a href="#R7-4-队列操作-20-分" class="headerlink" title="R7-4 队列操作 (20 分)"></a>R7-4 队列操作 (20 分)</h2><p>请实现一个MyQueue类，实现出队，入队，求队列长度.</p><p>实现入队函数 void push(int x); 实现出队函数 int pop(); 实现求队列长度函数 int size();</p><p>输入格式:<br>每个输入包含1个测试用例。每个测试用例第一行给出一个正整数 n (n &lt;= 10^6) ，接下去n行每行一个数字，表示一种操作： 1 x ： 表示从队尾插入x，0&lt;=x&lt;=2^31-1。 2 ： 表示队首元素出队。 3 ： 表示求队列长度。</p><p>输出格式:<br>对于操作2,若队列为空，则输出 “Invalid”,否则请输出队首元素。 对于操作3，请输出队列长度。 每个输出项最后换行。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 100</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">Invalid</span><br><span class="line">1</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQueue &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.front=<span class="number">0</span>;</span><br><span class="line">    sq.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(SQueue &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sq.rear-sq.front+<span class="number">50</span>)%<span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">enter</span><span class="params">(SQueue &amp;sq,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((sq.rear+<span class="number">1</span>)%<span class="number">50</span>==sq.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.base[sq.rear]=a;</span><br><span class="line">    sq.rear=(sq.rear+<span class="number">1</span>)%<span class="number">50</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">out</span><span class="params">(SQueue &amp;sq,<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.front==sq.rear) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">a=sq.base[sq.front];</span><br><span class="line">sq.front=(sq.front+<span class="number">1</span>)%<span class="number">50</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQueue L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">int</span> n,i,j,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;j;</span><br><span class="line">        <span class="keyword">switch</span>(j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">                enter(L,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(out(L,k)) <span class="built_in">cout</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Invalid&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;length(L)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于顺序队列的创建、初始化、求队长和出队入队操作及代码实例</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-3</title>
    <link href="https://zwiewings.github.io/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/"/>
    <id>https://zwiewings.github.io/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</id>
    <published>2021-04-14T07:37:35.000Z</published>
    <updated>2021-05-12T12:17:28.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>【Elemtype为数据类型】</p><p>顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相较普通顺序表简单。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype *base;<span class="comment">//定义栈底指针</span></span><br><span class="line">Elemtype *top;<span class="comment">//定义栈顶指针</span></span><br><span class="line"><span class="keyword">int</span> maxsize;<span class="comment">//定义最大栈的最大容量</span></span><br><span class="line">&#125;SQstack;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initstack</span><span class="params">(SQstack &amp;sq)</span><span class="comment">//传址需要初始化的表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sq.base=<span class="keyword">new</span> Elemtype[MAXSIZE];</span><br><span class="line"><span class="comment">//分配大小为MAXSIZE的空间，并返回首地址给表的栈底指针</span></span><br><span class="line"><span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//若分配失败则返回</span></span><br><span class="line">sq.top=sq.base;<span class="comment">//栈顶指针等于栈底指针，表示空栈</span></span><br><span class="line">sq.maxsize=MAXSIZE;<span class="comment">//记录栈的最大容量为MAXSIZE</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回创建成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈（从栈顶插入）"><a href="#入栈（从栈顶插入）" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SQstack &amp;sq,Elemtype e)</span><span class="comment">//传址需要操作的栈，传值需要入栈的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sq.top-sq.base&gt;=sq.maxsize) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//若栈顶指针与栈底指针的差为最大空间（即栈满），返回入栈失败</span></span><br><span class="line">    *sq.top=e;</span><br><span class="line"><span class="comment">//栈顶指针总是指在栈顶元素的下一个位置，故而直接赋值</span></span><br><span class="line">sq.top++;<span class="comment">//栈顶指针后移</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回入栈成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（从栈顶删除）"><a href="#出栈（从栈顶删除）" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SQstack &amp;sq,Elemtype &amp;e)</span><span class="comment">//传址需要操作的表和出栈的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//若栈顶指针与栈底指针相同（即栈空），则返回失败</span></span><br><span class="line">sq.top--;</span><br><span class="line"><span class="comment">//栈顶指针总是指在栈顶元素的下一个位置，故而栈顶指针后移</span></span><br><span class="line">e=*sq.top;<span class="comment">//将出栈的元素传给e</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取栈顶（取值）"><a href="#取栈顶（取值）" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">gettop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要操作的表，返回栈顶元素，该操作只取栈顶，不修改栈顶指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sq.top!=sq.base)<span class="comment">//若该栈非空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *(sq.top<span class="number">-1</span>);<span class="comment">//取栈顶指针的前一个位置，即栈顶元素向外传递</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>【Elemtype为数据类型】</p><p>在无法估计栈数据量时，通常采用链式栈，而且因为栈的主要操作是插入和删除，所以用链表的头部作栈顶更加方便。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elemtype data;<span class="comment">//定义链表结点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span><span class="comment">//定义指向下一节点的指针域</span></span><br><span class="line">&#125;*Linkstack;</span><br></pre></td></tr></table></figure><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initstack</span><span class="params">(Linkstack &amp;ls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ls=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//由于栈不需要对栈顶以外的元素操作，故而不需要设置头结点来使表头操作与表中表尾一致</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回初始化成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈（从栈顶插入）-1"><a href="#入栈（从栈顶插入）-1" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(Linkstack &amp;ls,Elemtype e)</span><span class="comment">//传址需要操作的表，传值需要插入的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Lnode *p;</span><br><span class="line">p=<span class="keyword">new</span> Lnode;<span class="comment">//重新分配一个结点空间，首地址赋给p</span></span><br><span class="line">p-&gt;data=e;<span class="comment">//新结点的数据域为e</span></span><br><span class="line">p-&gt;next=ls;<span class="comment">//新结点的指针域指向头指针ls，即将新结点作头插</span></span><br><span class="line">ls=p;<span class="comment">//头指针前移</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回入栈成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈（从栈顶删除）-1"><a href="#出栈（从栈顶删除）-1" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(Linkstack &amp;ls，Elemtype &amp;e)</span>   <span class="comment">//传址需要操作的表和出栈的元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈空则返回删除失败</span></span><br><span class="line">e=ls-&gt;data;<span class="comment">//e接收出栈元素</span></span><br><span class="line">Lnode *p=ls;<span class="comment">//定义一个p指针指向原栈顶元素</span></span><br><span class="line">ls=ls-&gt;next;<span class="comment">//让头指针后移</span></span><br><span class="line"><span class="keyword">delete</span> p;<span class="comment">//删除p指向的结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//返回删除完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取栈顶（取值）-1"><a href="#取栈顶（取值）-1" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">gettop</span><span class="params">(Linkstack &amp;ls)</span><span class="comment">//传址需要操作的表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)<span class="comment">//栈非空</span></span><br><span class="line"><span class="keyword">return</span> ls-&gt;data;<span class="comment">//返回栈顶元素的值，栈顶指针不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-1-堆栈操作合法性-20-分"><a href="#R7-1-堆栈操作合法性-20-分" class="headerlink" title="R7-1 堆栈操作合法性 (20 分)"></a>R7-1 堆栈操作合法性 (20 分)</h2><p>假设以S和X分别表示入栈和出栈操作。如果根据一个仅由S和X构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入S和X序列，判断该序列是否合法。</p><p>输入格式:<br>输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由S和X构成的序列。序列保证不为空，且长度不超过100。</p><p>输出格式:<br>对每个序列，在一行中输出YES如果该序列是合法的堆栈操作序列，或NO如果不是。</p><p>输入样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 10</span><br><span class="line">SSSXXSXXSX</span><br><span class="line">SSSXXSXXS</span><br><span class="line">SSSSSSSSSSXSSXXXXXXXXXXX</span><br><span class="line">SSSXXSXXX</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[m];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=m;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=e;</span><br><span class="line">    sq.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    SQstack L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        init(L,m);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;str[j]!=<span class="string">&#x27;\0&#x27;</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]==<span class="string">&#x27;S&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                flag=push(L,str[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[j]==<span class="string">&#x27;X&#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                flag=pop(L);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.base==L.top&amp;&amp;flag==<span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="R7-2-回文判断-20-分"><a href="#R7-2-回文判断-20-分" class="headerlink" title="R7-2 回文判断 (20 分)"></a>R7-2 回文判断 (20 分)</h2><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p><p>输入格式:<br>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p><p>输出格式:<br>若字符序列是回文，输出“YES”；否则，输出“NO”。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abdba</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=a;</span><br><span class="line">    sq.top++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gettop</span><span class="params">(SQstack &amp;sq,<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.base==sq.top) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a=*(sq.top<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQstack L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> i,n=<span class="number">0</span>,a;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">    n=str.size();</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n/<span class="number">2</span>) push(L,str[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                gettop(L,a);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(str[i]==a) pop(L);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==(n<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;(n<span class="number">-1</span>)/<span class="number">2</span>) push(L,str[i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    gettop(L,a);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(str[i]==a) pop(L);</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="R7-3-括号匹配-20-分"><a href="#R7-3-括号匹配-20-分" class="headerlink" title="R7-3 括号匹配 (20 分)"></a>R7-3 括号匹配 (20 分)</h2><p>检查一段C语言代码的小括号( )、 中括号 [ ] 和大括号{ } 是否匹配。</p><p>输入格式:<br>在一行中输入一段C语言代码，长度不超过1000个字符（行末以换行符结束）。</p><p>输出格式:<br>第一行输出左括号的数量和右括号的数量，中间以一个空格间隔。<br>若括号是匹配的，在第二行打印YES，否则打印NO。</p><p>输入样例1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;v; i++)&#123; visited[i] &#x3D; 0; for(int j&#x3D;0; j&lt;v; j++) scanf(&quot;%d&quot;,&amp;(g-&gt;Adj[i][j])); &#125;</span><br></pre></td></tr></table></figure><p>输出样例1:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 8</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>输入样例2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(int i&#x3D;0; i&lt;v; i++) a(i]&#x3D;0;</span><br></pre></td></tr></table></figure><p>输出样例2:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *top;</span><br><span class="line">    <span class="keyword">char</span> *base;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">&#125;SQstack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.base=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.top=sq.base;</span><br><span class="line">    sq.size=<span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top-sq.base==sq.size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    *sq.top=a;</span><br><span class="line">    sq.top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(SQstack &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    sq.top--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gettop</span><span class="params">(SQstack &amp;sq,<span class="keyword">char</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sq.top==sq.base) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    a=*(sq.top<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SQstack L;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">char</span> a=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i,left=<span class="number">0</span>,right=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">500</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;(&#x27;</span>||str[i]==<span class="string">&#x27;[&#x27;</span>||str[i]==<span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            push(L,str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>||str[i]==<span class="string">&#x27;]&#x27;</span>||str[i]==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right++;</span><br><span class="line">            gettop(L,a);</span><br><span class="line">            <span class="keyword">if</span>((str[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;a==<span class="string">&#x27;(&#x27;</span>)||(str[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;a==<span class="string">&#x27;[&#x27;</span>)||(str[i]==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;a==<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                pop(L);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L.top!=L.base) flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>) flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;left&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;right&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于栈的顺序存储与链式存储实现算法与代码实例</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-3</title>
    <link href="https://zwiewings.github.io/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/"/>
    <id>https://zwiewings.github.io/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/</id>
    <published>2021-04-13T12:28:08.000Z</published>
    <updated>2021-05-12T12:19:06.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础功能实现"><a href="#基础功能实现" class="headerlink" title="基础功能实现"></a>基础功能实现</h1><h2 id="人物操作功能"><a href="#人物操作功能" class="headerlink" title="人物操作功能"></a>人物操作功能</h2><h3 id="疾跑"><a href="#疾跑" class="headerlink" title="疾跑"></a>疾跑</h3><p>思路:在按下对应键（暂定shift）时，更改人物行走最大速度</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/1.png" alt="1"></p><h3 id="射击（创建发射物）"><a href="#射击（创建发射物）" class="headerlink" title="射击（创建发射物）"></a>射击（创建发射物）</h3><p>思路：在按下对应键（暂定鼠标左键）时，生成一个发射物</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/2.png" alt="2"></p><h3 id="过肩视角"><a href="#过肩视角" class="headerlink" title="过肩视角"></a>过肩视角</h3><p>思路：在按下对应键时（暂定鼠标右键），让视角缓缓变成过肩视角</p><p>玩家角色蓝图：（时间轴具体操作参考之前的节点介绍）</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/3.png" alt="3"></p><h3 id="★线检★"><a href="#★线检★" class="headerlink" title="★线检★"></a>★线检★</h3><p><strong><em>【注：案例的线检中“线”的长度为1000单位】</em></strong></p><p>思路：在actor正前方的创造一根不可见的线检测前方的物体，输出被检测到的物体，以便实现判断交互</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/4.png" alt="4"></p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p><strong><em>【注：案例中的”医疗包”为触碰即获得并消失，“门”为被线检到（最大距离为线的长度），并且按下F键时，实现“开门”，物体2为人物处于更小的范围或其他范围内，并按下F键时，实现拾取】</em></strong></p><p>思路：</p><ol><li>利用使用线检和类型转换判断物体属于什么类型，或判断开始重叠，然后执行对应的操作</li><li>在按下对应键时（暂定F键），判断可交互性，并判断线检检测到的物体，执行对应的自定义事件</li><li>在要交互的物体蓝图中设置其交互时执行的具体操作，即定义自定义事件</li></ol><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/5.png" alt="5"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/6.png" alt="6"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/9.png" alt="9"></p><p>“医疗包”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/10.png" alt="10"></p><p>“门”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/7.png" alt="7"></p><p>“物品2”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/8.png" alt="8"></p><h2 id="界面HUD"><a href="#界面HUD" class="headerlink" title="界面HUD"></a>界面HUD</h2><h3 id="显示HUD"><a href="#显示HUD" class="headerlink" title="显示HUD"></a>显示HUD</h3><p>思路：创建HUD控件之后，显示到视口</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/11.png" alt="11"></p><h3 id="显示交互按钮及其名称"><a href="#显示交互按钮及其名称" class="headerlink" title="显示交互按钮及其名称"></a>显示交互按钮及其名称</h3><p>指定/创建绑定函数：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/14.png" alt="14"></p><p><strong><em>（注：在文本、百分比、可视性等多个数据都可以使用函数绑定返回值来实现动态显示）</em></strong></p><p>思路：</p><ol><li>判断当前物体类型，按钮子项的文本函数返回不同的文本</li><li>判断当前物体是否为可交互物，可交互显示按钮，不可交互隐藏按钮</li></ol><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/12.png" alt="12"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/13.png" alt="13"></p><h3 id="显示角色血条"><a href="#显示角色血条" class="headerlink" title="显示角色血条"></a>显示角色血条</h3><p>思路：HUD中创建一个进度条，进度-百分比使用函数绑定，读取玩家角色的变量HP并返回</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/15.png" alt="15"></p><h3 id="制作标题及设置页面控件"><a href="#制作标题及设置页面控件" class="headerlink" title="制作标题及设置页面控件"></a>制作标题及设置页面控件</h3><p>标题页面控件：</p><ul><li><strong>事件构造时——“显示光标”，并”设置输入模式仅UI“</strong></li><li>开始——点击button时，执行“打开关卡”节点</li><li>退出——点击button时，执行“退出游戏”节点</li><li>设置——点击button时，创建“设置页面控件”，并“添加到视口”，将原来的标题控件“从父项中移除”</li></ul><p>设置页面控件：</p><p><strong><em>注：虚幻本身具有调节各种画质的设置，仅需要调用这套设置即可</em></strong></p><p>组合框设置初始显示值（显示当前抗锯齿与视图距离为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/17.png" alt="17"></p><p>组合框设置（后期处理质量设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/18.png" alt="18"></p><p>滑条操作（分辨率缩放设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/19.png" alt="19"></p><p>返回按钮：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/20.png" alt="20"></p>]]></content>
    
    
    <summary type="html">以第三人称模板为例的基础人物操作与HUD显示功能实现</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-2</title>
    <link href="https://zwiewings.github.io/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/"/>
    <id>https://zwiewings.github.io/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/</id>
    <published>2021-04-13T05:51:17.000Z</published>
    <updated>2021-05-12T12:18:22.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表单结构"><a href="#表单结构" class="headerlink" title="表单结构"></a>表单结构</h1><p>表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介</p><h2 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h2><ul><li><h3 id="表单标签-form"><a href="#表单标签-form" class="headerlink" title="表单标签-form"></a>表单标签-form</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get/post&quot;</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br><span class="line">    填入表单域和表单按钮等</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>action：</strong>表示接受并处理表单数据的服务器程序的url地址</p><p><strong>method：get</strong>为默认，表单数据和URL一起发送，提交的数据显示在浏览器地址栏中，保密性差，有数据量限制；<strong>post</strong>保密性好，并且无数据量限制，表单数据和URL分开发送，保密性好</p><p><strong>name：</strong>指定表单名称，以区分一个页面中的多个表单</p></li></ul><ul><li><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单常用控件</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>预览</th></tr></thead><tbody><tr><td>input type=“date”</td><td>日期选择框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/8.png" alt="8"></td></tr><tr><td>input type=“text”</td><td>单行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/1.png" alt="1"></td></tr><tr><td>input type=“password”</td><td>密码输入框（输入的文字用*表示）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/2.png" alt="2"></td></tr><tr><td>input type=“radio”</td><td>单选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/3.png" alt="3"></td></tr><tr><td>input type=”checkbox“</td><td>复选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/7.png" alt="7"></td></tr><tr><td>input type=“hidden”</td><td>隐藏域（不显示，供开发使用）</td><td>——————————</td></tr><tr><td>input type=“file”</td><td>文件域（上传文件）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/4.png" alt="4"></td></tr><tr><td>select</td><td>列表框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/5.png" alt="5"></td></tr><tr><td>textarea</td><td>多行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/6.png" alt="6"></td></tr></tbody></table></li></ul><p>  <strong>表单域常用属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>控件名称（公共属性，与每个表单域对应）</td></tr><tr><td>type</td><td>控件类型，如radio，text等</td></tr><tr><td>size</td><td>指定控件的宽度</td></tr><tr><td>value</td><td>用于设定输入默认值（公共属性，可用来指定输入区域默认值）</td></tr><tr><td>maxlength</td><td>在单行文本时允许输入的最大字符数</td></tr><tr><td>src</td><td>插入图像的地址</td></tr></tbody></table><ul><li><h3 id="表单按钮"><a href="#表单按钮" class="headerlink" title="表单按钮"></a>表单按钮</h3><p><strong>普通按钮:触发提交表单的动作，配合JavaScript使用</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name值&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>提交按钮：将表单中的信息提交给表单中action指向的文件</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;button_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>图片式提交按钮：指可以在按钮位置上放置图片，这幅图片具有提交按钮的功能</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>重置按钮：指清除已填写的表单内容，恢复为默认内容，重新填写</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="H5结构性标签"><a href="#H5结构性标签" class="headerlink" title="H5结构性标签"></a>H5结构性标签</h1><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>网页页眉的结构标签，位于网页的最上端，一般header标签至少包含但不局限于一个标题，还可以包括hgroup标签，包括表格内容，网页封面，logo图案，搜索表单和nav等。</p><h2 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h2><p>网页中的导航条，是navigator的缩写，常用无序列表的形式加上css外观配置实现，一般置于header下方。</p><p>nav标签可以应用于传统导航条，侧边栏导航，页内导航，翻页操作等场合</p><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>用于对网页中的内容进行分区分块，定义文档中的节。一般情况下，section标签常由标题和内容组成。</p><p><strong>注意：</strong></p><ul><li>section标签表示一段专题性的内容，一般会带有标题，没有标题的区块不要用section定义</li><li>根据实际情况来看，若是article标签，aside标签或是nav标签更符合使用条件，那么不要使用section标签</li><li>当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div标签而不是section</li></ul><h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><p>一个特殊的section标签，比section具有更明确的语义，代表一个独立的，完整的相关内容块，可独立于页面其他内容使用</p><p><strong>注意：</strong></p><ul><li>article标签会有标题部分，通常可以包含header，有时也会包含footer</li><li>article可以嵌套，内层的article对外层的article标签有着隶属关系，如博客的文章可以用article显示，一些评论也可以以article的形式嵌入其中</li></ul><h2 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h2><p>aside标签用来装载非正文的内容，被视为页面里单独的一个部分，作为页面或站点全局的附属信息部分，例如广告，友链，侧边栏，导航条等等，可以被article包含在内</p><h2 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h2><p>footer定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说作者和日期。</p><p>作为页面页脚时，一般包括版权，相关文件和链接</p><p>footer和header标签使用基本一样，可以在一个页面中多次使用，也可以在article或section中添加，相当于该区段的页脚</p><h2 id="框架示例："><a href="#框架示例：" class="headerlink" title="框架示例："></a>框架示例：</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>叮叮书店<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>网站logo·叮叮书店(div)<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;search&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span> <span class="attr">value</span>=<span class="string">&quot;搜索&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nav&quot;</span> <span class="attr">style</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书籍分类<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>特刊降价<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;cart&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;adv&quot;</span>&gt;</span></span><br><span class="line">此处用于添加广告</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;recommend&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>本周推荐<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;recommend-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书1标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span>书1<span class="tag">&lt;/<span class="name">mark</span>&gt;</span>简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;recommend-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书2标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>书2简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;new&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>最近新书<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;new-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effect-1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod4.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书3标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>书3简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;new-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书4标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effect-1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover-2&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;description-2&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书4标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>书4简介<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cart-more&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>加入购物车<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>详细内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>最近促销<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书5标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effort-1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/sale.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;sale-book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>书6标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;effort-1&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/prod3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sale&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/sale.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;advert&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad1.jpg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad2.jpg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/ad3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;best-selling&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>畅销图书<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling1.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书1名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书1现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书1原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling2.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书2名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书2现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书2原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书3名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书3现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书3原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling4.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书4名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书4现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书4原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书5<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;curr&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-pic&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/selling5.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c-text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>书5名<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>书5现价<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">del</span>&gt;</span>书5原价<span class="tag">&lt;/<span class="name">del</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;classify-partner&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;classify&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>图书分类<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>编程语言<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>图形图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>网页制作<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>考试认证<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;partner&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>合作伙伴<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国电子商务研究中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>清华大学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国人民大学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>中国社会科学出版社<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>关于书店<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picture&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/about.gif&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>书店介绍<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer-wrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>服务条款<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>隐私策略<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>copyright内容<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/vcss.gif&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span>通讯地址：</span><br><span class="line">电话：</span><br><span class="line"><span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于h5网页的表单结构标签与实际效果展示</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="html基础" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/html%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-2</title>
    <link href="https://zwiewings.github.io/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/"/>
    <id>https://zwiewings.github.io/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/</id>
    <published>2021-04-09T10:28:08.000Z</published>
    <updated>2021-05-12T12:18:58.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><p>普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可</p><h2 id="材质域（常用）"><a href="#材质域（常用）" class="headerlink" title="材质域（常用）"></a>材质域（常用）</h2><p>材质的类型一般由材质域区分（材质界面左下角中，细节页的材质栏）</p><ul><li><h3 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h3><p>普通的基本材质，如木质、铁质、玻璃等覆盖在表面的东西</p></li><li><h3 id="延迟贴花"><a href="#延迟贴花" class="headerlink" title="延迟贴花"></a>延迟贴花</h3><p>类似等同于喷漆，混合模式只能是半透明，如同投影一样覆盖在物体表面，本质是Actor组件，但可以作为只有一个贴花组件的Actor放入场景</p></li><li><h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用于UI显示，需要新建媒体播放器，使用媒体纹理生成材质，更改材质域为“用户界面”，在用户UI中添加图像时便可以使用该材质放入外观-笔刷中。</p><p>注：使用生成的材质时，需要在UI图表中添加默认值为该材质源媒体播放器的媒体播放器变量，并且事件构造中通过该变量添加对应播放器的“打开源”，如下图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/8.png" alt="8"></p></li></ul><p>左二接口接入媒体播放器（仅作为媒介），而左三接口则接入具体的视频媒体</p><h2 id="混合模式（常用）"><a href="#混合模式（常用）" class="headerlink" title="混合模式（常用）"></a>混合模式（常用）</h2><ul><li><h3 id="不透明"><a href="#不透明" class="headerlink" title="不透明"></a>不透明</h3><p>整个材质完全不透光，一般作为底层材质</p></li><li><h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><p>材质呈现半透明，可以和下层叠加，一般是作为贴花使用</p></li></ul><h2 id="材质节点引脚（常用）"><a href="#材质节点引脚（常用）" class="headerlink" title="材质节点引脚（常用）"></a>材质节点引脚（常用）</h2><ul><li><h3 id="基础颜色"><a href="#基础颜色" class="headerlink" title="基础颜色"></a>基础颜色</h3><p>材质的基本图像，可以是纯色或贴图，是整个材质的主外观</p></li><li><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>一般叫做金属度，针对金属材质，设置金属的质感，反光光泽等</p></li><li><h3 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h3><p>基本用于非金属表面，一般输入一张比标准贴图亮的贴图，用于扩大光照面和暗面的对比，也可以直接输入一个具体的值，改变整体的反光强度，类似对比度</p></li><li><h3 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h3><p>决定材质的粗糙程度，0为完全光滑的镜面反射，1为完全粗糙的漫反射</p></li><li><h3 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h3><p>控制材质发光部位，设置自发光颜色或强度</p></li><li><h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>法线，输入一张法线贴图，用于记录材质不同位置的凹凸感</p></li><li><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>输入一个很小的数，影响折射率，可以实现透明玻璃之类的折射，<strong>但效果不怎么样</strong></p></li></ul><h2 id="材质快捷键节点"><a href="#材质快捷键节点" class="headerlink" title="材质快捷键节点"></a>材质快捷键节点</h2><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/1.png" alt="1"></p><p>快捷键：1+Left</p><p>具体作用：创建一个常数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/3.png" alt="3"></p><p>快捷键：3+Left</p><p>具体作用：创建一个常量颜色值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/2.png" alt="2"></p><p>快捷键：s+Left</p><p>具体作用：创建一个变量数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/6.png" alt="6"></p><p>快捷键：V+Left</p><p>具体作用：创建一个颜色变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/5.png" alt="5"></p><p>快捷键：U+Left</p><p>具体作用：创建一个UV缩放节点，用于缩放贴图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/4.png" alt="4"></p><p>快捷键：A+Left</p><p>具体作用：将两种颜色或贴图叠加在一起</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/7.png" alt="7"></p><p>快捷键：M+Left</p><p>具体作用：将两种颜色或贴图混合在一起，一般用选定颜色乘白色贴图进行染色</p><h2 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h2><p>由材质生成的材质实例将材质蓝图中的变量节点显示于右面接口，通过改变接口值来更加直观的实时改变材质的颜色等各种属性，能够实现一个材质创造一堆材质实例的操作</p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>同c的结构体变量类型相同，可以设置一个结构体变量中包含多个普通类型变量，并设置默认值，不能使用自身类型的变量嵌套</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/9.png"></p><p>在蓝图中使用时，通过make节点创建结构体并连接set对应的结构体变量，可初始化的设定其各个变量的值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/11.png" alt="11"></p><p>使用break节点拆分结构体，可以得到其中指定的单个变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/10.png" alt="10"></p><h2 id="蓝图函数库"><a href="#蓝图函数库" class="headerlink" title="蓝图函数库"></a>蓝图函数库</h2><p>类似于头文件，但并不只是函数声明，而是完整的函数编辑，对于同一个文件，可以在左侧边栏里添加多个函数，而且所定义的所有函数均为全局函数</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/12.png" alt="12"></p><p>和c与c++的函数不同，虚幻引擎的函数可以有多个输入，多个输出</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/13.png" alt="13"></p><p>反应在引用该函数的蓝图上就是对应变量的接口</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/14.png" alt="14"></p><h2 id="蓝图宏库"><a href="#蓝图宏库" class="headerlink" title="蓝图宏库"></a>蓝图宏库</h2><p>类似于函数库，但创建与普通蓝图相似，用于创建自定义节点，通常选择创建actor或是object</p><p>默认的宏库中只有一个新建宏0和没有接口的输入输出节点，可选择输入输出节点后在右下角细节面板添加</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/15.png" alt="15"></p><p>不同于函数的是，设置宏的输入输出时，额外可以设置的还有执行引脚</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/22.png" alt="22"></p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/20.png" alt="20"></p><p>若在蓝图宏库中写入以上内容，则在其他蓝图中引用宏时能够得到下面节点</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/21.png" alt="21"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型会将数据定义成具体的内容，例如bool型中，0定义为了false，1定义为了true，创建面板如下，可通过右侧的“新”添加新的枚举值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/16.png" alt="16"></p><p>在蓝图中设置枚举变量也和其他变量类型的操作相同</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/17.png" alt="17"></p><p>用switch连上枚举类型的话，可以用于判断枚举类型，切换流程</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/18.png" alt="18"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>相当于编辑器里的Beginplay（事件开始运行），事件面板中的内容在编辑器中不会运行，只有测试时才会执行，但构造函数里的内容编辑器中也会执行，并且不断更新，只要改动就会产生实时变化。</p><p>简要来说，在蓝图中写入“设置actor位置”无法在场景中看到actor位置变化，但在选项卡中改动x，y，z数值却会直接改变actor位置，后者就属于构造函数中的内容</p><h2 id="媒体播放器"><a href="#媒体播放器" class="headerlink" title="媒体播放器"></a>媒体播放器</h2><p>媒体播放器仅仅是视频文件的播放载体，放入媒体播放器的文件仅仅是预览，具体文件播放的内容需要在蓝图或场景中设置（详细的使用在前面“材质-用户界面”有讲）</p><p><strong>注：UE4支持的视频文件格式应该是.avi，音频文件是.wav，导入时需要注意</strong></p><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><p>如字面意思，用于体现物体物理状态的材质，主要是设定摩擦力</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/23.png" alt="23"></p><p>物理材质可以在材质面板中赋给某个特定的材质，改变使用这个材质的所有模型的物理材质，也可以在场景中赋予单个模型，后者为物理材质的重载，会针对选定模型覆盖原有的物理材质</p><h2 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="控件蓝图"><a href="#控件蓝图" class="headerlink" title="控件蓝图"></a>控件蓝图</h3><ul><li><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>默认新建的控件蓝图中会生成一个画布面板，可以通过多个面板与面板的排列或是互相之间的嵌套完成一整套hud或是UI的设置</p></li><li><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一般只使用可编辑文本和文本框，可编辑文本允许玩家/用户编辑，没有背景，而文本框是开发者设定的文字，显示上有背景；</p><p>其中没有备注的均为单行，不能换行，而标注了多行，也仅仅是多行文本框支持换行，并不意味着自动换行</p><p><strong>右侧的细节面板中（以文本框为例）</strong></p><p>【锚点栏】</p><p>1.锚点主要针对屏幕比例不同时，设定UI位置的参考系</p><p>2.大小到内容是使整个控件大小和内容（比如文字长度）相同</p><p>3.Zorder是上下层数，重叠时最上层数值最大</p><p>【内容栏】文本为固定出现的文本，而提示文本则是仅文本框为空才出现的内容</p><p>【外观栏】</p><p>1.支持更换文本框的背景图片，悬停为鼠标悬停，聚焦指鼠标点击</p><p>2.填充指缩进部分，数值越大，缩进越多</p><p>3.字体轮廓设置时可以选择对投影应用轮廓，让阴影部分也具有描边</p><p>4.删除线可导入图片作为删除线</p><p>5.阴影偏移能够设定阴影与文字的位置差，相当于调整投影的光的角度</p><p>【行为栏】</p><p>1.不勾选“已启用”则显示控件，但不能交互（未开放或不能按的按钮）</p><p>2.可视性：针对可见和占据空间及子项能否交互分类，详情鼠标悬停在选项上</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>导入字体格式一般为otf，ttf也可行，对同种字体同时导入多个文件时，需要否定引擎导入时的新建（否则会每个文件导入一个字体资产），另外自行新建字体资产，分配字体族系</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/24.png" alt="24"></p>]]></content>
    
    
    <summary type="html">材质与蓝图函数库、蓝图宏库、媒体播放器及用户界面说明</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-1</title>
    <link href="https://zwiewings.github.io/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/"/>
    <id>https://zwiewings.github.io/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/</id>
    <published>2021-04-02T11:43:30.000Z</published>
    <updated>2021-05-12T12:18:50.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键节点："><a href="#快捷键节点：" class="headerlink" title="快捷键节点："></a>快捷键节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/1.png" alt="1"></p><p>节点名：延迟</p><p>呼出方式：（快捷键）D+left</p><p>具体作用：实现程序暂停，延迟一段时间继续执行后续节点</p><p>接口：Duration——延迟时长，单位为秒</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/2.png" alt="2"></p><p>节点名：分支</p><p>呼出方式：（快捷键）B+left</p><p>具体作用：实现程序因布尔值变化而条件分歧</p><p>接口：Condition——决定选择支的布尔值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/3.png" alt="3"></p><p>节点名：序列</p><p>呼出方式：（快捷键）S+left</p><p>具体作用：使多个分支同时进行</p><p>接口：Then——同时进行的分支接口</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/4.png" alt="4"></p><p>节点名：For each loop</p><p>呼出方式：（快捷键）F+left</p><p>具体作用：根据数组元素的个数执行循环</p><p>接口：array——需要遍历的数组</p><p>Loop body——循环体</p><p>Array Element——当前数组元素的值</p><p>Array Index——当前数组元素的下标</p><p>Completed——循环出口</p><h1 id="普通节点："><a href="#普通节点：" class="headerlink" title="普通节点："></a>普通节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/5.png" alt="5"></p><p>节点名：获取类的所有actor</p><p>呼出方式：右键查询（使用节点名或get all actor）</p><p>具体作用：获取场景中所有某类的实例</p><p>接口：Actor Class——需要获取的类</p><p>Out Actors——选中类的所有actor的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/6.png" alt="6"></p><p>节点名：自定义事件（事件名称）</p><p>呼出方式：右键查询（使用节点名或custom event）</p><p>具体作用：定义一个自定义事件</p><p>接口：无</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/11.png" alt="11"></p><p>节点名：（事件名称）</p><p>呼出方式：右键查询（使用节点名查找引用）</p><p>具体作用：引用一个在某蓝图中定义好的自定义事件</p><p>接口：无</p><h1 id="时间轴与变换节点："><a href="#时间轴与变换节点：" class="headerlink" title="时间轴与变换节点："></a>时间轴与变换节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/10.png" alt="10"></p><p>节点名：时间轴</p><p>呼出方式：右键查询（使用节点名或timeline）</p><p>具体作用：创建时间轴（用于播放动画等）</p><p>接口：play——正放</p><p>play from start——从头正放</p><p>stop——暂停</p><p>Reverse——倒放</p><p>Reverse from End——从最后倒放</p><p>Set New Time——跳转到特定时间轴</p><p>New Time——设定跳转到的特定时间轴（需要Set New Time启用）</p><p>Update——在时间轴移动时不断执行</p><p>Finished——时间轴结束后执行（无论正放倒放）</p><p>Direction——为时间轴进行方向，可在update或finished后接入switch判断正放倒放</p><p>*创建时间轴和圆滑曲线化：</p><p>通常使用浮点型轨道（f+），键入轨道名称后会出现相应接口，返回时间轴窗口创建关键帧，在两个不同关键帧间会形成对应时间和值的变化直线（折线），最后修改时间轴总长度等于有效变化直线的时间，若同时将两个或以上的关键帧插值改为“用户”型，可通过调整其切线使整个变化折线变为曲线，更加圆滑的完成值的变化</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/12.png" alt="12"></p><p>节点名：拆分变换</p><p>呼出方式：右键查找（使用节点名或break）</p><p>具体作用：将一个变换过程拆分成L、R、S三者</p><p>接口：In Transform——需要拆分的变换</p><p>Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/13.png" alt="13"></p><p>节点名：创建变换</p><p>呼出方式：右键查找（使用节点名或make）</p><p>具体作用：合并L、R、S三者为一个变换过程</p><p>接口：Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p>Return value——变换的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/15.png" alt="15"></p><p>节点名：插值</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个值随时间变化中特定比例处的值</p><p>接口：A——变化开始时值的初始量</p><p>B——变化结束时值的终点量</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/16.png" alt="16"></p><p>节点名：插值（向量）</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个向量随时间变化中特定比例处的值</p><p>接口：A——变化开始时向量的初始值</p><p>B——变化结束时向量的终点值</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/14.png" alt="14"></p><p>节点名：已限制映射范围</p><p>呼出方式：右键查找（使用节点名或Clamp）</p><p>具体作用：将基准值实现In A~In B的变化，并且按In和Out的A、B比例缩放</p><p>接口：Value——输入的基准值</p><p>In Range A——输入的初始比例</p><p>In Range B——输入的终点比例</p><p>Out Range A——输出的初始比例</p><p>Out Range B——输出的终点比例</p><p>Return Value——返回变化且缩放后的值</p><p>注：上文所提到的普通插值可视作In A=0.0，In B=1.0的该节点</p><h1 id="运算节点："><a href="#运算节点：" class="headerlink" title="运算节点："></a>运算节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/17.png" alt="17"></p><p>节点名：限制（浮点）</p><p>呼出方式：右键查找（使用节点名或clamp）</p><p>具体作用：将数据限制在范围内，范围外的数小于min的输出min，大于max输出max</p><p>接口：Value——输入值</p><p>Min——范围的最小值</p><p>Max——范围的最大值</p><p>Return Value——数据限制后的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/18.png" alt="18"></p><p>节点名：截断</p><p>呼出方式：右键查找（使用节点名）/将浮点数据直接接入整数接口</p><p>具体作用：将数据向0舍入，截断小数部分</p><p>注：1.6舍入为1，但-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/19.png" alt="19"></p><p>节点名：底部</p><p>呼出方式：右键查找（使用节点名或floor）</p><p>具体作用：将数据向负无穷舍入，下舍到前一个整数</p><p>注：1.6舍入为1，但-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/20.png" alt="20"></p><p>节点名：顶部</p><p>呼出方式：右键查找（使用节点名）</p><p>具体作用：将数据向正无穷/向上舍入到下一个整数</p><p>注：1.6舍入为2，而-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/21.png" alt="21"></p><p>节点名：舍入</p><p>呼出方式：右键查找（使用节点名或round）</p><p>具体作用：将数据舍入到最近的整数</p><p>注：1.6舍入为2，而-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/22.png" alt="22"></p><p>节点名：（dot）</p><p>呼出方式：右键查找（点乘积）</p><p>具体作用：计算向量点乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/23.png" alt="23"></p><p>节点名：（cross）</p><p>呼出方式：右键查找（叉乘积）</p><p>具体作用：计算向量叉乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/24.png" alt="24"></p><p>节点名：范围内随机浮点（其他数据类型也可）</p><p>呼出方式：右键查找（使用节点名或random float）</p><p>具体作用：生成随机浮点数</p><p>接口：min——最小值</p><p>max——最大值</p><p>return value——范围内的随机数</p><h1 id="选择节点："><a href="#选择节点：" class="headerlink" title="选择节点："></a>选择节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/7.png" alt="7"></p><p>节点名：切换整型</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：利用整数切换引脚流程</p><p>接口：Selection——作为切换标准的整型</p><p>Default——不满足其他引脚时的默认执行引脚</p><p>注：除切换为整型以外，其他类型的数据也可使用switch查找对应类型的切换</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/9.png" alt="9"></p><p>节点名：开启字符串【翻译可能有误】</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：输入指定字符串选择完全相同的引脚执行</p><p>接口：Selection——输入作为判断依据的字符</p><p>Default——不满足其他引脚时的默认执行引脚</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/8.png" alt="8"></p><p>节点名：选择</p><p>呼出方式：右键查询（使用节点名或select）</p><p>具体作用：通过输入的内容得到已设定的返回值</p><p>接口：Option 0，Option 1——设置给出的index值得到的返回值</p><p>Index——可以接入任何类型的通配符</p><p>Return value——返回值的出口</p><h1 id="控制器节点："><a href="#控制器节点：" class="headerlink" title="控制器节点："></a>控制器节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/26.png" alt="26"></p><p>节点名：设置仅输入模式游戏</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在游戏界面中心</p><p>接口：Player Controller——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/25.png" alt="25"></p><p>节点名：设置仅输入模式UI</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在某个UI上</p><p>接口：Player Controller——接玩家控制器</p><p>In Widget to Focus——将光标锁定在该接口指定的UI上</p><p>In Mouse Lock Mode——设置系统光标状态</p><p>注：In Mouse Lock Mode接口分不锁定、捕获时锁定、固定锁定、锁定为全屏；捕获时锁定指运行窗口在最前端时将系统光标锁定在程序窗口内，直到win键强行解锁；固定锁定指一直将系统光标锁定在程序窗口内，直到win键强行解锁；锁定为全屏指仅全屏时锁定光标。</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/31.png" alt="31"></p><p>节点名：获取玩家控制器/角色/pawn</p><p>呼出方式：右键查询（使用节点名或蓝色引脚牵出搜索get player）</p><p>具体作用：得到一个玩家控制器的返回值</p><p>接口：Player Index——玩家控制器的序号</p><p>Return Value——返回玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/33.png" alt="33"></p><p>节点名：（set）</p><p>呼出方式：右键查询（show mouse）[需要取消情境关联]</p><p>具体作用：设置鼠标的显示</p><p>接口：Show Mouse Cursor——是否显示鼠标</p><p>目标——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/32.png" alt="32"></p><p>节点名：生成Actor</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：凭空创建一个actor</p><p>接口：Class——生成的actor类型</p><p>Spawn Transform——指定actor初始变换（生成位置、缩放、旋转度）</p><p>Collision Handing Override——判断生成的条件（和碰撞体积有关）</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/27.png" alt="27"></p><p>节点名：销毁Actor</p><p>呼出方式：右键查询（使用节点名或destroy）</p><p>具体作用：销毁目标Actor</p><p>接口：目标——被销毁的对象</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/30.png" alt="30"></p><p>节点名：构建</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：创建一个UI</p><p>接口：Class——UI的类型</p><p>Owning Player——指定UI属于哪一个玩家</p><p>Return Value——生成的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/29.png" alt="29"></p><p>节点名：添加到视口</p><p>呼出方式：右键查询（使用节点名或牵引构建ui的返回值引脚，输入add to）</p><p>具体作用：让创建的UI显示到用户界面</p><p>接口：目标——接已创建的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/28.png" alt="28"></p><p>节点名：从父项中移除</p><p>呼出方式：右键查询（使用节点名或remove from parent）</p><p>具体作用：移除目标控件</p><p>接口：目标——需要移除的控件</p><h1 id="数组节点"><a href="#数组节点" class="headerlink" title="数组节点"></a>数组节点</h1><p>创建数组：在创建好的变量左侧图标上右键，能够创建一个同类型变量的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/34.png" alt="34"></p><p>节点名：获取数组元素（上为复制，下为引用）</p><p>呼出方式：右键查询（使用节点名或数组引线查询get）</p><p>具体作用：获取数组中指定下标的元素</p><p>接口：（数组接口）——该元素所在数组</p><p>（整数型接口）——需要获取的数组元素下标</p><p>（右值）——返回值（复制返回值，引用返回地址）</p><p>注：该节点分为复制和引用两种方式，同c/c++中函数的传值和引用传址，复制会生成副本，引起的变化不改变数组本身，而引用则可以改变数组内元素的值，但操作不当易使数据受损</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/35.png" alt="35"></p><p>节点名：创建数组</p><p>呼出方式：右键查询（使用节点名或从set左值牵引查询make）</p><p>具体作用：创建一个数组</p><p>接口：左侧——设置序号下的数组值</p><p>右侧——得到数组变量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/36.png" alt="36"></p><p>节点名：（set）</p><p>呼出方式：有引出变量的情况下，输入set查询</p><p>具体作用：设置数组</p><p>接口：左侧——被设置的对象变量数组</p><p>右侧——接已经创建的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/37.png" alt="37"></p><p>节点名：设置阵列元素</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询set）</p><p>具体作用：设置数组单个元素的值</p><p>接口：Target Array——接该元素所在数组</p><p>Index——指定的数组元素的序号</p><p>Item——为该数组元素所赋的值</p><p>Size to Fit——当index大于数组大小时，数组将扩展</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/38.png" alt="38"></p><p>节点名：查找项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：查找与给定值相等的数组下标</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/39.png" alt="39"></p><p>节点名：为有效索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：判断能否查找到指定元素</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——能否找到的bool值返回</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/40.png" alt="40"></p><p>节点名：添加</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在数组最后添加一个元素</p><p>接口：左侧——数组与需要添加的值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/41.png" alt="41"></p><p>节点名：插入</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在指定下标处插入一个元素，其他元素自动后移</p><p>接口：左侧——数组与需要查找的给定值，以及需要插入的位置序号</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/42.png" alt="42"></p><p>节点名：长度</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：返回数组长度</p><p>接口：左侧——数组</p><p>右侧——数组长度返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/43.png" alt="43"></p><p>节点名：清空</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：清空整个数组</p><p>接口：左侧——需要清空的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/44.png" alt="44"></p><p>节点名：移除项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除等于这个值的元素</p><p>接口：左侧——数组与需要移除的给定值</p><p>右侧——返回是否成功移除</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/45.png" alt="45"></p><p>节点名：移除索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除这个下标的元素</p><p>接口：左侧——数组和元素下标</p>]]></content>
    
    
    <summary type="html">普通actor类蓝图常用节点具体作用、呼出方式及各接口说明</summary>
    
    
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-2</title>
    <link href="https://zwiewings.github.io/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/"/>
    <id>https://zwiewings.github.io/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</id>
    <published>2021-03-30T06:14:43.000Z</published>
    <updated>2021-05-12T12:17:10.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-单链表"><a href="#线性表-单链表" class="headerlink" title="线性表-单链表"></a>线性表-单链表</h1><p>【Elemtype为数据类型】</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="链表结点结构体创建"><a href="#链表结点结构体创建" class="headerlink" title="链表结点结构体创建"></a>链表结点结构体创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct LNode        &#x2F;&#x2F;创建结点类型</span><br><span class="line">&#123;</span><br><span class="line">elemtype data;         &#x2F;&#x2F;结点中包含数据域</span><br><span class="line">struct LNode *next;    &#x2F;&#x2F;结点中包含指向下一个结点的指针</span><br><span class="line">&#125;*Linklist                 &#x2F;&#x2F;将该类型定义为一个链表（常使用指针方式价）</span><br></pre></td></tr></table></figure><h3 id="尾插法创建"><a href="#尾插法创建" class="headerlink" title="尾插法创建"></a>尾插法创建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要创建的表L，以及初始表长n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;<span class="comment">//为L新分配一个地址</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//将L的next设为空（前两步为初始化）</span></span><br><span class="line">    Lnode *E=L;<span class="comment">//令新指针指向L指向的头结点</span></span><br><span class="line">    <span class="keyword">int</span> i,a;</span><br><span class="line">Lnode *p;<span class="comment">//定义另一个指向结点的指针p</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;a;<span class="comment">//输入数据a</span></span><br><span class="line">     p=<span class="keyword">new</span> Lnode;<span class="comment">//令p指向新建结点</span></span><br><span class="line">     p-&gt;data=a;<span class="comment">//将新建结点的数据域赋值为a</span></span><br><span class="line">     E-&gt;next=p;<span class="comment">//令E的next指向p指向的结点</span></span><br><span class="line">     p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//p的next指向空</span></span><br><span class="line">     E=p;<span class="comment">//指针E后移，指向p指向的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="头插法创建"><a href="#头插法创建" class="headerlink" title="头插法创建"></a>头插法创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void create(Linklist &amp;L，int n)</span><br><span class="line">&#x2F;&#x2F;传址需要创建的表L，以及初始表长n</span><br><span class="line">&#123;</span><br><span class="line">L&#x3D;new LNode;</span><br><span class="line">L-&gt;next&#x3D;NULL;</span><br><span class="line">    int i,a;</span><br><span class="line">struct LNode *p;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    for(i&#x3D;1;a!&#x3D;-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    p&#x3D;new LNode;</span><br><span class="line">    p-&gt;data&#x3D;a;</span><br><span class="line">    p-&gt;next&#x3D;L-&gt;next;</span><br><span class="line">    L-&gt;next&#x3D;p;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>注：初始化应当在尾插和头插法前使用，或者不使用</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span>       <span class="comment">//传址创建的链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">L=<span class="keyword">new</span> LNode;            <span class="comment">//新生成一个结点，让头指针指向头结点</span></span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;          <span class="comment">//为统一操作，头结点仅作为首元结点的前驱，数据域不放入数据，且指针域指向空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;           <span class="comment">//返回值提示完成初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>单链表的取值需要顺序遍历，耗时较长，故而不适合频繁获取特定位置的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getelem</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i,elemtype &amp;e)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址数据所在的表，并且传值需要取值的元素序号i，将得到的值传给e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">LNode *p=L-&gt;next;               <span class="comment">//令p指向首元结点</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i&amp;&amp;p!=<span class="literal">NULL</span>;j++)       <span class="comment">//j作为计数器，确定遍历到的位置，当p指针指向空或j==i时结束循环</span></span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;                  <span class="comment">//让p指向p的下一个结点，实现p后移</span></span><br><span class="line">&#125;                               <span class="comment">//结束循环时，j==i，p指向的结点为第i-1个结点</span></span><br><span class="line"> <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;       <span class="comment">//如果p指针指向空，则返回取值失败</span></span><br><span class="line">e=p-&gt;next-&gt;data;                <span class="comment">//否则，将p指向结点的下一个结点的数据域赋给e</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                   <span class="comment">//返回取值完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>单链表的查找同顺序表一样，需要遍历整个表，比较每个数据域和待查找值，若相同则返回其序号，若始终不相同则返回查找失败</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Linklist &amp;L,LNode *&amp;p,elemtype a)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址需要查找的表，查找成功时用于指向查找结果的指针p，同时传值需要查找的数据a</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;p-&gt;next!=<span class="literal">NULL</span>;j++)      <span class="comment">//j作为计数器，确定遍历到的位置，当p指针指向为空时结束循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;data==a) <span class="keyword">break</span>;       <span class="comment">//查找到与数据a相同的数据域，提前退出循环</span></span><br><span class="line">p=p-&gt;next;                  <span class="comment">//p指针继续后移，继续遍历整个链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=a)   <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"><span class="comment">//如果p指针已经指向尾结点，且尾结点数据域域不等于a，则查找失败</span></span><br><span class="line"><span class="comment">//p指针直接能够返回需要查找的节点，不需要另外设置返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                   <span class="comment">//返回查找成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时，需要先让新结点连接需要插入位置前驱的后一个结点，再让前驱的next指针指向新结点，否则会直接丢失后面数据的地址</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i，elem e)</span></span></span><br><span class="line"><span class="function"><span class="comment">//传址链表，需要插入的位置i，需要插入的元素值e</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">Lnode *p=L-&gt;next;                <span class="comment">//使p指针指向首元结点</span></span><br><span class="line">Lnode *s=<span class="keyword">new</span> Lnode;              <span class="comment">//新建一个结点，并用s指针指向它</span></span><br><span class="line">s-&gt;data=e;                       <span class="comment">//将新建结点的数据域赋为e</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>;j++)      </span><br><span class="line"><span class="comment">//当j移动到需要插入位置的前驱时或者链表结束时结束循环</span></span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;                   <span class="comment">//让p指向下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">//如果p指向不合法位置则返回插入失败</span></span><br><span class="line">s-&gt;next=p-&gt;next;                 <span class="comment">//否则让s的next指针指向p的下一个结点</span></span><br><span class="line">p-&gt;next=s;                       <span class="comment">//并让p的next指针指向s</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                     <span class="comment">//返回成功插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">Lnode *p=L-&gt;next;                <span class="comment">//使p指向首元结点</span></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i<span class="number">-1</span>&amp;&amp;p!=<span class="literal">NULL</span>)           </span><br><span class="line"><span class="comment">//当j移动到需要删除位置的前驱或链表结束时结束循环</span></span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;                  <span class="comment">//让p指向p的下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;        <span class="comment">//p指向不合法位置时，返回删除失败</span></span><br><span class="line">p-&gt;next=p-&gt;next-&gt;next;          <span class="comment">//让p的next指针等于p下一个结点的next</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                    <span class="comment">//返回删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-3-单链表的创建及遍历-20-分"><a href="#R7-3-单链表的创建及遍历-20-分" class="headerlink" title="R7-3 单链表的创建及遍历 (20 分)"></a>R7-3 单链表的创建及遍历 (20 分)</h3><p>读入n值及n个整数，建立单链表并遍历输出。</p><p>输入格式:<br>读入n及n个整数。</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10 5</span><br></pre></td></tr></table></figure><p>输出样例:<br>在这里给出相应的输出。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(<span class="built_in">list</span>,n);</span><br><span class="line">    putout(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="R7-1-两个有序链表序列的合并-20-分"><a href="#R7-1-两个有序链表序列的合并-20-分" class="headerlink" title="R7-1 两个有序链表序列的合并 (20 分)"></a>R7-1 两个有序链表序列的合并 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 3 5 -1</span><br><span class="line">2 4 6 8 10 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;a!=<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addit</span><span class="params">(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p1</span>=</span>l1-&gt;next,*p2=l2-&gt;next, *p3;</span><br><span class="line">    l3=l1;</span><br><span class="line">    p3=l3;</span><br><span class="line">    <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;data&lt;=p2-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">        p3-&gt;next=p1;</span><br><span class="line">        p3=p1;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p3-&gt;next=p2;</span><br><span class="line">            p3=p2;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p3-&gt;next=p1?p1:p2;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">                <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NULL&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist L1,L2,L3;</span><br><span class="line">create(L1);</span><br><span class="line">create(L2);</span><br><span class="line">init(L3);</span><br><span class="line">    addit(L1,L2,L3);</span><br><span class="line">    putout(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="R7-2-两个有序链表序列的交集-20-分"><a href="#R7-2-两个有序链表序列的交集-20-分" class="headerlink" title="R7-2 两个有序链表序列的交集 (20 分)"></a>R7-2 两个有序链表序列的交集 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 5 -1</span><br><span class="line">2 4 5 8 10 -1</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;*Linklist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">init</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L=<span class="keyword">new</span> Lnode;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        Lnode *E=L;</span><br><span class="line">        <span class="keyword">int</span> i,a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;a!=<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        p=<span class="keyword">new</span> Lnode;</span><br><span class="line">        p-&gt;data=a;</span><br><span class="line">        E-&gt;next=p;</span><br><span class="line">        p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        E=p;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(Linklist &amp;L,<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>;</span></span><br><span class="line">    p=L-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;p-&gt;next!=<span class="literal">NULL</span>;j++)      </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==a) <span class="keyword">break</span>;       </span><br><span class="line">        p=p-&gt;next;                 </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=a)   <span class="keyword">return</span> <span class="literal">false</span>;              </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cutit</span><span class="params">(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p1</span>=</span>l1-&gt;next,*p2=l2-&gt;next,*p3=l3;</span><br><span class="line">    <span class="keyword">while</span>(p1&amp;&amp;p2)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(p1-&gt;data&lt;p2-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">    p1=p1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(p1-&gt;data==p2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">p3-&gt;next=p1;</span><br><span class="line">p3=p3-&gt;next;</span><br><span class="line">p1=p1-&gt;next;</span><br><span class="line">p2=p2-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span>(p1-&gt;data&gt;p2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">p2=p2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p3-&gt;next!=<span class="literal">NULL</span>) p3-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putout</span><span class="params">(Linklist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Lnode</span> *<span class="title">p</span>=</span>L;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;NULL&quot;</span>; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;p-&gt;next-&gt;next!=<span class="literal">NULL</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Linklist L1,L2,L3;</span><br><span class="line">create(L1);</span><br><span class="line">create(L2);</span><br><span class="line">init(L3);</span><br><span class="line">    cutit(L1,L2,L3);</span><br><span class="line">    putout(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于线性表中单链表的头插尾插创建、初始化、取值、查找、插入、删除及代码实例</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-1</title>
    <link href="https://zwiewings.github.io/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
    <id>https://zwiewings.github.io/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</id>
    <published>2021-03-24T11:02:30.000Z</published>
    <updated>2021-05-12T12:16:59.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-顺序表"><a href="#线性表-顺序表" class="headerlink" title="线性表-顺序表"></a>线性表-顺序表</h1><h2 id="创建（初始化）"><a href="#创建（初始化）" class="headerlink" title="创建（初始化）"></a>创建（初始化）</h2><p>以数组的形式创建顺序表</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct      &#x2F;&#x2F;理解为将定义的结构体改称为&#123;&#125;后的名字，如SQlist</span><br><span class="line">&#123;</span><br><span class="line">Elemtype *elem； &#x2F;&#x2F;定义顺序表具有首元素地址</span><br><span class="line">int length;     &#x2F;&#x2F;定义顺序表具有表长这一属性</span><br><span class="line">&#125;SQlist;</span><br></pre></td></tr></table></figure><p>初始化设置顺序表的最大存储空间，以及初始化其表长为0</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool initList(SQlist &amp;sq)     &#x2F;&#x2F;将需要初始化的表传址</span><br><span class="line">&#123;</span><br><span class="line">sq.elem&#x3D;new maxsize;        &#x2F;&#x2F;为顺序表分配maxsize的空间作为最大上限</span><br><span class="line">if(!sq.elem) return false;      &#x2F;&#x2F;如果空间分配失败，直接返回提示错误</span><br><span class="line">sq.length&#x3D;0;                    &#x2F;&#x2F;如果分配空间成功，则继续初始化表长为0</span><br><span class="line">return true;                    &#x2F;&#x2F;返回参数提示顺序表初始化成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>顺序表能够随机存取，故而方便存取指定位置的值，即可以随机存取</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool getelem(SQlist &amp;sq,int i，elemtype &amp;a)  </span><br><span class="line">&#x2F;&#x2F;将需要初始化的表传址，并且传值需要获取的是第i个值，返回的值传给a</span><br><span class="line">&#123;</span><br><span class="line">if(i&lt;1||i&gt;sq.length) return false;    &#x2F;&#x2F;如果i为非法位置，返回提示错误</span><br><span class="line">a&#x3D;sq.elem[i];                 &#x2F;&#x2F;否则返回第i个元素给a</span><br><span class="line">return true;                  &#x2F;&#x2F;返回提示执行正常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序表的查找就是顺序比较表内元素和待查找元素，相同查找成功，始终不同查找失败</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int find(SQlist &amp;sq,elemtype a)</span><br><span class="line">&#x2F;&#x2F;传址需要查找的表，并传值需要查找的数值a,返回查找到的序号为int类型</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i&#x3D;0;i&lt;sq.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(sq.elem[i]&#x3D;&#x3D;a) return i;</span><br><span class="line">&#x2F;&#x2F;如果查找到了，返回该值在表中的序号，此处为数组下标，若返回第几个元素序号，则需要i+1</span><br><span class="line">&#125;</span><br><span class="line">return -1;            &#x2F;&#x2F;查找失败，返回负数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>顺序表为紧邻的线性表，故而插入时需要向后移动较多元素，并且需要从最后一个元素开始向后移动，以免数据被覆盖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool insert(SQlist &amp;sq,elemtype a,int i)</span><br><span class="line">&#x2F;&#x2F;将元素a的值插入表中第i个位置，传址需要做插入的表，以及传值a，i</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">if(i&lt;1||i&gt;sq.length+1) return false;&#x2F;&#x2F;如果i值不合法，则不作插入</span><br><span class="line">if(sq.length&#x3D;&#x3D;maxsize) return false;&#x2F;&#x2F;如果表长已经达到最大，则判断表满，不作插入</span><br><span class="line">for(j&#x3D;sq.length-1;j&gt;&#x3D;i-1;j--)</span><br><span class="line">&#x2F;&#x2F;让j为最后一个元素的角标，循环递减，并且当j等于插入位置i的前驱时，停止循环</span><br><span class="line">&#123;</span><br><span class="line">sq.elem[j+1]&#x3D;sq.elem[j];        &#x2F;&#x2F;给j+1角标的空间赋值当前j角标的值，实现后移</span><br><span class="line">&#125;</span><br><span class="line">sq.elem[i-1]&#x3D;a;                     &#x2F;&#x2F;赋值第i个位置，即角标为i-1的空间为a</span><br><span class="line">sq.length++;                        &#x2F;&#x2F;表长增加</span><br><span class="line">return true;                        &#x2F;&#x2F;返回插入成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>顺序表的删除是将待删除位置后面的全部往前覆盖，向前移动较多元素，并且需要从待删除位置的后一个开始移动，以免覆盖数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool delete(SQlist &amp;sq,int i)</span><br><span class="line">&#x2F;&#x2F;传址需要删除元素的顺序表，并且传值需要删除的元素位置</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">if(i&lt;1||i&gt;sq.length) return false;   &#x2F;&#x2F;如果i值不合法，则不作插入</span><br><span class="line">for(j&#x3D;i;j&lt;&#x3D;sq.length-1;j++)</span><br><span class="line">&#x2F;&#x2F;将i位置之后的所有元素都向前移，并且循环在将最后一个元素移动到表长减一后的位置停止</span><br><span class="line">&#123;</span><br><span class="line">sq.elem[j-1]&#x3D;sq.elem[j];        &#x2F;&#x2F;被删位置后的元素全部前移</span><br><span class="line">&#125;</span><br><span class="line">sq.length--;                        &#x2F;&#x2F;表长减少</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-1-顺序表的建立及遍历-20-分"><a href="#R7-1-顺序表的建立及遍历-20-分" class="headerlink" title="R7-1 顺序表的建立及遍历 (20 分)"></a>R7-1 顺序表的建立及遍历 (20 分)</h3><p>读入n值及n个整数，建立顺序表并遍历输出。</p><p>输入格式:<br>读入n及n个整数</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-3 10 20 78</span><br></pre></td></tr></table></figure><p>输出样例:<br>在这里给出相应的输出。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-3 10 20 78</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(List &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sq.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">output</span><span class="params">(List &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sq.a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;sq.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sq.a[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List sqlist;</span><br><span class="line">    <span class="keyword">int</span> i,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(sqlist);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;sqlist.a[i];</span><br><span class="line">        sqlist.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sqlist.length!=<span class="number">0</span>) </span><br><span class="line">        output(sqlist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="R7-2-jmu-ds-顺序表区间元素删除-20-分"><a href="#R7-2-jmu-ds-顺序表区间元素删除-20-分" class="headerlink" title="R7-2 jmu-ds-顺序表区间元素删除 (20 分)"></a>R7-2 jmu-ds-顺序表区间元素删除 (20 分)</h3><p>若一个线性表L采用顺序存储结构存储，其中所有的元素为整数。设计一个算法，删除元素值在[x,y]之间的所有元素，要求算法的时间复杂度为O(n)，空间复杂度为O(1)。</p><p>输入格式:<br>三行数据，第一行是顺序表的元素个数，第二行是顺序表的元素，第三行是x和y。</p><p>输出格式:<br>删除元素值在[x,y]之间的所有元素后的顺序表。</p><p>输入样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 1 9 10 67 12 8 33 6 2</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure><p>输出样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 67 12 33 2</span><br></pre></td></tr></table></figure><p><strong>解法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">create</span><span class="params">(sqlist &amp;sq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq.a= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">if</span>(!sq.a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    sq.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">del</span><span class="params">(sqlist &amp;sq,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;sq.length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sq.a[j]&gt;=x&amp;&amp;sq.a[j]&lt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=j;i&lt;sq.length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sq.a[i]=sq.a[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            sq.length--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqlist List;</span><br><span class="line">    <span class="keyword">int</span> n,i,x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    create(List);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;List.a[i];</span><br><span class="line">        List.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    del(List,x,y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;List.a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;List.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;List.a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于线性表中顺序表的创建/初始化、取值、查找、插入、删除以及代码实例</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-2：string头文件</title>
    <link href="https://zwiewings.github.io/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/"/>
    <id>https://zwiewings.github.io/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/</id>
    <published>2021-03-22T23:41:02.000Z</published>
    <updated>2021-05-14T02:51:30.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：string"><a href="#头文件：string" class="headerlink" title="头文件：string"></a>头文件：string</h1><h2 id="用于简化操作的常用函数"><a href="#用于简化操作的常用函数" class="headerlink" title="用于简化操作的常用函数"></a>用于简化操作的常用函数</h2><ul><li><p>string变量读取单个字符用s[i]可以读出</p></li><li><p>输入带空格的字符串，用getline(cin,a)；(a为字符串类型变量)</p></li><li><p>str.=“”——清空</p></li><li><p>str.empty()——是否为空</p></li><li><p>str.size()——str长度</p></li><li><p>swap(s1，s2)——交换s1，s2</p></li><li><p>str. insert(x,“aaa”)——在下标x处插入aaa</p></li><li><p>str.substr(x,y)——读出下标为x开始长度为y的字符串</p></li><li><p>str.erase(x,y)——移除下标x长度为y的字符</p></li><li><p>str.find(“字符或字符串”)——找str中第一次出现的下标，找不到就是-1</p></li><li><p>while((i=str.find(“a”,i))!=-1) { i++; cout&lt;&lt;i&lt;&lt;endl; }  ——读出所有a字符出现的下标</p><p>  (基本思路是找到一个就从那个下标+1继续找)</p></li><li><p>str.replace(x，y，“aa”)——用aa替换(x，y)(删掉下标x开始长度为y个，在下标为x处插入aa)</p></li></ul><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>string s——生成一个空字符串s</p><p>string s(str) ——拷贝构造函数 生成str的复制品</p><p>string s(str,stridx)——将字符串str内“始于位置stridx”的部分当作字符串的初值</p><p>string s(str,stridx,strlen) ——将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</p><p>string s(cstr) ——将C字符串作为s的初值</p><p>string s(chars,chars_len) ——将C字符串前chars_len个字符作为字符串s的初值。</p><p> string s(num,c) ——生成一个字符串，包含num个c字符</p><p> string s(beg,end) ——以区间beg;end(不包含end)内的字符作为字符串s的初值</p><p>s.~string() ——销毁所有字符，释放内存</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p> =，assign()——赋以新值</p></li><li><p>swap()——交换两个字符串的内容</p></li><li><p>+=，append()，push_back()——在尾部添加字符</p></li><li><p>insert()——插入字符</p></li><li><p>erase()——删除字符</p></li><li><p>clear()——删除全部字符</p></li><li><p>replace()——替换字符</p></li><li><p>+——串联字符串</p></li><li><p>==，!=，&lt;，&lt;=，&gt;，&gt;=，compare()——比较字符串</p></li><li><p>size(),length()——返回字符数量</p></li><li><p>max_size()——返回字符的可能最大个数</p></li><li><p>empty()——判断字符串是否为空</p></li><li><p>capacity()——返回重新分配之前的字符容量</p></li><li><p>reserve()——保留一定量内存以容纳一定数量的字符</p></li><li><p> [ ], at()——存取单一字符</p></li><li><p>“&gt;&gt;”,getline()——从stream读取某值</p></li><li><p>” &lt;&lt;“ ——将谋值写入stream</p></li><li><p>copy()——将某值赋值为一个C_string</p></li><li><p>c_str()——将内容以C_string返回</p></li><li><p> data()——将内容以字符数组形式返回</p></li><li><p>substr()——返回某个子字符串</p></li><li><p>begin() end()——提供类似STL的迭代器支持</p></li><li><p> rbegin() rend()——逆向迭代器</p></li><li><p>get_allocator()——返回配置器</p></li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。</p>]]></content>
    
    
    <summary type="html">关于c++的String头文件中的函数</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++拓展" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/C-%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-1：algorithm头文件</title>
    <link href="https://zwiewings.github.io/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/"/>
    <id>https://zwiewings.github.io/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-03-19T12:41:02.000Z</published>
    <updated>2021-05-14T02:51:58.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：algorithm"><a href="#头文件：algorithm" class="headerlink" title="头文件：algorithm"></a>头文件：algorithm</h1><p>algorithm意为”算法”,是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><h2 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h2><ol><li><strong>容器</strong> 容器是用来存放各种数据的一个东西，<code>&lt;algorithm&gt;</code>中的算法是针对容器设计的。因此，不论数据是一些<code>int</code>，<code>char</code>还是自定义的<code>class</code>，<code>&lt;algorithm&gt;</code>中的函数都可以正确应对。<code>vector</code>是最常用的容器。</li><li><strong>迭代器</strong> 迭代器是与容器进行配套使用的。它的作用是对容器中的元素进行遍历，比如数组的指针就可以看作一种迭代器。迭代器一般支持解引用（<code>operator*()</code>）、自加（<code>operator++()</code>）、相等（<code>operator==()</code>）等操作。</li><li><strong>谓词</strong> 谓词是用来对<code>&lt;algorithm&gt;</code>中的函数进行定制操作的。谓词可以是lambda表达式或是函数/函数指针，并且<code>&lt;algorithm&gt;</code>中只有一元谓词和二元谓词，即函数只能接收一个或两个参数。对于需要额外参数的谓词可以使用lambda表达式的捕获功能。</li><li><strong><code>pair</code></strong> 部分算法会有两个返回值，<code>pair</code>有两个成员<code>first</code>和<code>second</code>，用来将两个值进行打包返回。</li></ol><h2 id="用到的主要参数说明"><a href="#用到的主要参数说明" class="headerlink" title="用到的主要参数说明"></a>用到的主要参数说明</h2><ul><li><code>beg</code>和<code>end</code>是表示元素范围的迭代器。</li><li><code>beg2</code>是第二个输入序列开始位置的迭代器，<code>end2</code>表示第二个序列末尾位置（如果有的话）。如果没有<code>end2</code>，则假定<code>beg2</code>表示的序列与<code>beg</code>和<code>end</code>表示的序列一样大。<code>beg</code>和<code>beg2</code>不必是相同的类型，但两个序列中的元素都要能调用给定的可调用对像。比如<code>beg</code>是一个<code>std::vector&lt;int&gt;::iterator</code>，而<code>beg2</code>可以是一个<code>std::deque&lt;int&gt;::iterator</code>。</li><li><code>dest</code>是表示目的序列的迭代器，目的序列必须保证能够存储算法生成的所有元素。若无法确定大小，可以调用<code>std::back_inserter()</code>函数获取目的序列的插入迭代器。</li><li><code>unaryPred</code>和<code>binayPred</code>是一元和二元谓词，其实参都是序列中的元素。</li><li><code>comp</code>是一个二元谓词，用于比较两个元素。</li><li><code>unaryOp</code>和<code>binaryOp</code>是可调用对象。</li></ul><p>此外，部分算法要求序列是有序的，默认是使用小于运算符（<code>&lt;</code>）定义的升序。若使用谓词版本，则有序是按<code>comp</code>升序。</p><h2 id="常用函数及用法"><a href="#常用函数及用法" class="headerlink" title="常用函数及用法"></a>常用函数及用法</h2><h3 id="非修改性序列操作（12个）"><a href="#非修改性序列操作（12个）" class="headerlink" title="非修改性序列操作（12个）"></a>非修改性序列操作（12个）</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul><li>对序列中的每个元素执行某操作 for_each()</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>在序列中找出某个值的第一次出现的位置 find()   利用底层元素的等于操作符，对范围内的元素与输入的值进行比较。当匹配时，结束搜索，返回该元素的一个 InputIterator 。</li><li>在序列中找出符合某谓词的第一个元素 find_if()</li><li>在序列中找出一子序列的最后一次出现的位置 find_end()</li><li>在序列中找出第一次出现指定值集中之值的位置 find_first_of()</li><li>在序列中找出相邻的一对值 adjacent_find()</li></ul><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><ul><li>在序列中统计某个值出现的次数 count()</li><li>在序列中统计与某谓词匹配的次数 count_if()</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>找出两个序列相异的第一个元素 mismatch()</li><li>两个序列中的对应元素都相同时为真 equal()</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>在序列中找出一子序列的第一次出现的位置 search()</li><li>在序列中找出一值的连续n次出现的位置 search_n()</li></ul><h3 id="修改性序列操作（27个）"><a href="#修改性序列操作（27个）" class="headerlink" title="修改性序列操作（27个）"></a>修改性序列操作（27个）</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>从序列的第一个元素起进行复制 copy()</li><li>从序列的最后一个元素起进行复制 copy_backward()</li></ul><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul><li>交换两个元素 swap()</li><li>交换指定范围的元素 swap_ranges()</li><li>交换由迭代器所指的两个元素 iter_swap()</li></ul><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><ul><li>将某操作应用于指定范围的每个元素 transform()</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li>用一个给定值替换一些值 replace()</li><li>替换满足谓词的一些元素 replace_if()</li><li>复制序列时用一给定值替换元素 replace_copy()</li><li>复制序列时替换满足谓词的元素 replace_copy_if()</li></ul><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul><li>用一给定值取代所有元素 fill()</li><li>用一给定值取代前n个元素 fill_n()</li></ul><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><ul><li>用一操作的结果取代所有元素 generate()</li><li>用一操作的结果取代前n个元素 generate_n()</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除具有给定值的元素 remove()</li><li>删除满足谓词的元素 remove_if()</li><li>复制序列时删除具有给定值的元素 remove_copy()</li><li>复制序列时删除满足谓词的元素 remove_copy_if()</li></ul><h4 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h4><ul><li>删除相邻的重复元素 unique()</li><li>复制序列时删除相邻的重复元素 unique_copy()</li></ul><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ul><li>反转元素的次序 reverse()</li><li>复制序列时反转元素的次序 reverse_copy()</li></ul><h4 id="环移"><a href="#环移" class="headerlink" title="环移"></a>环移</h4><ul><li>循环移动元素 rotate()</li><li>复制序列时循环移动元素 rotate_copy()</li></ul><h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><ul><li>采用均匀分布来随机移动元素 random_shuffle()</li></ul><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul><li>将满足某谓词的元素都放到前面 partition()</li><li>将满足某谓词的元素都放到前面并维持原顺序 stable_partition()</li></ul><h3 id="序列排序及相关操作（27个）"><a href="#序列排序及相关操作（27个）" class="headerlink" title="序列排序及相关操作（27个）"></a>序列排序及相关操作（27个）</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>以很好的平均效率排序 sort()</li><li>并维持相同元素的原有顺序 stable_sort()</li><li>将序列的前一部分排好序 partial_sort()</li><li>复制的同时将序列的前一部分排好序 partial_sort_copy()</li><li>将第n各元素放到它的正确位置 nth_element()</li></ul><h4 id="二分检索"><a href="#二分检索" class="headerlink" title="二分检索"></a>二分检索</h4><ul><li>找到大于等于某值的第一次出现 lower_bound()</li><li>找到大于某值的第一次出现 upper_bound()</li><li>找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()</li><li>在有序序列中确定给定元素是否存在 binary_search()</li></ul><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><ul><li>归并两个有序序列 merge()</li><li>归并两个接续的有序序列 inplace_merge()</li></ul><h4 id="有序结构上的集合操作"><a href="#有序结构上的集合操作" class="headerlink" title="有序结构上的集合操作"></a>有序结构上的集合操作</h4><ul><li>一序列为另一序列的子序列时为真 includes()</li><li>构造两个集合的有序并集 set_union()</li><li>构造两个集合的有序交集 set_intersection()</li><li>构造两个集合的有序差集 set_difference()</li><li>构造两个集合的有序对称差集（并-交） set_symmetric_difference()</li></ul><h4 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h4><ul><li>向堆中加入元素 push_heap()</li><li>从堆中弹出元素 pop_heap()</li><li>从序列构造堆 make_heap()</li><li>给堆排序 sort_heap()</li></ul><h4 id="最大和最小"><a href="#最大和最小" class="headerlink" title="最大和最小"></a>最大和最小</h4><ul><li>两个值中较小的 min()</li><li>两个值中较大的 max()</li><li>序列中的最小元素 min_element()</li><li>序列中的最大元素 max_element()</li></ul><h4 id="词典比较"><a href="#词典比较" class="headerlink" title="词典比较"></a>词典比较</h4><ul><li>两个序列按字典序的第一个在前 lexicographical_compare()</li></ul><h4 id="排列生成器"><a href="#排列生成器" class="headerlink" title="排列生成器"></a>排列生成器</h4><ul><li>按字典序的下一个排列 next_permutation()</li><li>按字典序的前一个排列 prev_permutation() </li></ul><p>其他详细内容：<a href="https://www.lagou.com/lgeduarticle/9665.html">https://www.lagou.com/lgeduarticle/9665.html</a></p>]]></content>
    
    
    <summary type="html">关于c++的algorithm头文件中的函数</summary>
    
    
    
    <category term="学习" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++拓展" scheme="https://zwiewings.github.io/categories/%E5%AD%A6%E4%B9%A0/C-%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
  </entry>
  
</feed>
