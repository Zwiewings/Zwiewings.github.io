<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-01-28T10:41:55.776Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Wings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1.25-1.31周报汇总</title>
    <link href="http://example.com/2021/01/26/1.25-1.31%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2021/01/26/1.25-1.31%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/</id>
    <published>2021-01-26T01:38:45.000Z</published>
    <updated>2021-01-28T10:41:55.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h1><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><h1 id="Linux-应用领域"><a href="#Linux-应用领域" class="headerlink" title="Linux 应用领域"></a>Linux 应用领域</h1><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合。</p><h1 id="Linux-和-Windows的区别"><a href="#Linux-和-Windows的区别" class="headerlink" title="Linux 和 Windows的区别"></a>Linux 和 Windows的区别</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下</p><table><thead><tr><th align="left"></th><th align="left">Windows</th><th align="left">Linux</th></tr></thead><tbody><tr><td align="left">界面</td><td align="left">界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td align="left">图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td align="left">驱动程序</td><td align="left">驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td align="left">由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td align="left">使用</td><td align="left">使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td align="left">图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td align="left">学习</td><td align="left">系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td align="left">系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td align="left">软件</td><td align="left">每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td align="left">大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="Linux-系统启动过程"><a href="#Linux-系统启动过程" class="headerlink" title="Linux 系统启动过程"></a>Linux 系统启动过程</h1><p>linux启动时我们会看到许多启动信息。</p><p>Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</p><ul><li>内核的引导</li><li>运行 init</li><li>系统初始化</li><li>建立终端 </li><li>用户登录系统</li></ul><h3 id="init程序的类型："><a href="#init程序的类型：" class="headerlink" title="init程序的类型："></a>init程序的类型：</h3><ul><li>SysV: init, CentOS 5之前, 配置文件： /etc/inittab</li><li>Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf</li><li>Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system</li></ul><h2 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a>内核引导</h2><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p><p>操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</p><h2 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a>运行init</h2><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p><p>init 程序首先是需要读取配置文件 /etc/inittab。</p><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>init进程的一大任务，就是去运行这些开机启动的程序。</p><p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p><p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><p>Linux系统有7个运行级别(runlevel)：</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登陆后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><h2 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h2><p>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p><p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p><pre><code>l5:5:wait:/etc/rc.d/rc 5</code></pre><p>这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。</p><p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p><p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p><p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p><h2 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h2><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p><p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p><pre><code>1:2345:respawn:/sbin/mingetty tty12:2345:respawn:/sbin/mingetty tty23:2345:respawn:/sbin/mingetty tty34:2345:respawn:/sbin/mingetty tty45:2345:respawn:/sbin/mingetty tty56:2345:respawn:/sbin/mingetty tty6</code></pre><p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p><p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p><h1 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h1><p>一般来说，用户的登录方式有三种：</p><ul><li>（1）命令行登录</li><li>（2）ssh登录</li><li>（3）图形界面登录</li></ul><p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p><p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 /etc/nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p><p>这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p><p>/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h2 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式"></a>图形模式与文字模式的切换方式</h2><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p><p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space +（ F1-F6）. </p><p>如果你在图形界面下请按Alt + Shift + Ctrl + （F1-F6） 切换至命令窗口。</p><h1 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机"></a>Linux 关机</h1><p>在linux领域内<strong>大多用在服务器上，很少遇到关机的操作</strong>。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p><pre><code>sync 将数据由内存同步到硬盘中。shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。shutdown –h now 立马关机shutdown –h 20:25 系统会在今天20:25关机shutdown –h +10 十分钟后关机shutdown –r now 系统立马重启shutdown –r +10 系统十分钟后重启reboot 就是重启，等同于 shutdown –r nowhalt 关闭系统，等同于shutdown –h now 和 poweroff</code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><p><strong>[Tab] 有『命令补全』与『文件补齐』的功能</strong></p><pre><code>[Tab]      ## 接在一串指令的第一个字的后面，则为『命令补全』[Tab]      ## 接在一串指令的第二个字以后时，则为『文件补齐』</code></pre><p>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</p><p><strong>[Ctrl]+ C 如果在Linux 底下输入了错误的指令或参数，想让当前的程序『停掉』的话，可以输入：</strong></p><pre><code>[Ctrl] + c </code></pre><p><strong>[Ctrl]-d 『键盘输入结束(End Of File, EOF 或 End Of Input)』的意思</strong></p><p>另外，他也可以用来取代 exit 的输入。</p><p>例如你想要直接离开文字接口，可以直接按下：</p><pre><code>[Ctrl] + d   ## 相当于输入 exit</code></pre><p><strong>[shift]+{[PageUP]|[Page Down]}</strong></p><pre><code>[Shift]+[Page Up]    ## 往前翻页 [Shift]+[Page Down] ## 往后翻页</code></pre><p>shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。shutdown 会给系统计划一个时间关机。它可以被用于停止、关机、重启机器。</p><pre><code># shutdown -p now  ### 关闭机器# shutdown -H now  ### 停止机器      # shutdown -r 09:35 ### 在 09:35am 重启机器</code></pre><p>要取消即将进行的关机，只要输入下面的命令：</p><pre><code># shutdown -c</code></pre><p>halt 命令通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。注意在有些情况会它会完全关闭系统。</p><pre><code># halt             ### 停止机器# halt -p          ### 关闭机器、关闭电源# halt --reboot    ### 重启机器</code></pre><p>poweroff 会发送一个 ACPI 信号来通知系统关机。</p><pre><code># poweroff           ### 关闭机器、关闭电源# poweroff --halt    ### 停止机器# poweroff --reboot  ### 重启机器</code></pre><p>reboot 命令 reboot 通知系统重启。</p><pre><code># reboot           ### 重启机器# reboot --halt    ### 停止机器# reboot -p        ### 关闭机器</code></pre><h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><p>登录系统后，在当前命令窗口下输入命令：</p><pre><code> ls / </code></pre><p>可显示当前层的目录。</p><p><img src="/2021/01/26/1.25-1.31%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/pic-1.png" alt="树状目录结构图"></p><p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p><p>文件系统的最顶层是由根目录开始的，系统使用 <strong>/</strong> 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。</p><p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <strong>.</strong> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 <strong>..</strong> 来表示。</p><ul><li> . ：代表当前的目录，也可以使用 ./ 来表示；</li><li> .. ：代表上一层目录，也可以 ../ 来代表。</li></ul><p>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p><h2 id="1-系统启动必须："><a href="#1-系统启动必须：" class="headerlink" title="1.系统启动必须："></a><strong>1.系统启动必须：</strong></h2><p><strong>/boot：</strong>存放的启动Linux 时使用的内核文件，包括连接文件以及镜像文件。</p><p><strong>/etc：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>更改目录下的文件可能会导致系统不能启动。</p><p><strong>/lib</strong>：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p><p><strong>/sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p><h2 id="2-指令集合："><a href="#2-指令集合：" class="headerlink" title="2.指令集合："></a><strong>2.指令集合：</strong></h2><p><strong>/bin：</strong>存放着最常用的程序和指令</p><p><strong>/sbin：</strong>只有系统管理员能使用的程序和指令。</p><h2 id="3-外部文件管理："><a href="#3-外部文件管理：" class="headerlink" title="3.外部文件管理："></a><strong>3.外部文件管理：</strong></h2><p><strong>/dev ：</strong>Device(设备)的缩写, 存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p><p><strong>/media</strong>：类windows的<strong>其他设备，</strong>例如U盘、光驱等等，识别后linux会把设备放到这个目录下。</p><p><strong>/mnt</strong>：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</p><h2 id="4-临时文件："><a href="#4-临时文件：" class="headerlink" title="4.临时文件："></a><strong>4.临时文件：</strong></h2><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p><p><strong>/lost+found</strong>：一般情况下为空的，系统非法关机后，这里就存放一些文件。</p><p><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</p><h2 id="5-账户："><a href="#5-账户：" class="headerlink" title="5.账户："></a><strong>5.账户：</strong></h2><p><strong>/root</strong>：系统管理员的用户主目录。</p><p><strong>/home</strong>：用户的主目录，以用户的账号命名的。</p><p><strong>/usr</strong>：用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</p><p><strong>/usr/bin：</strong>系统用户使用的应用程序与指令。</p><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p><h2 id="6-运行过程中要用："><a href="#6-运行过程中要用：" class="headerlink" title="6.运行过程中要用："></a><strong>6.运行过程中要用：</strong></h2><p><strong>/var</strong>：存放经常修改的数据，比如程序运行的日志文件（/var/log 目录下）。</p><p><strong>/proc</strong>：管理<strong>内存空间！</strong>虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。</p><h2 id="7-扩展用的："><a href="#7-扩展用的：" class="headerlink" title="7.扩展用的："></a><strong>7.扩展用的：</strong></h2><p><strong>/opt</strong>：默认是空的，我们安装额外软件可以放在这个里面。</p><p><strong>/srv</strong>：存放服务启动后需要提取的数据<strong>（不用服务器就是空）</strong></p><h2 id="8-其他："><a href="#8-其他：" class="headerlink" title="8.其他："></a>8.其他：</h2><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre><p><strong>/selinux：</strong><br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p><h4 id="在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"><a href="#在-Linux-系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。" class="headerlink" title="在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。"></a>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</h4><p><strong>/etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p><strong>/bin, /sbin, /usr/bin, /usr/sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p><p><strong>/var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p><h1 id="Linux-远程登录"><a href="#Linux-远程登录" class="headerlink" title="Linux 远程登录"></a>Linux 远程登录</h1><p>Linux 一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的 Linux 服务器。</p><p>这时我们就需要远程登录到Linux服务器来管理维护系统。</p><p>Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22。</p><p>Window 系统上 Linux 远程登录客户端有 SecureCRT, Putty, SSH Secure Shell 等</p><h2 id="使用密钥认证机制远程登录linux"><a href="#使用密钥认证机制远程登录linux" class="headerlink" title="使用密钥认证机制远程登录linux"></a>使用密钥认证机制远程登录linux</h2><p>SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定。</p><p>SSH 为建立在应用层和传输层基础上的安全协议。</p><p>该工具可以生成三种格式的key ：SSH-1(RSA) SSH-2(RSA) SSH-2(DSA) ，我们采用默认的格式即 SSH-2(RSA)。Number of bits in a generated key 这个是指生成的key的大小，这个数值越大，生成的key就越复杂，安全性就越高。</p><h3 id="1）创建目录-root-ssh-并设置权限"><a href="#1）创建目录-root-ssh-并设置权限" class="headerlink" title="1）创建目录 /root/.ssh 并设置权限"></a>1）创建目录 /root/.ssh 并设置权限</h3><p>[root@localhost ~]# mkdir /root/.ssh mkdir 命令用来创建目录，以后会详细介绍，暂时只了解即可。</p><p>[root@localhost ~]# chmod 700 /root/.ssh chmod 命令是用来修改文件属性权限的，以后会详细介绍。</p><h3 id="2）创建文件-root-ssh-authorized-keys"><a href="#2）创建文件-root-ssh-authorized-keys" class="headerlink" title="2）创建文件 / root/.ssh/authorized_keys"></a>2）创建文件 / root/.ssh/authorized_keys</h3><p>[root@localhost ~]# vim /root/.ssh/authorized_keys vim 命令是编辑一个文本文件的命令，同样在后续章节详细介绍。</p><h3 id="3）打开刚才生成的public-key-文件"><a href="#3）打开刚才生成的public-key-文件" class="headerlink" title="3）打开刚才生成的public key 文件"></a>3）打开刚才生成的public key 文件</h3><p>建议使用写字板打开，这样看着舒服一些，复制从AAAA开头至 “—- END SSH2 PUBLIC KEY —-“ 该行上的所有内容，粘贴到/root/.ssh/authorized_keys 文件中，要保证所有字符在一行。（可以先把复制的内容拷贝至记事本，然后编辑成一行载粘贴到该文件中）。</p><p>在这里要简单介绍一下，如何粘贴，用vim打开那个文件后，该文件不存在，所以vim会自动创建。按一下字母”i”然后同时按shift + Insert 进行粘贴（或者单击鼠标右键即可），前提是已经复制到剪切板中了。粘贴好后，然后把光标移动到该行最前面输入 <strong>ssh-rsa</strong> </p><h3 id="4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth"><a href="#4）再设置putty选项，点窗口左侧的SSh-–-gt-Auth" class="headerlink" title="4）再设置putty选项，点窗口左侧的SSh –&gt; Auth"></a>4）再设置putty选项，点窗口左侧的SSh –&gt; Auth</h3><p>单击窗口右侧的Browse… 选择刚刚生成的私钥， 再点Open ，此时输入root，就不用输入密码就能登录了。</p><p>如果在前面你设置了Key Passphrase ，那么此时就会提示你输入密码的。为了更加安全建议大家要设置一个Key Passphrase。</p><h2 id="终端利用ssh登录远程服务器"><a href="#终端利用ssh登录远程服务器" class="headerlink" title="终端利用ssh登录远程服务器"></a><strong>终端利用ssh登录远程服务器</strong></h2><p>安装ssh：</p><pre><code>yum install ssh</code></pre><p>启动ssh：</p><pre><code>service sshd start</code></pre><p>登录远程服务器：</p><pre><code>ssh -p 50022 my@127.0.0.1输入密码：my@127.0.0.1:</code></pre><p><strong>-p</strong> 后面是端口</p><p><strong>my</strong> 是服务器用户名</p><p><strong>127.0.0.1</strong> 是服务器 ip</p><p>回车输入密码即可登录</p><h1 id="Linux-文件基本属性"><a href="#Linux-文件基本属性" class="headerlink" title="Linux 文件基本属性"></a>Linux 文件基本属性</h1><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。</p><p>为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：</p><ul><li>chown (change ownerp) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p><pre><code>[root@www /]# ls -ltotal 64dr-xr-xr-x   2 root root 4096 Dec 14  2012 bindr-xr-xr-x   4 root root 4096 Apr 19  2012 boot……</code></pre><p>实例中，<strong>bin</strong> 文件的第一个属性用 <strong>d</strong> 表示。<strong>d</strong> 在 Linux 中代表该文件是一个目录文件。</p><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 <strong>-</strong> 而已。</p><p><img src="/2021/01/26/1.25-1.31%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/pic-2.png" alt="pic-2"></p><p>从左至右用 <strong>0-9</strong> 这些数字来表示。</p><p>第 <strong>0</strong> 位确定文件类型，第 <strong>1-3</strong> 位确定属主（该文件的所有者）拥有该文件的权限。</p><p>第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中，第 <strong>1、4、7</strong> 位表示读权限，如果用 <strong>r</strong> 字符表示，则有读权限，如果用 <strong>-</strong> 字符表示，则没有读权限；</p><p>第 <strong>2、5、8</strong> 位表示写权限，如果用 <strong>w</strong> 字符表示，则有写权限，如果用 <strong>-</strong> 字符表示没有写权限；第 <strong>3、6、9</strong> 位表示可执行权限，如果用 <strong>x</strong> 字符表示，则有执行权限，如果用 <strong>-</strong> 字符表示，则没有执行权限。</p><h1 id="Linux文件属主和属组"><a href="#Linux文件属主和属组" class="headerlink" title="Linux文件属主和属组"></a>Linux文件属主和属组</h1><pre><code>[root@www /]# ls -ltotal 64drwxr-xr-x 2 root  root  4096 Feb 15 14:46 crondrwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql……</code></pre><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。</p><p>对于 root 用户来说，一般情况下，文件的权限对其不起作用。</p><h2 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h2><h3 id="1、chgrp：更改文件属组"><a href="#1、chgrp：更改文件属组" class="headerlink" title="1、chgrp：更改文件属组"></a>1、chgrp：更改文件属组</h3><p>Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。</p><p>与 chown的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>在 UNIX 系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用 chgrp 指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><h4 id="语法1："><a href="#语法1：" class="headerlink" title="语法1："></a>语法1：</h4><pre><code>chgrp [-R] 属组名 文件名</code></pre><h4 id="参数选项："><a href="#参数选项：" class="headerlink" title="参数选项："></a>参数选项：</h4><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h4 id="语法2："><a href="#语法2：" class="headerlink" title="语法2："></a>语法2：</h4><pre><code>chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</code></pre><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p><p>　　-f或–quiet或–silent 　不显示错误信息。</p><p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p><p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p><p>　　-v或–verbose 　显示指令执行过程。</p><p>　　–help 　在线帮助。</p><p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p><p>　　–version 　显示版本信息。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="实例1：改变文件的群组属性："><a href="#实例1：改变文件的群组属性：" class="headerlink" title="实例1：改变文件的群组属性："></a>实例1：改变文件的群组属性：</h5><pre><code>chgrp -v bin log2012.log</code></pre><p>输出：</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chgrp -v bin log2012.log</code></pre><p>“log2012.log” 的所属组已更改为 bin</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log</code></pre><p>说明： 将log2012.log文件由root群组改为bin群组</p><h5 id="实例2：根据指定文件改变文件的群组属性"><a href="#实例2：根据指定文件改变文件的群组属性" class="headerlink" title="实例2：根据指定文件改变文件的群组属性"></a>实例2：根据指定文件改变文件的群组属性</h5><pre><code>chgrp --reference=log2012.log log2013.log</code></pre><p>输出：</p><pre><code>[root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root     61 11-13 06:03 log2013.log[root@localhost test]#  chgrp --reference=log2012.log log2013.log [root@localhost test]# ll---xrw-r-- 1 root bin  302108 11-13 06:03 log2012.log-rw-r--r-- 1 root bin      61 11-13 06:03 log2013.log</code></pre><p>说明： 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p><h3 id="2、chown：更改文件属主，也可以同时更改文件属组"><a href="#2、chown：更改文件属主，也可以同时更改文件属组" class="headerlink" title="2、chown：更改文件属主，也可以同时更改文件属组"></a>2、chown：更改文件属主，也可以同时更改文件属组</h3><p>Linux chown（英文全拼：<strong>change owner</strong>）命令用于设置文件所有者和文件关联组的命令。</p><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。 </p><p>只有超级用户和属于组的文件所有者才能变更文件关联组。非超级用户如需要设置关联组可能需要使用 chgrp 命令。</p><h4 id="语法1：-1"><a href="#语法1：-1" class="headerlink" title="语法1："></a>语法1：</h4><pre><code>chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名</code></pre><h4 id="语法2：-1"><a href="#语法2：-1" class="headerlink" title="语法2："></a>语法2：</h4><pre><code>chown [-cfhvR] [--help] [--version] user[:group] file...</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数 :"></a><strong>参数</strong> :</h4><ul><li>user : 新的文件拥有者的使用者 ID</li><li>group : 新的文件拥有者的使用者组(group)</li><li>-c : 显示更改的部分的信息</li><li>-f : 忽略错误信息</li><li>-h :修复符号链接</li><li>-v : 显示详细的处理信息</li><li>-R : 处理指定目录以及其子目录下的所有文件</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><p>把 /var/run/httpd.pid 的所有者设置 root：</p><pre><code>chown root /var/run/httpd.pid</code></pre><p>将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</p><pre><code>chown runoob:runoobgroup file1.txt</code></pre><p>将当前前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</p><pre><code>chown -R runoob:runoobgroup *</code></pre><p>把 /home/runoob 的关联组设置为 512 （关联组ID），不改变所有者：</p><pre><code>chown :512 /home/runoob</code></pre><p>进入 /root 目录（~）将install.log的拥有者改为bin这个账号：</p><pre><code>[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log</code></pre><p>将install.log的拥有者与群组改回为root：</p><pre><code>[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log</code></pre><h3 id="3、chmod：更改文件9个属性"><a href="#3、chmod：更改文件9个属性" class="headerlink" title="3、chmod：更改文件9个属性"></a>3、chmod：更改文件9个属性</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><pre><code>chmod [-cfvR] [--help] [--version] mode file...</code></pre><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>mode : 权限设定字串，格式如下 :</p><pre><code>[ugoa...][[+-=][rwxX]...][,...]</code></pre><h4 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h4><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul><h4 id="其他参数说明："><a href="#其他参数说明：" class="headerlink" title="其他参数说明："></a>其他参数说明：</h4><ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作</li><li>-f : 若该文件权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><h4 id="符号模式"><a href="#符号模式" class="headerlink" title="符号模式"></a>符号模式</h4><p>使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示:</p><table><thead><tr><th align="left">who</th><th align="left">用户类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>u</code></td><td align="left">user</td><td align="left">文件所有者</td></tr><tr><td align="left"><code>g</code></td><td align="left">group</td><td align="left">文件所有者所在组</td></tr><tr><td align="left"><code>o</code></td><td align="left">others</td><td align="left">所有其他用户</td></tr><tr><td align="left"><code>a</code></td><td align="left">all</td><td align="left">所用用户, 相当于 <em>ugo</em></td></tr></tbody></table><h5 id="operator-的符号模式表"><a href="#operator-的符号模式表" class="headerlink" title="operator 的符号模式表:"></a>operator 的符号模式表:</h5><table><thead><tr><th align="left">Operator</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">为指定的用户类型增加权限</td></tr><tr><td align="left"><code>-</code></td><td align="left">去除指定用户类型的权限</td></tr><tr><td align="left"><code>=</code></td><td align="left">设置指定用户权限的设置，即将用户类型的所有权限重新设置</td></tr></tbody></table><h5 id="permission-的符号模式表"><a href="#permission-的符号模式表" class="headerlink" title="permission 的符号模式表:"></a>permission 的符号模式表:</h5><table><thead><tr><th align="left">模式</th><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>r</code></td><td align="left">读</td><td align="left">设置为可读权限</td></tr><tr><td align="left"><code>w</code></td><td align="left">写</td><td align="left">设置为可写权限</td></tr><tr><td align="left"><code>x</code></td><td align="left">执行权限</td><td align="left">设置为可执行权限</td></tr><tr><td align="left"><code>X</code></td><td align="left">特殊执行权限</td><td align="left">只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行</td></tr><tr><td align="left"><code>s</code></td><td align="left">setuid/gid</td><td align="left">当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限</td></tr><tr><td align="left"><code>t</code></td><td align="left">粘贴位</td><td align="left">设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位</td></tr></tbody></table><h4 id="八进制语法"><a href="#八进制语法" class="headerlink" title="八进制语法"></a>八进制语法</h4><p>chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。</p><table><thead><tr><th align="left">#</th><th align="left">权限</th><th align="left">rwx</th><th align="left">二进制</th></tr></thead><tbody><tr><td align="left">7</td><td align="left">读 + 写 + 执行</td><td align="left">rwx</td><td align="left">111</td></tr><tr><td align="left">6</td><td align="left">读 + 写</td><td align="left">rw-</td><td align="left">110</td></tr><tr><td align="left">5</td><td align="left">读 + 执行</td><td align="left">r-x</td><td align="left">101</td></tr><tr><td align="left">4</td><td align="left">只读</td><td align="left">r–</td><td align="left">100</td></tr><tr><td align="left">3</td><td align="left">写 + 执行</td><td align="left">-wx</td><td align="left">011</td></tr><tr><td align="left">2</td><td align="left">只写</td><td align="left">-w-</td><td align="left">010</td></tr><tr><td align="left">1</td><td align="left">只执行</td><td align="left">–x</td><td align="left">001</td></tr><tr><td align="left">0</td><td align="left">无</td><td align="left">—</td><td align="left">000</td></tr></tbody></table><p>例如， 765 将这样解释：</p><ul><li>所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。</li><li>用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。</li><li>其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。</li></ul><h4 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h4><p>将文件 file1.txt 设为所有人皆可读取 :</p><pre><code>chmod ugo+r file1.txt</code></pre><p>将文件 file1.txt 设为所有人皆可读取 :</p><pre><code>chmod a+r file1.txt</code></pre><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><pre><code>chmod ug+w,o-w file1.txt file2.txt</code></pre><p>将 ex1.py 设定为只有该文件拥有者可以执行 :</p><pre><code>chmod u+x ex1.py</code></pre><p>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><pre><code>chmod -R a+r *</code></pre><p>此外chmod也可以用数字来表示权限如 :</p><pre><code>chmod 777 file</code></pre><p>语法为：</p><pre><code>chmod abc file</code></pre><p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p>r=4，w=2，x=1</p><ul><li>若要 rwx 属性则 4+2+1=7；</li><li>若要 rw- 属性则 4+2=6；</li><li>若要 r-x 属性则 4+1=5。</li></ul><pre><code>chmod a=rwx file</code></pre><p>和</p><pre><code>chmod 777 file</code></pre><p>效果相同</p><pre><code>chmod ug=rwx,o=x file</code></pre><p>和</p><pre><code>chmod 771 file</code></pre><p>效果相同</p><p>若用 <strong>chmod 4755 filename</strong> 可使此程序具有 root 的权限。</p><h4 id="更多说明"><a href="#更多说明" class="headerlink" title="更多说明"></a>更多说明</h4><table><thead><tr><th align="left"><code>命令</code></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>chmod a+r *file*</code></td><td align="left">给file的所有用户增加读权限</td></tr><tr><td align="left"><code>chmod a-x *file*</code></td><td align="left">删除file的所有用户的执行权限</td></tr><tr><td align="left"><code>chmod a+rw *file*</code></td><td align="left">给file的所有用户增加读写权限</td></tr><tr><td align="left"><code>chmod +rwx *file*</code></td><td align="left">给file的所有用户增加读写执行权限</td></tr><tr><td align="left"><code>chmod u=rw,go= *file*</code></td><td align="left">对file的所有者设置读写权限，清空该用户组和其他用户对file的所有权限（空格代表无权限）</td></tr><tr><td align="left"><code>chmod -R u+r,go-r *docs*</code></td><td align="left">对目录docs和其子目录层次结构中的所有文件给用户增加读权限，而对用户组和其他用户删除读权限</td></tr><tr><td align="left"><code>chmod 664 *file*</code></td><td align="left">对file的所有者和用户组设置读写权限, 为其其他用户设置读权限</td></tr><tr><td align="left"><code>chmod 0755 *file*</code></td><td align="left">相当于<code>u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)</code>。<code>0</code> 没有特殊模式。</td></tr><tr><td align="left"><code>chmod 4755 *file*</code></td><td align="left"><code>4</code>设置了设置<a href="https://www.runoob.com/wiki/%E7%94%A8%E6%88%B7ID">用户ID</a>位，剩下的相当于 u=rwx (4+2+1),go=rx (4+1 &amp; 4+1)。</td></tr><tr><td align="left"><code>find path/ -type d -exec chmod a-x &#123;&#125; \;</code></td><td align="left">删除可执行权限对path/以及其所有的目录（不包括文件）的所有用户，使用’-type f’匹配文件</td></tr><tr><td align="left"><code>find path/ -type d -exec chmod a+x &#123;&#125; \;</code></td><td align="left">允许所有用户浏览或通过目录path/</td></tr></tbody></table><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux 文件的基本权限就有九个，分别是 <strong>owner/group/others(拥有者/组/其他)</strong> 三种身份各有自己的 <strong>read/write/execute</strong> 权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为： <strong>-rwxrwxrwx</strong> ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： <strong>-rwxrwx—</strong> 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><p>所以等一下我们设定权限的变更时，该文件的权限数字就是 <strong>770</strong>。变更权限的指令 chmod 的语法是这样的：</p><pre><code> chmod [-R] xyz 文件或目录</code></pre><p>选项与参数：</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>举例来说，如果要将 .bashrc 这个文件所有的权限都设定启用，那么命令如下：</p><pre><code>[root@www ~]# ls -al .bashrc-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc[root@www ~]# chmod 777 .bashrc[root@www ~]# ls -al .bashrc-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc</code></pre><p>那如果要将权限变成 <em>-rwxr-xr–</em> 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754。</p><h4 id="符号类型改变文件权限"><a href="#符号类型改变文件权限" class="headerlink" title="符号类型改变文件权限"></a>符号类型改变文件权限</h4><p>还有一个改变权限的方法，从之前的介绍中我们可以发现，基本上就九个权限分别是：</p><ul><li>user：用户</li><li>group：组</li><li>others：其他</li></ul><p>那么我们就可以使用 <strong>u, g, o</strong> 来代表三种身份的权限。</p><p>此外， <strong>a</strong> 则代表 <strong>all</strong>，即全部的身份。读写的权限可以写成 <strong>r, w, x</strong>，也就是可以使用下表的方式来看：</p><table><thead><tr><th>chmod</th><th>u g o a</th><th>+(加入) -(除去) =(设定)</th><th>r w x</th><th>文件或目录</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们需要将文件权限设置为 <strong>-rwxr-xr–</strong> ，可以使用 <strong>chmod u=rwx,g=rx,o=r 文件名</strong> 来设定:</p><pre><code>#  touch test1    // 创建 test1 文件# ls -al test1    // 查看 test1 默认权限-rw-r--r-- 1 root root 0 Nov 15 10:32 test1# chmod u=rwx,g=rx,o=r  test1    // 修改 test1 权限# ls -al test1-rwxr-xr-- 1 root root 0 Nov 15 10:32 test1</code></pre><p>而如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：</p><pre><code>#  chmod  a-x test1# ls -al test1-rw-r--r-- 1 root root 0 Nov 15 10:32 test1</code></pre><h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>/</strong> 写起，例如： /usr/share/doc 这个目录。</p></li><li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>/</strong> 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： <strong>cd ../man</strong> 这就是相对路径的写法。</p></li></ul><hr><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将家目录下的所有文件列出来(含属性与隐藏档)</p><pre><code>[root@www ~]# ls -al ~</code></pre><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code> cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..</code></pre><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@www ~]# pwd [-P]</code></pre><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><pre><code>[root@www ~]# pwd/root   &lt;== 显示出目录啦～</code></pre><p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p><pre><code>[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到/tmp底下尝试创建数个新目录看看：</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#39;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><pre><code>[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><pre><code> rmdir [-p] 目录名称</code></pre><p>选项与参数：</p><ul><li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li></ul><p>删除 runoob 目录</p><pre><code>[root@www tmp]# rmdir runoob/</code></pre><p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p><pre><code>[root@www tmp]# ls -l   &lt;==看看有多少目录存在？drwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#39;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><pre><code>[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#39;? n  &lt;==n不覆盖，y为覆盖</code></pre><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><pre><code> rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><pre><code>[root@www tmp]# rm -i bashrcrm: remove regular file `bashrc&#39;? y</code></pre><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><pre><code>[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><pre><code>[root@www tmp]# mv mvtest mvtest2</code></pre><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><pre><code>cat [-AbEnTv]</code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 /etc/issue 这个文件的内容：</p><pre><code>[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \r on an \m</code></pre><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code>[root@www ~]# tac /etc/issueKernel \r on an \mCentOS release 6.4 (Final)</code></pre><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><pre><code>nl [-bnw] 文件</code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 /etc/issue 的内容</p><pre><code>[root@www ~]# nl /etc/issue     1  CentOS release 6.4 (Final)     2  Kernel \r on an \m</code></pre><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><pre><code>[root@www ~]# more /etc/man_db.config ## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....--More--(28%)  &lt;== </code></pre><p>在 more 这个程序的运行过程中：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p><pre><code>[root@www ~]# less /etc/man.config## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....:   &lt;== 这里可以等待你输入命令！</code></pre><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><pre><code>head [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><pre><code>[root@www ~]# head /etc/man.config</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre><code>[root@www ~]# head -n 20 /etc/man.config</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><pre><code>tail [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><pre><code>[root@www ~]# tail /etc/man.config# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：[root@www ~]# tail -n 20 /etc/man.config</code></pre><h2 id="Linux-链接概念"><a href="#Linux-链接概念" class="headerlink" title="Linux 链接概念"></a>Linux 链接概念</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，<strong>ln</strong> 命令产生硬链接。</p><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a><strong>硬连接</strong></h3><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a><strong>软连接</strong></h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><h3 id="可以得到以下全部结论："><a href="#可以得到以下全部结论：" class="headerlink" title="可以得到以下全部结论："></a>可以得到以下全部结论：</h3><p>1).删除符号连接f3,对f1,f2无影响</p><p>2).删除硬连接f2，对f1,f3也无影响</p><p>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效</p><p> 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除</p><h1 id="常用命令大全："><a href="#常用命令大全：" class="headerlink" title="常用命令大全："></a>常用命令大全：</h1><h2 id="日常使用命令"><a href="#日常使用命令" class="headerlink" title="日常使用命令"></a>日常使用命令</h2><p>开关机命令<br>1、shutdown –h now：立刻进行关机</p><p>2、shutdown –r now：现在重新启动计算机</p><p>3、reboot：现在重新启动计算机</p><p>4、su -：切换用户；passwd：修改用户密码</p><p>5、logout：用户注销</p><h2 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h2><p>1、tab = 补全</p><p>2、ctrl + l -：清屏，类似clear命令</p><p>3、ctrl + r -：查找历史命令（history）；ctrl+c = 终止</p><p>4、ctrl+k = 删除此处至末尾所有内容</p><p>5、ctrl+u = 删除此处至开始所有内容</p><p>6、linux中的帮助命令：man、info、–help【[root@localhost ~]# man ls；[root@localhost ~]# info ls；[root@localhost ~]# ls –help】。退出帮助的话，按快捷键q</p><h2 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h2><p>1、ls</p><p>ls命令是列出目录内容的意思（List Directtory Contents）。运行它就是列出文件夹的内容，可能是文件也可能是文件夹。</p><p>  ls -l命令以详情模式(long listing fashion)列出文件夹的内容。</p><p>  ls -a命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件。</p><p>  注意：在Linux中，文件以“.”开头就是隐藏文件，并且每个文件，文件夹，设备或者命令都是以文件对待。</p><p>  2、lsblk</p><p>  lsblk就是列出块设备。除了RAM外，以标准的树状输出格式，整齐地显示块设备。</p><p>  lsblk -l命令以列表格式显示块设备(而不是树状格式)。</p><p>  注意：lsblk是最有用和最简单的方式来了解新插入的USB设备的名字，特别是当你在终端上处理磁盘/块设备时。</p><p>  3、uname</p><p>  “uname”命令就是Unix Name的简写。显示机器名，操作系统和内核的详细信息。</p><p>  注意：uname显示内核类别，uname -a显示详细信息。</p><p>  4、history</p><p>  “history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史。</p><p>  5、sudo</p><p>  “sudo”(super userdo)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p><p>  注意：sudo允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。</p><p>  并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事。</p><p>  6、chmod</p><p>  “chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p><p>  7、chown</p><p>  “chown”命令就是改变文件拥有者和所在用户组。每个文件都属于一个用户组和一个用户。在你的目录下，使用”ls -l”,你就会看到像这样的东西。</p><p>  8、apt</p><p>  Debian系列以“apt”命令为基础，“apt”代表了Advanced Package Tool。APT是一个为Debian系列系统（Ubuntu，Kubuntu等等）开发的高级包管理器，在Gnu/Linux系统上，它会为包自动地，智能地搜索，安装，升级以及解决依赖。例如：apt-get install mplayer</p><p>  9、cal</p><p>  “cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份。</p><p>  10、date</p><p>  “date”命令使用标准的输出打印当前的日期和时间，也可以深入设置。</p><h3 id="系统常用操作命令"><a href="#系统常用操作命令" class="headerlink" title="系统常用操作命令"></a>系统常用操作命令</h3><h4 id="1、指定运行级别"><a href="#1、指定运行级别" class="headerlink" title="1、指定运行级别"></a>1、指定运行级别</h4><p>命令：init[0123456]</p><p>运行级别：（0：关机；1：单用户；2：多用户状态没有网络服务；3：多用户状态有网络服务；4：系统未使用保留给用户；5：图形界面；6：系统重启）。</p><p> 常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab的id:5:inittab：这一行的数字。</p><p> 在启动引导界面的时候按e进入编辑，在进入grub引界面时，请输入e再选中第二个选项按e，再最后输入1[单用户级别]，然后按b进入单用户模式。</p><p> *：可通过此方法进行linux用户密码的修改。</p><h4 id="2、文件显示命令"><a href="#2、文件显示命令" class="headerlink" title="2、文件显示命令"></a>2、文件显示命令</h4><p>more：显示文件内容，带分页；</p><p>less：显示文件内容带分页；</p><p> grep：在文件中查询内容，grep –n “查找内容” 文件名；</p><p> | [管道命令]：在linux和unix系统中 | 就是管道命令，把上一个命令的结果交给 | 的后面的命令进行处理。</p><p> 例：grep –n “查找内容” 文件名 | more</p><p> cat：把文件串连接后输出到屏幕或加 &gt; fileName 到另一个档案。</p><p> head：格式：head [-n|c num]fileName，说明：显示文件头部内容。没有参数时，显示最前10行。</p><p> tail：格式：tail [-n|c num]fileName，说明：显示文件尾部内容。没有参数时，显示最后10行。</p><p> cut：格式：cut -cnum1-num2 filename，说明：显示每行从开头算起第 num1 到 num2 的字符。</p><h4 id="3、文件搜索命令find"><a href="#3、文件搜索命令find" class="headerlink" title="3、文件搜索命令find"></a>3、文件搜索命令find</h4><p>find：搜索文件及目录</p><p>在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而find命令可以解决上述问题。</p><p>  1、在特定的目录下搜索并显示指定名称的文件和目录。</p><p>  find / -name man：意思是说从根目录开始搜索名称为man的文件或目录。</p><p>  2、搜索一段时间内被存取/变更的文件或目录</p><p>  find / home–amin -10：十分钟内存取的文件或目录</p><p>  find / home–atime -10：十小时内存取的文件或目录</p><p>  find / home–cmin -10：十分钟内更改过的文件或目录</p><p>  find / home–ctime -10：十小时内更改过的文件或目录</p><p>  3、搜索指定大小的文件</p><p>  find / home–size +10k：意思是说查找/home目录下大小为10K的文件。</p><h4 id="4、重定向命令"><a href="#4、重定向命令" class="headerlink" title="4、重定向命令"></a>4、重定向命令</h4><p>重定向命令：管道定向命令“&gt;”为覆盖，“&gt;&gt;”追加写在原文件内容后面。</p><p>ls –l &gt;a.txt 列表的内容写入文件a.txt中（覆盖写）。</p><p>  ls –al&gt;&gt; aa.txt 列表的内容追加到文件aa.txt的末尾。</p><h4 id="5、其他命令"><a href="#5、其他命令" class="headerlink" title="5、其他命令"></a>5、其他命令</h4><p>who：格式：who - [husfV] [user]。说明：显示有哪些用户登录到系统中，显示的信息包含用户ID，使用的终端，上线时间，呆滞时间，CPU使用量，动作等等。相关命令 : who am i：显示当前用户是谁。</p><p>sleep：格式：sleep [–help] [–version] number[smhd]。说明 : sleep 可以用来将当前动作延迟一段时间。</p><p>  kill：格式：kill [ -s signal ] pid … 或 kill -l [ signal ]。说明：kill送出一个特定的信号 (signal) 给进程号为 pid 的进程。根据该信号而做特定的动作，若没有指定，默认是送出终止(TERM)信号。</p><p>  ps：格式：ps [options] [–help]。说明：显示进程的名称、占用资源、状态等。</p><p>  top：说明：显示CPU的使用率、内存大小、内存使用率、进程状态等。</p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd … 返回上一级目录<br>cd …/… 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’ I n s t a l l e d − S i z e ; 10 t {Installed-Size;10}t Installed−Size;10t{Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><p><strong>使用 “+” 设置权限，使用 “-” 用于取消</strong></p><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位</p><p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-” 用于取消<br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性</p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 49: …所有空白行 sed ‘/ *#̲/d; /^/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode …HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux简介&quot;&gt;&lt;a href=&quot;#Linux简介&quot; class=&quot;headerlink&quot; title=&quot;Linux简介&quot;&gt;&lt;/a&gt;Linux简介&lt;/h1&gt;&lt;p&gt;Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习周报" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>1.18-1.24周报汇总</title>
    <link href="http://example.com/2021/01/20/1.18-1.24%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2021/01/20/1.18-1.24%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/</id>
    <published>2021-01-20T08:11:42.000Z</published>
    <updated>2021-01-27T08:03:33.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="·类和对象"><a href="#·类和对象" class="headerlink" title="·类和对象"></a>·类和对象</h2><p><strong>1.c++面向对象的三大特性：封装、继承、多态</strong></p><p><strong>2.c++认为万物皆可对象，对象上有其属性和行为</strong></p><p><strong>3.具有相同性质的对象，我们可以抽象称为类</strong></p><h3 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h3><h4 id="（1）意义："><a href="#（1）意义：" class="headerlink" title="（1）意义："></a>（1）意义：</h4><ul><li><p>将属性和行为作为一个整体，表现生活中的事物</p><p>在设计类的时候，属性和行为写在一起</p><pre><code>class 类名&#123; 访问权限: 属性 / 行为 &#125;;//属性使用变量表示//行为一般用函数表示</code></pre><p>在类的概念下，具体的一个物体（整体），称作对象。【类似结构体】</p></li><li><p>将属性和行为加以权限控制</p><p>访问权限有三种：</p><p>1.public（公共权限）：类内可以访问，类外可以访问</p><p>2.protected（保护权限)：类内可以访问，类外不可以访问，子类可以访问</p><p>3.private（私有权限）：类内可以访问，类外不可以访问，子类不可以访问</p></li></ul><h4 id="（2）struct和class区别（默认访问权限不同）"><a href="#（2）struct和class区别（默认访问权限不同）" class="headerlink" title="（2）struct和class区别（默认访问权限不同）"></a>（2）struct和class区别（默认访问权限不同）</h4><ul><li>struct默认权限为公共，可以定义成员函数</li><li>class默认权限为私有</li></ul><h4 id="（3）成员属性设置为私有"><a href="#（3）成员属性设置为私有" class="headerlink" title="（3）成员属性设置为私有"></a>（3）成员属性设置为私有</h4><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限【通过设置公有权限下函数控制读写权限】</p><p>优点2：对于写权限，我们可以检测数据的有效性</p><h4 id="（4）对象的初始化和清理"><a href="#（4）对象的初始化和清理" class="headerlink" title="（4）对象的初始化和清理"></a>（4）对象的初始化和清理</h4><p>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</p><p>对象的初始化和清理也是两个非常重要的安全问题，一个对象或者变量没有初始状态，对其使用后果是未知。同样的使用完一个对象或变量,没有及时清理，也会造成一定的安全问题。</p><p>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构,编译器会提供。</p><p>编译器提供的构造函数和析构函数是空实现。</p><h5 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数:"></a>1.构造函数:</h5><p>主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p><p>默认情况下，c++一般给一个类添加三个函数：默认构造函数，默认析构函数，默认拷贝构造函数</p><p><strong>语法:</strong></p><pre><code>类名()&#123;函数体&#125;</code></pre><ul><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用，,而且只会调用一次</li></ul><p><strong>构造函数的分类及调用：</strong></p><p>1.两种分类方式：</p><ul><li><p>按参数分：有参构造和无参构造（又称默认构造参数）</p></li><li><p>按类型分：</p><p>普通构造</p><p>拷贝构造（将其他对象的属性作为默认值拷贝过来）</p><pre><code>类名（const 类名 &amp;对象名）&#123;函数体&#125;</code></pre><p>c++中拷贝构造函数调用时机通常有三种情况：</p><ol><li>使用一个已经创建完毕的对象来初始化新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ol></li></ul><p>2.三种调用方式：</p><ul><li><p><strong>括号法</strong>：通过有无括号和参数个数调用对应的构造函数，无括号调用默认构造函数</p></li><li><p><strong>显示法：</strong>通过“=”号调用对应构造函数，左侧是“类名 对象名”，右侧带入具体内容，无左侧内容和“=”号的，为匿名对象，特点是当前行执行结束后，系统会立刻回收掉匿名对象</p><p>*<strong>不要利用拷贝构造函数，初始化匿名对象！</strong>编译器会认为是重定义</p></li><li><p><strong>隐式转换法：</strong>隐藏掉显示法”=“右侧的类名和括号，是显示法的简化写法</p></li></ul><p>3.调用规则</p><ul><li>用户定义有参构造函数，c++ 不提供无参构造，但会提供默认拷贝构造</li><li>用户定义拷贝构造函数，c++不提供其他构造函数</li></ul><p>4.深浅拷贝</p><ul><li><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p>【使用new在堆区开辟新空间（一般变量在栈上），并返回一段空间的首地址，一般用指针接收，需要手动在析构函数中用“delete”释放这一段空间，并且将指针变为空指针（指向NULL），如果用浅拷贝就会直接拷贝地址，从而发生重复释放，这时需要用深拷贝模仿操作开辟一个新空间】</p><p><img src="/2021/01/20/1.18-1.24%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/pic-2.png" alt="pic-2"></p></li><li><p>浅拷贝：简单的赋值拷贝操作</p></li></ul><h5 id="2-析构函数"><a href="#2-析构函数" class="headerlink" title="2.析构函数:"></a>2.析构函数:</h5><p>主要作用在于对象销毁前系统自动调用，执行一些清理工作。</p><p>语法:</p><pre><code>~类名()&#123;函数体&#125;</code></pre><ul><li>没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号~</li><li>析构函数不可以有参数,因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</li></ul><p><strong>3.初始化列表</strong>——初始化属性</p><p>语法：</p><pre><code>构造函数（）:属性1（值1），属性2（值2）……&#123;构造函数的函数体&#125;</code></pre><h4 id="（5）类对象作为类成员"><a href="#（5）类对象作为类成员" class="headerlink" title="（5）类对象作为类成员"></a>（5）类对象作为类成员</h4><p>c++类的成员可以是另一个类的对象，我们称该成员为对象成员</p><p>B类中有对象A作为成员，A为对象成员，构造时，先构造类的对象，再构造自身，析构时先析构自身，再析构类的对象</p><h4 id="（6）静态成员"><a href="#（6）静态成员" class="headerlink" title="（6）静态成员"></a>（6）静态成员</h4><p>在成员变量和成员函数前加上关键字static，称为静态成员，分为：静态成员变量和静态成员函数</p><ul><li><p>静态成员变量</p><p>1.所有对象共享同一份数据</p><p>2.在编译阶段分配内存</p><p>3.类内声明（static 变量类型 静态成员变量名；），类外初始化（变量类型 类名::静态成员变量名 = 初值；）</p></li><li><p>静态成员函数</p><p>1.所有对象共享同一个函数</p><p>2.静态成员函数只能访问静态成员变量</p></li></ul><p>静态成员函数的访问：</p><ol><li>通过对象访问</li><li>通过类名访问</li></ol><p>*静态成员函数同样具有访问权限</p><h4 id="（7）c-对象模型和this指针"><a href="#（7）c-对象模型和this指针" class="headerlink" title="（7）c++对象模型和this指针"></a>（7）c++对象模型和this指针</h4><p>成员变量和成员函数分开存储：在c++中，类内的成员变量和成员函数分开储存，只有非静态成员变量才属于类的对象</p><p>空对象占用内存空间为：1，为了区分每个空对象所占内存的位置</p><p>非空对象占用内存空间决定于其包含成员所占字节数。</p><p>每一个非静态成员函数只会诞生-份函数实例，也就是说多个同类型的对象会共用一块代码那么问题是:这一块代码是如何区 分那个对象调用自己的呢?</p><p>C+ +通过提供特殊的对象指针，this指针， 解决上述问题。this指针指向被调用的成员函数所属的对象</p><p>this指针是隐含每一个非静态成员函数内的一种指针this指针不需要定义，直接使用即可</p><p><strong>this指针的用途:</strong></p><p>●当形参和成员变量同名时，可用this指针来区分</p><p>●在类的非静态成员函数中返回对象本身，可使用return *this</p><p>c++中，空指针也是可以调用成员函数的，但是需要注意有没有用到this指针，如果用到的话，需要加以判断保证代码的健壮性。</p><p><strong>常函数:</strong></p><p>●成员函数后加const后我们称为这个函数为常函数</p><p>●常函数内不可以修改成员属性</p><p>●成员属性声明时加关键字mutable后, 在常函数中依然可以修改</p><p>常对象:</p><p>●声明对象前加const称该对象为常对象</p><p>●常对象只能调用常函数</p><h4 id="（8）友元"><a href="#（8）友元" class="headerlink" title="（8）友元"></a>（8）友元</h4><p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类访问另一个类中私有成员，关键字为friend</p><p>友元的三种实现：</p><p>●全局函数做友元</p><p>●类做友元</p><p>●成员函数做友元.</p><h4 id="（9）运算符重载"><a href="#（9）运算符重载" class="headerlink" title="（9）运算符重载"></a>（9）运算符重载</h4><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p><p>当调用一个重载函数或重载运算符时，编译器通过把所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。</p><p>可以重定义或重载大部分 C++ 内置的运算符。这样就能使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><pre><code>Box operator+(const Box&amp;);</code></pre><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p><pre><code>Box operator+(const Box&amp;, const Box&amp;);</code></pre><p>可重载运算符：</p><table><thead><tr><th>双目算术运算符</th><th>+ (加)，-(减)，*(乘)，/(除)，% (取模)</th></tr></thead><tbody><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td><strong>()</strong>(函数调用)，**-&gt;<strong>(成员访问)，</strong>,<strong>(逗号)，</strong>[]**(下标)</td></tr></tbody></table><p>不可重载运算符：</p><ul><li>**.**：成员访问运算符</li><li><strong>.*</strong>, <strong>-&gt;*</strong>：成员指针访问运算符</li><li>**::**：域运算符</li><li><strong>sizeof</strong>：长度运算符</li><li>**?:**：条件运算符</li><li>**#**： 预处理符号</li></ul><h3 id="（5）继承"><a href="#（5）继承" class="headerlink" title="（5）继承"></a>（5）继承</h3><p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。</p><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为<strong>基类</strong>，新建的类称为<strong>派生类</strong>。</p><p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p><p><img src="/2021/01/20/1.18-1.24%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/pic-3.png" alt="pic-3"></p><h4 id="基类-amp-派生类："><a href="#基类-amp-派生类：" class="headerlink" title="基类 &amp; 派生类："></a><strong>基类 &amp; 派生类：</strong></h4><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><pre><code>class derived-class: access-specifier base-class</code></pre><p>其中，访问修饰符 access-specifier 是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><h4 id="访问控制和继承："><a href="#访问控制和继承：" class="headerlink" title="访问控制和继承："></a><strong>访问控制和继承</strong>：</h4><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p><table><thead><tr><th align="left">访问</th><th align="left">public</th><th align="left">protected</th><th align="left">private</th></tr></thead><tbody><tr><td align="left">同一个类</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">派生类</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left">外部的类</td><td align="left">yes</td><td align="left">no</td><td align="left">no</td></tr></tbody></table><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><h4 id="继承类型："><a href="#继承类型：" class="headerlink" title="继承类型："></a>继承类型：</h4><p>当一个类派生自基类，该基类可以被继承为 <strong>public、protected</strong> 或 <strong>private</strong> 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 <strong>protected</strong> 或 <strong>private</strong> 继承，通常使用 <strong>public</strong> 继承。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li><strong>公有继承（public）：</strong>当一个类派生自<strong>公有</strong>基类时，基类的<strong>公有</strong>成员也是派生类的<strong>公有</strong>成员，基类的<strong>保护</strong>成员也是派生类的<strong>保护</strong>成员，基类的<strong>私有</strong>成员不能直接被派生类访问，但是可以通过调用基类的<strong>公有</strong>和<strong>保护</strong>成员来访问。</li><li><strong>保护继承（protected）：</strong> 当一个类派生自<strong>保护</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>保护</strong>成员。</li><li><strong>私有继承（private）：</strong>当一个类派生自<strong>私有</strong>基类时，基类的<strong>公有</strong>和<strong>保护</strong>成员将成为派生类的<strong>私有</strong>成员。</li></ul><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承:"></a>多继承:</h4><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><pre><code>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…&#123;&lt;派生类类体&gt;&#125;;</code></pre><p>其中，访问修饰符继承方式是 <strong>public、protected</strong> 或 <strong>private</strong> 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p><h3 id="（6）多态"><a href="#（6）多态" class="headerlink" title="（6）多态"></a>（6）多态</h3><p><strong>多态</strong>按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p><p>多态分为两类：</p><p>●静态多态:函数重载和运算符重载属于静态多态，复用函数名</p><p>●动态多态:派生类和虚函数实现运行时多态</p><p>静态多态和动态多态区别:</p><p>●静态多态的函数地址早绑定- 编译阶段确定函数地址</p><p>●动态多态的函数地址晚绑定- 运行阶段确定函数地址</p><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>每个子类都能有一个函数 area() 的独立实现。这就是<strong>多态</strong>的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p><h4 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h4><p><strong>虚函数</strong> 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接</strong>，或<strong>后期绑定</strong>。</p><h4 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h4><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p><h2 id="·c-文件操作"><a href="#·c-文件操作" class="headerlink" title="·c++文件操作"></a>·c++文件操作</h2><p>在C++中，有一个stream这个类，所有的I/O都以这个”流”类为基础的，包括我们要认识的文件I/O，stream这个类有两个重要的运算符：</p><h3 id="1、插入器-lt-lt"><a href="#1、插入器-lt-lt" class="headerlink" title="1、插入器(&lt;&lt;)"></a><strong>1、插入器(&lt;&lt;)</strong></h3><p>　　向流输出数据。比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;”Write Stdout”&lt;&lt;’/n’;就表示把字符串”Write Stdout”和换行字符(‘/n’)输出到标准输出流。</p><h3 id="2、析取器-gt-gt"><a href="#2、析取器-gt-gt" class="headerlink" title="2、析取器(&gt;&gt;)"></a><strong>2、析取器(&gt;&gt;)</strong></h3><p>　　从流中输入数据。比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。</p><p>在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream。下面就把此类的文件操作过程一一道来。</p><h3 id="3、打开文件"><a href="#3、打开文件" class="headerlink" title="3、打开文件"></a><strong>3、打开文件</strong></h3><p>　　在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><p>　　void open(const char* filename,int mode,int access);</p><p>　　参数：</p><p>　　filename：　　要打开的文件名<br>　　mode：　　　　要打开文件的方式<br>　　access：　　　打开文件的属性<br>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p><p>　　ios::app：　　　以追加的方式打开文件<br>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性<br>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文<br>　　ios::in：　　　 文件以输入方式打开<br>　　ios::out：　　　文件以输出方式打开<br>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　<br>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败<br>　　ios::trunc：　　如果文件存在，把文件长度设为0<br>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p><p>　　打开文件的属性取值是：</p><p>　　0：普通文件，打开访问<br>　　1：只读文件<br>　　2：隐含文件<br>　　4：系统文件<br>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p><p>　　例如：以二进制输入方式打开文件c:/config.sys</p><p>　　fstream file1;<br>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p><p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p><p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p><p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p><p>　　fstream file1(“c://config.sys”);</p><p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。</p><p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件<br>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p><p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义。</p><h3 id="4、关闭文件"><a href="#4、关闭文件" class="headerlink" title="4、关闭文件"></a>4、关闭文件</h3><p>　　打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。</p><h3 id="5、读写文件"><a href="#5、读写文件" class="headerlink" title="5、读写文件"></a>5、读写文件</h3><p>　　读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式</p><h4 id="1、文本文件的读写"><a href="#1、文本文件的读写" class="headerlink" title="1、文本文件的读写"></a>1、文本文件的读写</h4><p>　　文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：</p><p>　　file2&lt;&lt;”I Love You”;//向文件写入字符串”I Love You”<br>　　int i;<br>　　file1&gt;&gt;i;//从文件输入一个整数值。</p><p>　　这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些</p><p>　　操纵符 功能 输入/输出<br>　　dec 格式化为十进制数值数据 输入和输出<br>　　endl 输出一个换行符并刷新此流 输出<br>　　ends 输出一个空字符 输出<br>　　hex 格式化为十六进制数值数据 输入和输出<br>　　oct 格式化为八进制数值数据 输入和输出<br>　　setpxecision(int p) 设置浮点数的精度位数 输出</p><p>　　比如要把123当作十六进制输出：file1&lt;</p><h4 id="2、二进制文件的读写"><a href="#2、二进制文件的读写" class="headerlink" title="2、二进制文件的读写"></a>2、二进制文件的读写</h4><h5 id="①put"><a href="#①put" class="headerlink" title="①put()"></a>①put()</h5><p>　　put()函数向流写入一个字符，其原型是ofstream &amp;put(char ch)，使用也比较简单，如file1.put(‘c’);就是向流写一个字符’c’。</p><h5 id="②get"><a href="#②get" class="headerlink" title="②get()"></a>②get()</h5><p>　　get()函数比较灵活，有3种常用的重载形式：</p><p>　　一种就是和put()对应的形式：ifstream &amp;get(char &amp;ch);功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如file2.get(x);表示从文件中读取一个字符，并把读取的字符保存在x中。</p><p>　　另一种重载形式的原型是： int get();这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如x=file2.get();和上例功能是一样的。</p><p>　　还有一种形式的原型是：ifstream &amp;get(char *buf,int num,char delim=’/n’)；这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’/n’。例如：</p><p>　　file2.get(str1,127,’A’);//从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。</p><h5 id="③读写数据块"><a href="#③读写数据块" class="headerlink" title="③读写数据块"></a>③读写数据块</h5><p>　　要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：</p><p>　　read(unsigned char *buf,int num);<br>　　write(const unsigned char *buf,int num);</p><p>　　read()从文件中读取 num 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而 write() 从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 unsigned char *，有时可能需要类型转换。</p><p>　　例：</p><p>　　unsigned char str1[]=”I Love You”;<br>　　int n[5];<br>　　ifstream in(“xxx.xxx”);<br>　　ofstream out(“yyy.yyy”);<br>　　out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中<br>　　in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换<br>　　in.close();out.close();</p><h3 id="6、检测EOF"><a href="#6、检测EOF" class="headerlink" title="6、检测EOF"></a>6、检测EOF</h3><p>　　成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();</p><p>　　例：　　if(in.eof())ShowMessage(“已经到达文件尾！”);</p><h3 id="7、文件定位"><a href="#7、文件定位" class="headerlink" title="7、文件定位"></a>7、文件定位</h3><p>　　和C的文件操作方式不同的是，C++ I/O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是 seekg()和 seekp()，seekg()是设置读位置，seekp是设置写位置。它们最通用的形式如下：</p><p>　　istream &amp;seekg(streamoff offset,seek_dir origin);<br>　　ostream &amp;seekp(streamoff offset,seek_dir origin);</p><p>　　streamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：</p><p>　　ios::beg：　　文件开头<br>　　ios::cur：　　文件当前位置<br>　　ios::end：　　文件结尾<br>　　这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。</p><p>　　例：</p><p>　　file1.seekg(1234,ios::cur);//把文件的读指针从当前位置向后移1234个字节<br>　　file2.seekp(1234,ios::beg);//把文件的写指针从文件开头向后移1234个字节</p><h3 id="8-BCB提供的文件操作函数"><a href="#8-BCB提供的文件操作函数" class="headerlink" title="8.BCB提供的文件操作函数"></a>8.BCB提供的文件操作函数</h3><p>总共分为三类：</p><p>1、文件名函数</p><p>2、文件管理函数</p><p>3、文件I/O函数</p><h4 id="1、文件名函数"><a href="#1、文件名函数" class="headerlink" title="1、文件名函数"></a>1、文件名函数</h4><p>　　文件名函数可以对文件的名称、所在子目录、驱动器和扩展名等进行操作。下表列出这些函数及其功能。</p><p>　　函数 说明<br>　　ExpandFileName() 返回文件的全路径(含驱动器、路径)<br>　　ExtractFileExt() 从文件名中抽取扩展名<br>　　ExtractFileName() 从文件名中抽取不含路径的文件名<br>　　ExtractFilePath() 从文件名中抽取路径名<br>　　ExtractFileDir() 从文件名中抽取目录名<br>　　ExtractFileDrive() 从文件名中抽取驱动器名<br>　　ChangeFileExt() 改变文件的扩展名<br>　　ExpandUNCFileName() 返回含有网络驱动器的文件全路径<br>　　ExtractRelativePath() 从文件名中抽取相对路径信息<br>　　ExtractShortPathName() 把文件名转化为DOS的8·3格式<br>　　MatchesMask() 检查文件是否与指定的文件名格式匹配</p><p>　　下面就把这些函数作一一介绍：</p><h5 id="⑴ExpandFileName"><a href="#⑴ExpandFileName" class="headerlink" title="⑴ExpandFileName()"></a><strong>⑴ExpandFileName()</strong></h5><p>　　功能：返回文件的全路径(含驱动器、路径)</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExpandFileName(Application-&gt;ExeName));//显示你的程序文件名，如C:/MyBCB/Sample1.EXE</p><h5 id="⑵ExtractFileExt"><a href="#⑵ExtractFileExt" class="headerlink" title="⑵ExtractFileExt()"></a><strong>⑵ExtractFileExt()</strong></h5><p>　　功能：从文件名中抽取扩展名</p><p>　　参数：FileName:要处理的文件名（全路径）</p><p>　　例：ShowMessage(ExtractFileExt(Application-&gt;ExeName));//显示”.exe”</p><h5 id="⑶ExtractFileName"><a href="#⑶ExtractFileName" class="headerlink" title="⑶ExtractFileName()"></a><strong>⑶ExtractFileName()</strong></h5><p>　　功能：从文件名中抽取不含路径的文件名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileExt(“c://Winnt//SOL.EXE”));//显示”SOL.EXE”</p><h5 id="⑷ExtractFilePath"><a href="#⑷ExtractFilePath" class="headerlink" title="⑷ExtractFilePath()"></a><strong>⑷ExtractFilePath()</strong></h5><p>　　功能：从文件名中抽取路径名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFilePath(“Winnt//SOL.EXE”));//显示”Winnt/“</p><h5 id="⑸ExtractFileDir"><a href="#⑸ExtractFileDir" class="headerlink" title="⑸ExtractFileDir()"></a><strong>⑸ExtractFileDir()</strong></h5><p>　　功能：从文件名中抽取目录名(和上个函数不同，不包括最后的”/“)</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileDir(“Winnt//SOL.EXE”));//显示”Winnt”,注意和上个函数的区别</p><h5 id="⑹ExtractFileDrive"><a href="#⑹ExtractFileDrive" class="headerlink" title="⑹ExtractFileDrive()"></a><strong>⑹ExtractFileDrive()</strong></h5><p>　　功能：从文件名中抽取驱动器名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractFileDrive(“c://Winnt//SOL.EXE”));//显示”c:”</p><h5 id="⑺ChangeFileExt"><a href="#⑺ChangeFileExt" class="headerlink" title="⑺ChangeFileExt()"></a><strong>⑺ChangeFileExt()</strong></h5><p>　　功能：更改文件名的扩展名，不是对真正的文件进行改名，只是对文件名这个字符串进行处理</p><p>　　参数：FileName:要改名的文件名，Extension：新的扩展名</p><p>　　例：ShowMessage(ChangeFileExt(“c://Winnt//SOL.EXE”,”.OOO”));//显示”c:/winnt/SOL.OOO”</p><h5 id="⑻ExpandUNCFileName"><a href="#⑻ExpandUNCFileName" class="headerlink" title="⑻ExpandUNCFileName()"></a><strong>⑻ExpandUNCFileName()</strong></h5><p>　　功能：返回含有网络驱动器的文件全路径，格式为：//机器名/共享名/文件名</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExpandUNCFileName(“F://Winnt//SOL.EXE”));/<em>如果F:是映射的网络驱动器//NT40/WINNT，则显示”//NT40/WINNT/SOL.EXE”</em>/</p><h5 id="⑼ExtractRelativePath"><a href="#⑼ExtractRelativePath" class="headerlink" title="⑼ExtractRelativePath()"></a><strong>⑼ExtractRelativePath()</strong></h5><p>　　功能：从文件名中抽取相对路径信息，如”../sss/ss.asd”这种形式</p><p>　　参数：BaseName：基准文件名；DestName：目标文件名</p><p>　　例：ShowMessage(ExtractRelativePath(“D://Source//c//1.123”,”D://Source//Asm//dz.asm”));/<em>显示”../asm/dz.asm”</em>/</p><h5 id="10-ExtractShortPathName"><a href="#10-ExtractShortPathName" class="headerlink" title="(10) ExtractShortPathName()"></a><strong>(10) ExtractShortPathName()</strong></h5><p>　　功能：把文件名转换为DOS的8、3格式</p><p>　　参数：FileName:要处理的文件名</p><p>　　例：ShowMessage(ExtractShortPathName(“E://Program Files//Dual Wheel Mouse//4dmain.exe”));/<em>显示”E:/Progra<del>1/dualwh</del>1/4dmain.exe”</em>/</p><h5 id="⑾MatchesMask"><a href="#⑾MatchesMask" class="headerlink" title="⑾MatchesMask()"></a><strong>⑾MatchesMask()</strong></h5><p>　　功能：检查文件是否与指定的文件名格式匹配</p><p>　　参数：FileName:要处理的文件名；Mask:文件名格式，支持通配符</p><p>　　例：ShowMessage(MatchesMask(“Lxf.exe”,”*.?x?));//显示”true”</p><h4 id="2、文件管理函数"><a href="#2、文件管理函数" class="headerlink" title="2、文件管理函数"></a>2、文件管理函数</h4><p>　　这类函数包括设置和读取驱动器、子目录和文件的有关的各种操作，下表列出这类操作常用的函数及其功能。</p><p>　　函数 功能<br>　　CreateDir() 创建新的子目录<br>　　DeleteFile() 删除文件<br>　　DirectoryExists() 判断目录是否存在<br>　　DiskFree() 获取磁盘剩余空间<br>　　DiskSize() 获取磁盘容量<br>　　FileExists() 判断文件是否存在<br>　　FileGetAttr() 获取文件属性<br>　　FileGetDate() 获取文件日期<br>　　GetCurrentDir() 获取当前目录<br>　　RemoveDir() 删除目录<br>　　SetCurrentDir() 设置当前目录</p><p>　　下面就把这些函数作一一介绍：</p><h5 id="⑴CreateDir"><a href="#⑴CreateDir" class="headerlink" title="⑴CreateDir()"></a><strong>⑴CreateDir()</strong></h5><p>　　功能：建立子目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要建立的子目录的名字</p><p>　　例：Create(“ASM”);//在当前目录下建立一个名为ASM的子目录</p><h5 id="⑵DeleteFile"><a href="#⑵DeleteFile" class="headerlink" title="⑵DeleteFile()"></a><strong>⑵DeleteFile()</strong></h5><p>　　功能：删除文件，如果成功返回true，否则返回false</p><p>　　参数：FileName:要删除的文件名</p><p>　　例：if(OpenDialog1-&gt;Execute())DeleteFile(OpenDialog1-&gt;FileName);</p><h5 id="⑶DirectoryExists"><a href="#⑶DirectoryExists" class="headerlink" title="⑶DirectoryExists()"></a><strong>⑶DirectoryExists()</strong></h5><p>　　功能：检测目录是否存在，如果存在返回true，否则返回false</p><p>　　参数：Name:要检测的目录名</p><p>　　例：if(!DirectoryExists(“ASM”))CreateDir(“ASM”);//如果ASM这个目录不存在则创建之</p><h5 id="⑷DiskFree"><a href="#⑷DiskFree" class="headerlink" title="⑷DiskFree()"></a><strong>⑷DiskFree()</strong></h5><p>　　功能：检测磁盘剩余空间，返回值以字节为单位，如果指定的磁盘无效，返回-1</p><p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p><p>　　例：ShowMessage(DiskFree(0));//显示当前盘的剩余空间</p><h5 id="⑸DiskSize"><a href="#⑸DiskSize" class="headerlink" title="⑸DiskSize()"></a><strong>⑸DiskSize()</strong></h5><p>　　功能：检测磁盘容量，返回值以字节为单位，如果指定的磁盘无效，返回-1</p><p>　　参数：Drive：磁盘的代号，0表示当前盘, 1=A,2=B,3=C 以此类推</p><p>　　例：ShowMessage(DiskFree(0));//显示当前盘的容量</p><p>　　<strong>⑹FileExists()</strong> </p><p>　　功能：检测文件是否存在，如果存在返回true，否则返回false</p><p>　　参数：FileName:要检测的文件名</p><p>　　例：if(FileExists(“AAA.ASM”))DeleteFile(“AAA.ASM”);</p><h5 id="⑺FileGetAttr"><a href="#⑺FileGetAttr" class="headerlink" title="⑺FileGetAttr()"></a><strong>⑺FileGetAttr()</strong></h5><p>　　功能：取得文件属性，如果出错返回-1</p><p>　　返回值如下表，如果返回$00000006表示是一个具有隐含和系统属性的文件(4+2)</p><p>　　常量 值 含义<br>　　faReadOnly $00000001 只读文件<br>　　faHidden $00000002 隐含文件<br>　　faSysFile $00000004 系统文件<br>　　faVolumeID $00000008 卷标<br>　　faDirectory $00000010 目录<br>　　faArchive $00000020 归档文件</p><p>　　例：if(FileGetAttr(“LLL.TXT”)&amp;0x2)ShowMessage(“这是一个有隐含属性的文件”);</p><p>　　与此对应的有FileSetAttr() ，请自已查阅帮助系统</p><h5 id="⑻FileGetDate"><a href="#⑻FileGetDate" class="headerlink" title="⑻FileGetDate()"></a><strong>⑻FileGetDate()</strong></h5><p>　　功能：返回文件的建立时间到1970-1-1日0时的秒数</p><p>　　参数：Handle:用FileOpen()打开的文件句柄。</p><p>　　例：</p><p>　　int i=FileOpen(“C://autoexec.bat”,fmOpenRead);<br>　　ShowMessage(FileGetDate(i));<br>　　FileClose(i);</p><p>　　与此对应的有FileSetDate()</p><p>　　<strong>⑼GetCurrentDir()</strong> </p><p>　　功能：取得当前的目录名</p><p>　　例：ShowMessage(GetCurrentDir());</p><h5 id="⑽RemoveDir"><a href="#⑽RemoveDir" class="headerlink" title="⑽RemoveDir()"></a><strong>⑽RemoveDir()</strong></h5><p>　　功能：删除目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要删除的目录名</p><p>　　例：if(DiectoryExists(“ASM”))RemoveDir(“ASM”);</p><h5 id="⑾SetCurrentDir"><a href="#⑾SetCurrentDir" class="headerlink" title="⑾SetCurrentDir()"></a><strong>⑾SetCurrentDir()</strong></h5><p>　　功能：设置当前目录，如果成功返回true，否则返回false</p><p>　　参数：Dir:要切换到的目录名</p><p>　　例：SetCurrentDir(“C://WINDOWS”);</p><h4 id="3、文件I-O函数"><a href="#3、文件I-O函数" class="headerlink" title="3、文件I/O函数"></a>3、文件I/O函数</h4><p>　　这类函数完成对文件的读写相关的操作，这种类型的操作和C的基于I/O文件操作类似，下表列出这类操作常用的函数及其功能。</p><p>　　FileOpen() 打开文件<br>　　FileClose() 关闭文件<br>　　FileRead() 读文件<br>　　FileSeek() 文件定位<br>　　FileWrite() 写文件<br>　　FileCreate() 创建文件</p><p>　　下面就对这些函数作详细介绍。</p><p>　　<strong>⑴FileOpen()</strong> </p><p>　　功能：打开文件，如果成功返回其句柄，否则返回-1</p><p>　　参数：FileName:要打开的文件名；Mode：打开的方式，取值如下表，可用”或”(“|”)运算符连接。</p><p>　　常量 值 说明 </p><p>　　fmOpenRead 0 以只读属性打开<br>　　fmOpenWrite 1 以只写属性打开<br>　　fmOpenReadWrite 2 以读/写属性打开<br>　　fmShareCompat 0 兼容FCB方式(汇编中有相应的DOS功能调用)<br>　　fmShareExclusive 16 共享方式：以独占方式打开，在关闭以前，别人不能访问<br>　　fmShareDenyWrite 32 共享方式：拒绝写访问<br>　　fmShareDenyRead 48 共享方式：拒绝读访问<br>　　fmShareDenyNone 64 共享方式：无限制，允许读写<br>　　例：int i=FileOpen(“C://WINDOWS//Win.ini”,fmOpenReadWrite|fmShareExclusive);</p><p>　　<strong>⑵FileClose()</strong> </p><p>　　功能：关闭打开的句柄。</p><p>　　参数：Handle:要关闭的句柄</p><p>　　例：FileClose(i);</p><p>　　<strong>⑶FileRead()</strong> </p><p>　　功能：读文件，返回实际读取的字节数，句柄必须首先由FileOpen或FileCreate创建。</p><p>　　参数：Handle:要读取的句柄；Buffer:存放读取的数据的缓冲区；Count:想读取的字节数</p><p>　　例：char str[400];FileRead(hnd1,str,400);</p><p>　　<strong>⑷FileSeek()</strong> </p><p>　　功能：移动文件读取指针，成功返回文件指针的位置，失败返回-1</p><p>　　参数：Handle:相关联的句柄；Offset:移动的量；Orgin:移动的基准，0=文件头，1=当前位置，2=文件尾。</p><p>　　例：ShowMessage(FileSeek(hnd1,0,2));//取得文件的长度</p><p>　　<strong>⑸FileWrite()</strong> </p><p>　　功能：写文件，返回实际写入的字节数，句柄必须首先由FileOpen或FileCreate创建。</p><p>　　参数：Handle:要写入的句柄；Buffer:存放写入数据的缓冲区；Count:想写入的字节数</p><p>　　例：char str[]=”I Love You”;FileWrite(hnd1,str,strlen(str));</p><p>　　<strong>⑹FileCreate()</strong> </p><p>　　功能：创建文件。成功返回其句柄，否则返回-1</p><p>　　参数：FileName:要创建的文件名</p><p>　　例：if(!FileExists(“KC.C”))hnd1=FileCreate(“KC.C”);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;·类和对象&quot;&gt;&lt;a href=&quot;#·类和对象&quot; class=&quot;headerlink&quot; title=&quot;·类和对象&quot;&gt;&lt;/a&gt;·类和对象&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1.c++面向对象的三大特性：封装、继承、多态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习周报" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>1.11-1.17周报汇总</title>
    <link href="http://example.com/2021/01/18/1.11-1.17%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2021/01/18/1.11-1.17%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/</id>
    <published>2021-01-18T06:11:37.000Z</published>
    <updated>2021-01-27T07:58:45.035Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>常规预处理命令</td><td>&lt;stdio.h&gt;</td><td><iostream>  后加using namespace std，声明存储位置；</iostream></td></tr><tr><td>输入</td><td>scanf（“%d,%d”，&amp;m,&amp;n）；</td><td>cin&gt;&gt;m&gt;&gt;n;</td></tr><tr><td>输出</td><td>printf（“%d”，m）；</td><td>cout&lt;&lt;m；</td></tr><tr><td>换行符</td><td>\n</td><td>endl（\n依旧沿用）</td></tr></tbody></table><h3 id="C-的数据类型"><a href="#C-的数据类型" class="headerlink" title="C++的数据类型"></a>C++的数据类型</h3><p><img src="/2021/01/18/1.11-1.17%E5%91%A8%E6%8A%A5%E6%B1%87%E6%80%BB/pic-1.jpg" alt="pic-1"></p><p><u>*布尔常量：布尔常量其数据类型为bool ，其取值只有两个：false（假）和true（真）。</u></p><p>*C++的基本数据类型与C基本相同：</p><p>基本数据类型（以32位编译系统为例）</p><table><thead><tr><th>类型名</th><th>字宽</th><th>取值范围</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>-128~127</td></tr><tr><td>signed char</td><td>1</td><td>-128~127</td></tr><tr><td>unsigned char</td><td>1</td><td>0~255</td></tr><tr><td>short [int]</td><td>2</td><td>-32768~32767</td></tr><tr><td>signed short [int]</td><td>2</td><td>-32768~32767</td></tr><tr><td>unsigned short [int]</td><td>2</td><td>0-65535</td></tr><tr><td>int</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>signed [int]</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned [int]</td><td>4</td><td>0-4294967295</td></tr><tr><td>long [int]</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>signed long [int]</td><td>4</td><td>-2147483648~2147483647</td></tr><tr><td>unsigned long [int]</td><td>4</td><td>0-4294967295</td></tr><tr><td>float</td><td>4</td><td>约6位有效数字</td></tr><tr><td>double</td><td>8</td><td>约12位有效数字</td></tr><tr><td>long double</td><td>16</td><td>约15位有效数字</td></tr></tbody></table><h3 id="定义C-语言的标识符应该遵循如下规则："><a href="#定义C-语言的标识符应该遵循如下规则：" class="headerlink" title="定义C++语言的标识符应该遵循如下规则："></a>定义C++语言的标识符应该遵循如下规则：</h3><p>(1)标识符只能由字母、数字和下划线三类字符组成。</p><p>(2)第一个字符必须为字母（第一个字符也可以是下划线，但通常被视为系统自定义的标识符）。</p><p>(3)大写字母和小写字母被认为是两个不同的字符。</p><p>(4)标识符长度不限，其有效长度通常依赖于机器类型，为便于阅读，一般用有意义的单词序列的命名方法。</p><p>(5)标识符不能是C++的关键字。</p><p>C++系统关键字是系统已经预定义的一些标识符，它们的意义和作用由系统规定。</p><table><thead><tr><th>关键字</th><th>含义描述</th><th>关键字</th><th>含义描述</th></tr></thead><tbody><tr><td>break</td><td>跳出循环体，结束循环</td><td>public</td><td>公有成员；公有继承</td></tr><tr><td>case</td><td>分支语句中的分支</td><td>return</td><td>从函数中返回</td></tr><tr><td>char</td><td>字符型数据</td><td>short</td><td>短整型数据</td></tr><tr><td>class</td><td>定义类的关键字</td><td>signed</td><td>有符号型数据</td></tr><tr><td>const</td><td>常量符号</td><td>sizeof</td><td>取数据类型长度运算符</td></tr><tr><td>continue</td><td>跳出本次循环，进行下一次</td><td>static</td><td>静态数据</td></tr><tr><td>default</td><td>分支语句中的默认分支</td><td>struct</td><td>定义结构体类型数据</td></tr><tr><td>delete</td><td>释放指针指向的内存块</td><td>switch</td><td>分支语句</td></tr><tr><td>do</td><td>do型循环</td><td>template</td><td>声明模板</td></tr><tr><td>double</td><td>双精度浮点型数据</td><td>this</td><td>本类指针</td></tr><tr><td>else</td><td>判断语句中的否定分支</td><td>typedef</td><td>重定义数据类型</td></tr><tr><td>enum</td><td>定义枚举型数据</td><td>union</td><td>定义联合体型数据</td></tr><tr><td>extern</td><td>声明外部变量</td><td>virtual</td><td>虚继承；虚函数</td></tr><tr><td>float</td><td>单精度浮点型数据</td><td>void</td><td>定义函数不返回数值</td></tr><tr><td>for</td><td>for型循环</td><td>while</td><td>while型循环</td></tr><tr><td>friend</td><td>友元类</td><td>int</td><td>整型数据</td></tr><tr><td>goto</td><td>跳转语句</td><td>long</td><td>长整型数据</td></tr><tr><td>if</td><td>条件判断语句</td><td>new</td><td>申请内存块</td></tr><tr><td>inline</td><td>声明为内联函数</td><td>operator</td><td>定义运算符重载</td></tr><tr><td>protected</td><td>保护成员；保护继承</td><td>private</td><td>私有成员；私有继承</td></tr></tbody></table><h3 id="C-中各类符号表示："><a href="#C-中各类符号表示：" class="headerlink" title="C++中各类符号表示："></a>C++中各类符号表示：</h3><table><thead><tr><th>转义字符</th><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>‘\a’</td><td>响铃符</td><td>用于输出</td></tr><tr><td>‘\b’</td><td>退格符</td><td>用于回退一个字符</td></tr><tr><td>‘\f’</td><td>换页符</td><td>用于输出</td></tr><tr><td>‘\r’</td><td>回车符</td><td>用于输出</td></tr><tr><td>‘\t’</td><td>水平制表符</td><td>用于制表</td></tr><tr><td>‘\’</td><td>反斜杠符</td><td>用于输出或文件的路径名中</td></tr><tr><td>‘\’’</td><td>单引号</td><td>用于输出单引号</td></tr><tr><td>‘\”’</td><td>双引号</td><td>用于输出双引号</td></tr><tr><td>‘\0’</td><td>空字符</td><td>用于结束标志</td></tr></tbody></table><table><thead><tr><th>符号表示</th><th>含义描述</th></tr></thead><tbody><tr><td>+</td><td>加法运算符，或正值运算符</td></tr><tr><td>-</td><td>减法运算符，或负值运算符</td></tr><tr><td>*</td><td>乘法运算符</td></tr><tr><td>/</td><td>除法运算符</td></tr><tr><td>%</td><td>求余运算符</td></tr></tbody></table><table><thead><tr><th>符号表示</th><th>含义描述</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr><tr><td>==</td><td>相等</td></tr><tr><td>!=</td><td>不相等</td></tr></tbody></table><table><thead><tr><th>符号表示</th><th>含义描述</th></tr></thead><tbody><tr><td>~</td><td>按位求反</td></tr><tr><td>&amp;</td><td>按位与</td></tr><tr><td>|</td><td>按位或</td></tr><tr><td>^</td><td>按位异或</td></tr><tr><td>&lt;&lt;</td><td>左移</td></tr><tr><td>&gt;&gt;</td><td>右移</td></tr></tbody></table><table><thead><tr><th>符号表示</th><th>含义描述</th></tr></thead><tbody><tr><td>!</td><td>单目运算符，逻辑非</td></tr><tr><td>&amp;&amp;</td><td>双目运算符，逻辑与</td></tr><tr><td>||</td><td>双目运算符，逻辑或</td></tr></tbody></table><table><thead><tr><th>符号表示</th><th>含义描述</th></tr></thead><tbody><tr><td>+=</td><td>加赋值</td></tr><tr><td>*=</td><td>乘赋值</td></tr><tr><td>%=</td><td>求余赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移位赋值</td></tr><tr><td>|=</td><td>按位或赋值</td></tr><tr><td>-=</td><td>减赋值</td></tr><tr><td>/=</td><td>除赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移位赋值</td></tr><tr><td>&amp;=</td><td>按位与赋值</td></tr><tr><td>^=</td><td>按位异或赋值</td></tr></tbody></table><p>按位求反“~”是将各个二进制位由1变成0，由0变成1，它是一个单目运算符。</p><p>按位与“&amp;”是将两个二进制位的操作数从低位到高位依次对齐后，每位求与运算。只有两个都是1时，结果为1，否则为0。</p><p>按位或“|”是将两个二进制位的操作数从低位到高位依次对齐后，每位求或运算。只有两个都是0时，结果为0，否则为1。</p><p>按位异或“^”是将两个二进制位的操作数从低位到高位依次对齐后，每位求异或运算。只要两个位不同时，结果为1，否则为0。</p><p>左移“&lt;&lt;”是将一个二进制数的数按指定移动的位数向左移动，移掉的被丢弃，右边移出的空位补0。</p><p>右移“&gt;&gt;”是将一个二进制数的数按指定移动的位数向右移动，移掉的被丢弃，左边移出的空位或者一律补0或者补符号位，这要由机器决定。</p><h3 id="选择结构："><a href="#选择结构：" class="headerlink" title="选择结构："></a>选择结构：</h3><p>\1. if语句——单行if语句，多行if语句，多条件if语句，嵌套if（使用方式和c语言基本相同）</p><p>\2. 表达式？x：y——三目运算符（使用方法和c语言基本相同）</p><p>\3. Swtch语句——switch（整型和字符）{case 常量：break；}（使用方法和c语言基本相同）</p><p>\4. While与do whlie语句——while（条件）{循环体}/do{循环体}while（条件）（使用方法与c语言基本相同）</p><p>rand（）生成一个【0，1）的随机数</p><h2 id="·函数："><a href="#·函数：" class="headerlink" title="·函数："></a>·函数：</h2><h3 id="函数的分文件编写："><a href="#函数的分文件编写：" class="headerlink" title="函数的分文件编写："></a>函数的分文件编写：</h3><p>1.创建后缀名.h的头文件</p><p>2.创建后缀名.cpp的源文件</p><p>3.在头文件中写函数的声明</p><p>4.在源文件中写函数的定义：包含<iostream>的同时还需要包含创建的“自定义头文件”</iostream></p><h5 id="如上，再次使用的时候直接引用自定义头文件就能够使用已定义在另一文件的函数里。"><a href="#如上，再次使用的时候直接引用自定义头文件就能够使用已定义在另一文件的函数里。" class="headerlink" title="如上，再次使用的时候直接引用自定义头文件就能够使用已定义在另一文件的函数里。"></a>如上，再次使用的时候直接引用自定义头文件就能够使用已定义在另一文件的函数里。</h5><h2 id="·指针："><a href="#·指针：" class="headerlink" title="·指针："></a>·指针：</h2><h3 id="空指针和野指针："><a href="#空指针和野指针：" class="headerlink" title="空指针和野指针："></a>空指针和野指针：</h3><p><strong>空指针：</strong>指针变量指向内存中编号为0的空间，用于初始化指针变量。</p><p><strong>（注：指向的内存不可以访问，0~255之间的内存编号为系统占用。）</strong></p><p>野指针：指针变量指向非法的内存空间【例如int*p=（int *）0x1100】</p><p><strong>由于指针的指向内容不一定在所申请的内存空间范围内，在程序中尽可能避免出现访问非法（未申请空间）的野指针。</strong></p><h3 id="const修饰指针："><a href="#const修饰指针：" class="headerlink" title="const修饰指针："></a>const修饰指针：</h3><p>1.const修饰指针——常量指针（const int*p=&amp;a）：指针的指向可以修改，但是指针指向的值不可以改</p><p>2.const修饰常量——指针常量（int * const p=&amp;a）：指针的指向不可以改，但是指针指向的值可以改</p><p>3.const即修饰指针又修饰常量（const int * const p=&amp;a）:指针的指向和指针指向的值都不能改</p><h3 id="函数指针：指向函数的指针"><a href="#函数指针：指向函数的指针" class="headerlink" title="函数指针：指向函数的指针"></a>函数指针：指向函数的指针</h3><p>函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。</p><p>一个函数的地址是该函数的进入点，也是调用函数的地址。</p><p>函数的调用可以通过函数名，也可以通过指向函数的指针来调用。</p><p>函数指针还允许将函数作为变元传递给其他函数。</p><p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p><p>定义形式：</p><pre><code>    类型 （*指针变量名）（参数列表）；</code></pre><p>例如：</p><pre><code>    int (*p)(int i,int j);</code></pre><p>p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。</p><p>p首先和*结合，表明p是一个指针。然后再与（）结合，表明它指向的是一个函数。</p><p>指向函数的指针也称为函数指针。</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h4><pre><code>int *f(int i, int j);//返回值是指针的函数fint (*p)(int i, int j);//指向函数的指针p</code></pre><h2 id="·结构体："><a href="#·结构体：" class="headerlink" title="·结构体："></a>·结构体：</h2><h3 id="1-基本概念："><a href="#1-基本概念：" class="headerlink" title="1.基本概念："></a>1.基本概念：</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="2-结构体定义和使用："><a href="#2-结构体定义和使用：" class="headerlink" title="2.结构体定义和使用："></a>2.结构体定义和使用：</h3><pre><code>struct 结构体名称 &#123; 结构体成员列表 &#125;；</code></pre><p>通过结构体创建变量的方式如下三种：**(创建变量时，struct 关键字可以省略)**</p><ul><li><p><strong>struct 结构体名 变量名</strong></p></li><li><p><strong>struct 结构体名 变量名 ={ 成员1值，成员2值……}</strong></p></li><li><p><strong>定义结构体时顺便创建变量</strong></p></li></ul><h3 id="3-结构体数组"><a href="#3-结构体数组" class="headerlink" title="3.结构体数组"></a>3.结构体数组</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>将自定义的结构体放入数组中，方便自定义结构体的维护</p><h4 id="形如："><a href="#形如：" class="headerlink" title="形如："></a>形如：</h4><pre><code>struct 结构体名 数组名[元素个数] =&#123;&#123;&#125;，&#123;&#125;，&#123;&#125;......&#125;；</code></pre><h4 id="结构体数组遍历："><a href="#结构体数组遍历：" class="headerlink" title="结构体数组遍历："></a>结构体数组遍历：</h4><pre><code>for (int i = 0;i &lt; 3;i++)//遍历每个结构体&#123;    cout&lt;&lt;结构体名 数组名[i].成员&lt;&lt;endl;//即输出所有结构体的某一成员&#125;</code></pre><h3 id="4-结构体指针："><a href="#4-结构体指针：" class="headerlink" title="4.结构体指针："></a>4.结构体指针：</h3><p>作用：通过指针访问结构体中成员</p><h5 id="使用操作符-gt-可以通过结构体指针访问结构体属性"><a href="#使用操作符-gt-可以通过结构体指针访问结构体属性" class="headerlink" title="使用操作符-&gt;可以通过结构体指针访问结构体属性"></a>使用操作符-&gt;可以通过结构体指针访问结构体属性</h5><pre><code>在学习C++的过程中我们经常会用到.和::和:和-&gt;，在此整理一下这些常用符号的区别。   1、A.B则A为对象或者结构体(s1.age=18;)；  2、A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；  3*、::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；  4*、:一般用来表示继承；</code></pre><p>*<em>注意：定义指针时，指针的类型应该与被指向的结构体变量相符，即用“struct 结构体名 * 指针名”*</em></p><h3 id="5-结构体嵌套结构体"><a href="#5-结构体嵌套结构体" class="headerlink" title="5.结构体嵌套结构体"></a>5.结构体嵌套结构体</h3><p>作用：在一个结构体内嵌套另一个结构体，即将结构体的成员设置为结构体（参考嵌套if）</p><p><strong>注意：在定义外层结构体前，需要先定义内层结构体</strong></p><h3 id="6-结构体做函数参数"><a href="#6-结构体做函数参数" class="headerlink" title="6.结构体做函数参数"></a>6.结构体做函数参数</h3><p>作用：将结构体作为参数向函数中传递</p><p><strong>两种传递方式：值传递、地址传递</strong>（同基本数据类型相同）</p><h3 id="7-结构体中const使用场景"><a href="#7-结构体中const使用场景" class="headerlink" title="7.结构体中const使用场景"></a>7.结构体中const使用场景</h3><p>作用：用const来防止误操作，一旦有修改的操作就会报错</p><h2 id="·引用："><a href="#·引用：" class="headerlink" title="·引用："></a>·引用：</h2><h3 id="1-用处："><a href="#1-用处：" class="headerlink" title="1.用处："></a><strong>1.用处：</strong></h3><p>给一个变量起别名，通过多个变量名修改变量值</p><h3 id="2-形如："><a href="#2-形如：" class="headerlink" title="2.形如："></a><strong>2.形如：</strong></h3><pre><code>数据类型 &amp;别名 = 原名</code></pre><h3 id="3-注意事项：引用必须初始化，且在初始化后不可以改变"><a href="#3-注意事项：引用必须初始化，且在初始化后不可以改变" class="headerlink" title="3.注意事项：引用必须初始化，且在初始化后不可以改变"></a>3.注意事项：引用必须初始化，且在初始化后不可以改变</h3><h3 id="4-引用做函数参数"><a href="#4-引用做函数参数" class="headerlink" title="4.引用做函数参数"></a>4.引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><h3 id="5-引用做函数返回值"><a href="#5-引用做函数返回值" class="headerlink" title="5.引用做函数返回值"></a>5.引用做函数返回值</h3><p><strong>用法：</strong>函数调用可以作为左值</p><p><strong>（f（）=1000；先运行返回引用的函数f（）得到返回值，然后返回值=1000）</strong></p><p><strong>注意：不要返回局部变量引用——可给局部变量加static前缀，变成静态变量</strong></p><p><em>（第一次结果因为编译器做了保留，所以正确，但第二次局部变量已经被释放，结果会乱码错误。）</em></p><h3 id="6-引用的本质：引用在c-内部的实现，实际上是一个指针常量"><a href="#6-引用的本质：引用在c-内部的实现，实际上是一个指针常量" class="headerlink" title="6.引用的本质：引用在c++内部的实现，实际上是一个指针常量"></a>6.引用的本质：引用在c++内部的实现，实际上是一个指针常量</h3><h3 id="7-常量引用"><a href="#7-常量引用" class="headerlink" title="7.常量引用"></a>7.常量引用</h3><p><strong>作用：常量引用主要用来修饰形参，防止误操作，在函数形参列表中加const修饰形参，防止形参改变实参</strong></p><h2 id="·函数提高："><a href="#·函数提高：" class="headerlink" title="·函数提高："></a>·函数提高：</h2><h3 id="1-函数默认参数"><a href="#1-函数默认参数" class="headerlink" title="1.函数默认参数"></a>1.函数默认参数</h3><p><strong>语法：</strong></p><pre><code>返回值类型 函数名 （参数=默认值）&#123;函数体&#125;</code></pre><p>注意事项：</p><p>1.如果某个位置已经有了默认参数，那么之后都必须有默认值</p><p>2.如果函数声明中有默认参数，函数实现中不能有默认参数（重定义）</p><h3 id="2-函数占位参数"><a href="#2-函数占位参数" class="headerlink" title="2.函数占位参数"></a>2.函数占位参数</h3><p>c++中函数的形参列表可以有占位参数，用来做占位，调用函数时，必须填补该位置</p><p>语法：</p><pre><code>返回值类型 函数名 （数据类型无形参名）&#123;函数体&#125;</code></pre><p><strong>注意：占位参数也可以有默认参数</strong></p><h3 id="3-函数重载"><a href="#3-函数重载" class="headerlink" title="3.函数重载"></a>3.函数重载</h3><p>作用：函数名可以相同，提高复用性</p><h4 id="1-函数重载满足条件："><a href="#1-函数重载满足条件：" class="headerlink" title="1.函数重载满足条件："></a><strong>1.函数重载满足条件：</strong></h4><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数类型不同，或者个数不同，或者顺序不同</li></ul><p>*<strong>函数的返回值不可以作为函数重载的条件</strong></p><h4 id="2-注意事项："><a href="#2-注意事项：" class="headerlink" title="2.注意事项："></a>2.注意事项：</h4><ul><li><p>引用作为重载条件（int &amp;a——应用变量，const int &amp;a——应用常量）</p></li><li><p>函数重载遇到函数的默认参数（在默认参数影响下，输入的函数参数个数可以变化，并有可能与重载的其他函数重复，从而产生错误）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;C++&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;常规预处理命令&lt;/td&gt;
&lt;td&gt;&amp;lt;stdio.h&amp;gt;&lt;/td&gt;
&lt;td&gt;&lt;iostream&gt;  </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习周报" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>初来乍到，请多指教</title>
    <link href="http://example.com/2021/01/17/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99/"/>
    <id>http://example.com/2021/01/17/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0%EF%BC%8C%E8%AF%B7%E5%A4%9A%E6%8C%87%E6%95%99/</id>
    <published>2021-01-17T05:39:45.000Z</published>
    <updated>2021-01-23T09:06:17.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="试验条幅，请勿注目"><a href="#试验条幅，请勿注目" class="headerlink" title="试验条幅，请勿注目"></a>试验条幅，请勿注目</h1><h3 id="哎，初来乍到，本座封艾羽，中二病晚期death，这里只是个简简单单的介绍。"><a href="#哎，初来乍到，本座封艾羽，中二病晚期death，这里只是个简简单单的介绍。" class="headerlink" title="哎，初来乍到，本座封艾羽，中二病晚期death，这里只是个简简单单的介绍。"></a>哎，初来乍到，本座封艾羽，中二病晚期death，这里只是个简简单单的介绍。</h3><h4 id="虽说我也不知道这玩意存在的意义到底是啥嘞，反正总之，存在即合理了嘛"><a href="#虽说我也不知道这玩意存在的意义到底是啥嘞，反正总之，存在即合理了嘛" class="headerlink" title="虽说我也不知道这玩意存在的意义到底是啥嘞，反正总之，存在即合理了嘛~"></a>虽说我也不知道这玩意存在的意义到底是啥嘞，反正总之，存在即合理了嘛~</h4><p>那么，就这样。</p><h1 id="今后还请多指教！"><a href="#今后还请多指教！" class="headerlink" title="今后还请多指教！"></a>今后还请多指教！</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;试验条幅，请勿注目&quot;&gt;&lt;a href=&quot;#试验条幅，请勿注目&quot; class=&quot;headerlink&quot; title=&quot;试验条幅，请勿注目&quot;&gt;&lt;/a&gt;试验条幅，请勿注目&lt;/h1&gt;&lt;h3 id=&quot;哎，初来乍到，本座封艾羽，中二病晚期death，这里只是个简简单单的介绍。</summary>
      
    
    
    
    <category term="闲谈" scheme="http://example.com/categories/%E9%97%B2%E8%B0%88/"/>
    
    
    <category term="其他" scheme="http://example.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
</feed>
