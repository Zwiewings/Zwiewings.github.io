<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="https://zwiewings.github.io/atom.xml" rel="self"/>
  
  <link href="https://zwiewings.github.io/"/>
  <updated>2021-08-27T13:39:36.785Z</updated>
  <id>https://zwiewings.github.io/</id>
  
  <author>
    <name>Zweiwings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaWeb学习-2</title>
    <link href="https://zwiewings.github.io/2021/08/27/JavaWeb%E5%AD%A6%E4%B9%A0-2/"/>
    <id>https://zwiewings.github.io/2021/08/27/JavaWeb%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2021-08-27T12:27:08.000Z</published>
    <updated>2021-08-27T13:39:36.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>数据库的特点：</p><ul><li>持久化存储数据的文件系统</li><li>方便存储和管理数据</li><li>使用了统一的方式操作数据库——SQL</li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>配置：（在使用管理员打开cmd的前提下）</p><ul><li>net start mysql：启动MySQL服务</li><li>net stop mysql：关闭MySQL服务</li></ul><p>登录：mysql -uroot -p——回车——输入密码</p><p>远程登录：mysql  -h主机IP地址 -uroot -p连接目标的密码</p><p>退出：exit/quit</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><strong>安装目录：</strong></p><p>-bin：可执行二进制文件目录</p><p>-data：用户数据目录</p><p>-include：c#头文件目录</p><p>-lib：运行所需要的库文件</p><p>-share：mysql的一些错误信息</p><p>-my.ini：mysql的配置文件</p><p><strong>数据目录：（默认在C:\ProgramData\MySQL\MySQL Server 5.5\data）<img src="/2021/08/27/JavaWeb%E5%AD%A6%E4%B9%A0-2/1.png" alt="1"></strong></p><p>数据目录下，数据库——文件夹，表——文件，数据——具体数据</p>]]></content>
    
    
    <summary type="html">JavaWeb相关数据库理论</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="JavaWeb" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/JavaWeb/"/>
    
    
    <category term="JavaWeb" scheme="https://zwiewings.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb基础-1</title>
    <link href="https://zwiewings.github.io/2021/08/21/JavaWeb%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://zwiewings.github.io/2021/08/21/JavaWeb%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-08-21T11:49:40.000Z</published>
    <updated>2021-08-27T12:25:05.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Junit单元测试"><a href="#Junit单元测试" class="headerlink" title="Junit单元测试"></a>Junit单元测试</h1><p>Junit使用：白盒测试</p><p>步骤：</p><ol><li>定义一个测试类</li><li>定义一个测试方法：可以独立运行</li><li>给方法加上@Test注解</li><li>导入junit依赖</li></ol><p>判定结果：一般使用断言操作处理结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Assert.assertEquals(期望的结果，运算的结果);</span><br></pre></td></tr></table></figure><p>@Before：修饰的方法会在测试方法之前被自动执行</p><p>@After：修饰的方法会在测试方法执行之后自动被执行，即使测试方法报错也同样执行</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>反射：将类的各个组成部分封装为其他对象</strong></p><p>反射是框架设计的灵魂，在框架的基础上进行软件开发能够有效的简化编码工作</p><p>如图，Java代码在计算机中运行分为如下三个阶段：</p><p><img src="/2021/08/21/JavaWeb%E5%AD%A6%E4%B9%A0-1/1.jpg" alt="1"></p><p>其中，由Sourse源代码阶段到Class类对象阶段的过程就是反射机制</p><p><strong>反射的好处</strong>：</p><ul><li>可以在程序运行过程中操作这些对象</li><li>可以降低程序的耦合性，提高程序可扩展性</li></ul><h2 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h2><h3 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h3><ul><li><p>Sourse源代码阶段——**Class.forName(“全类名”)**：将字节码文件加载进内存，返回Class对象——多用于配置文件，将类名定义在配置文件中，读取文件，加载类</p><p>其中全类名即包名.类名，如：PersonTest.Person，且由于类名可能有误，该方法可能会出现异常</p></li><li><p>Class类对象阶段——<strong>类名.class</strong>：通过类名的属性class获取——多用于参数的传递</p></li><li><p>RunTime运行时阶段——**对象.getClass()**：getClass()方法定义在Object类中，即被所有类直接或间接继承——多用于对象的获取字节码的方式</p></li></ul><div class="tip warning"><p></p><p><strong>同一个字节码文件（xx.class）在一次程序运行中都只会被加载一次，无论通过哪种方式获取的class对象都是同一个</strong></p><p></p></div><h3 id="Class对象功能"><a href="#Class对象功能" class="headerlink" title="Class对象功能"></a>Class对象功能</h3><ul><li><p>获取成员变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() <span class="comment">//获取所有public修饰的成员变量</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">//获取指定名称的 public修饰的成员变量</span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>  <span class="comment">//获取所有的成员变量，不考虑修饰符</span></span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>  </span></span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors()  </span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>  </span></span><br></pre></td></tr></table></figure></li><li><p>获取成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] getMethods()  <span class="comment">//获取所有public修饰的方法</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span> </span></span><br></pre></td></tr></table></figure></li><li><p>获取类名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    <span class="comment">//使用类对象调用，得到的类名是全类名</span></span></span><br></pre></td></tr></table></figure><h4 id="Field：成员变量"><a href="#Field：成员变量" class="headerlink" title="Field：成员变量"></a><strong>Field：成员变量</strong></h4></li><li><p>设置值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj,object value)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传入成员变量名，以及设置给该变量的值</span></span></span><br></pre></td></tr></table></figure></li><li><p>获取值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">get(Object obj)</span><br></pre></td></tr></table></figure></li><li><p>忽略访问权限修饰符的安全检查</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射</span></span><br></pre></td></tr></table></figure><h4 id="Constructor：构造方法"><a href="#Constructor：构造方法" class="headerlink" title="Constructor：构造方法"></a><strong>Constructor：构造方法</strong></h4></li></ul><p>创建对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object… initargs)</span></span></span><br><span class="line"><span class="function">如：</span></span><br><span class="line"><span class="function">    Constructor constructor</span>=personClass.getConstructor(String.class,<span class="keyword">int</span>.class);<span class="comment">//得到构造方法对象</span></span><br><span class="line">    constructor.newInstance(<span class="string">&quot;小明&quot;</span>,<span class="number">12</span>);<span class="comment">//用构造方法对象创建personClass类对象 对应的类 的对象</span></span><br></pre></td></tr></table></figure><p>如果使用空参创建对象，操作可以简化：使用class对象的newInstance方法</p><h4 id="Method：方法对象"><a href="#Method：方法对象" class="headerlink" title="Method：方法对象"></a>Method：方法对象</h4><p>执行方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj,Object… args)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//需要传入方法对象，如果有参数，需要传入参数</span></span></span><br></pre></td></tr></table></figure><p>获取方法名：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//使用方法对象调用，得到的是方法名</span></span></span><br></pre></td></tr></table></figure><h2 id="反射-案例"><a href="#反射-案例" class="headerlink" title="反射-案例"></a>反射-案例</h2><p><strong>需求：</strong>完成一个“框架”，在不改变该类任何代码的前提下，可以创建任意类的对象，并调用其中任意方法</p><p><strong>实现：</strong></p><ol><li>配置文件</li><li>反射</li></ol><p><strong>步骤：</strong></p><ol><li><p>将需要创建的对象的全类名和需要执行的方法定义在配置文件</p><p>创建一个pro.properties文件于同目录下，并定义全类名与执行方法，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">className&#x3D;test1.test.Person&#x2F;&#x2F;此处写Person类的全类名</span><br><span class="line">methodName&#x3D;breathe&#x2F;&#x2F;此处写需要调用的方法</span><br></pre></td></tr></table></figure></li><li><p>在程序中加载读取配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pro=<span class="keyword">new</span> Properties();<span class="comment">//创建一个Properties对象</span></span><br><span class="line">ClassLoader classLoader=Test.class.getClassLoader();<span class="comment">//获取测试类的类加载器</span></span><br><span class="line">InputStream is=classLoader.getResourceAsStream(<span class="string">&quot;pro.properties&quot;</span>);<span class="comment">//用类加载器的getResourceAsStream方法获取文件pro.properties路径作为字节流</span></span><br><span class="line">pro.load(is);<span class="comment">//用pro对象调用load方法，加载is路径下配置文件到pro中</span></span><br><span class="line">String className=pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">String methodName=pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">//获取配置文件中的className和mehodName存为变量</span></span><br></pre></td></tr></table></figure></li><li><p>使用反射来加载类文件进内存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cls=Class.forName(className);<span class="comment">//用类名获取类对象</span></span><br></pre></td></tr></table></figure></li><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=cls.newInstance();<span class="comment">//用class的newInstance方法创建对象</span></span><br><span class="line">Method method=cls.getMethod(methodName);<span class="comment">//用方法名获取该类中的同名方法</span></span><br></pre></td></tr></table></figure></li><li><p>执行方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">method.invoke();<span class="comment">//通过方法对象执行方法</span></span><br></pre></td></tr></table></figure><p>通过该种方法，可以在不修改原码的基础上变更创建对象的类和对象调用的方法，只需要修改配置文件中的值即可</p></li></ol><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>也称元数据，放在包、类、字段、方法、局部变量等前面，用于对这些元素进行说明注释，使用注解时写作：@注解名称</p><p><strong>作用分类：</strong></p><p>编写文档：通过代码里标识的元数据生成文档【通过javadoc命令生成doc文档】</p><p>代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</p><p>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【@Override】</p><h2 id="JDK中预定义的注解"><a href="#JDK中预定义的注解" class="headerlink" title="JDK中预定义的注解"></a>JDK中预定义的注解</h2><p>@Override：用于检测被该注解标注的方法是否继承自父类（接口）</p><p>@Deprecated：该注解标注的内容表示已过时</p><p>@SuppressWarnings：用于压制警告，一般传递参数all，写作@SuppressWarnings(“all”)</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>注解本质上就是一个接口，该接口默认继承自Annotation接口</p><p>自定义注解编译为class文件后再用javap命令反编译，java会自动生成一个文件，其文件内容类似如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnno</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>接口中的抽象方法，其要求如下：</p><ol><li>属性的返回值类型必须如下<ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li>定义了属性，在使用时需要给属性赋值<ol><li>如不想赋值，则需要加默认，即default后加初始值</li><li>如果只有一个属性需要赋值，且属性为value，则value可以省略，直接写值</li><li>数组赋值时，值使用{}包裹，若数组只有一个值，则{}可以省略</li></ol></li></ol><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>用于描述注解的注解，可用JDK已经定义的注解修饰自定义的注解，常用元注解如下：</p><ul><li>@Target：描述注解能够作用的位置<ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段，一般使用RetentionPolicy.RUNTIME，表示自定义的注解会保留到class字节码中，被JVM读取到</li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被其修饰的类的子类继承</li></ul><h2 id="程序中使用（解析）注解"><a href="#程序中使用（解析）注解" class="headerlink" title="程序中使用（解析）注解"></a>程序中使用（解析）注解</h2><p>主要是用于获取注解中定义的属性值</p><ol><li>获取注解定义的位置的对象（Class，Method，Field）</li><li>获取指定的注解：getAnnotation（Class），其实就是在内存中生成了一个该注解接口的子类实现对象</li><li>调用注解中的抽象方法获取配置的属性值</li></ol><h2 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h2><p>判断一个方法是否被一个注解修饰：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名.isAnnotationPresent(注解名.class)</span><br></pre></td></tr></table></figure><p>BufferedWriter对象创建文档并写入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;bug.txt&quot;</span>));</span><br><span class="line"><span class="comment">//通过BufferedWriter对象创建一个txt文档用于记录bug</span></span><br><span class="line">bw.write(method.getName()+<span class="string">&quot;方法出现异常：&quot;</span>+);<span class="comment">//写入记录</span></span><br><span class="line">bw.newline();<span class="comment">//新起一行</span></span><br><span class="line">bw.write(<span class="string">&quot;异常的名称：&quot;</span>+e.getCause().getClass().getSimpleName());</span><br><span class="line">bw.newline();<span class="comment">//其中e是捕捉到的异常，通过该方法可以获得其简单类名</span></span><br><span class="line">bw.write(<span class="string">&quot;异常的原因&quot;</span>+e.getCause().getMessage());</span><br><span class="line">bw.flush();<span class="comment">//将以上写入的内容打印到对应txt文档</span></span><br><span class="line">bw.close();<span class="comment">//关闭缓冲区</span></span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ul><li>比起自定义注解，已有的注解更加常用</li><li>注解是给编译器和解析程序使用的</li><li>注解不是程序的一部分，可以理解为一个标签</li></ul>]]></content>
    
    
    <summary type="html">JavaWeb相关基础加强</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="JavaWeb" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/JavaWeb/"/>
    
    
    <category term="JavaWeb" scheme="https://zwiewings.github.io/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-4</title>
    <link href="https://zwiewings.github.io/2021/08/19/Java%E5%AD%A6%E4%B9%A0-4/"/>
    <id>https://zwiewings.github.io/2021/08/19/Java%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-08-19T13:05:01.000Z</published>
    <updated>2021-08-21T11:55:33.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API（应用程序编程接口）"><a href="#API（应用程序编程接口）" class="headerlink" title="API（应用程序编程接口）"></a>API（应用程序编程接口）</h1><p>API是一些预先定义好的接口（如函数，HTTP接口）或指软件系统不同组成部分衔接的约定。用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节</p><p><strong>工具类的设计思想：</strong></p><ul><li>构造方法用private修饰（防止外界创建对象）</li><li>成员用public static修饰（强制用类名访问）</li></ul><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math包含执行基本数字运算的方法，成员均为静态，即可以通过类名调用,常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>返回大于或等于参数的最小double值，等于一个整数</td></tr><tr><td>public static double floor(double a)</td><td>返回小于或等于参数的最大double值，等于一个整数</td></tr><tr><td>public static int round(float a)</td><td>按照四舍五入返回最接近参数的int</td></tr><tr><td>public static int max(int a,int b)</td><td>返回两个int值中较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回两个int值中较小值</td></tr><tr><td>public static double pow(double a,double b)</td><td>返回a的b次幂的值</td></tr><tr><td>public static double random()</td><td>返回值为double的正值，[0.0,1.0)</td></tr></tbody></table><h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><p>System包含几个有用的类字段和方法，不能被实例化，常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行的Java虚拟机，非零表示异常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间（以毫秒为单位）</td></tr></tbody></table><p>其中currentTimeMillis()方法可通过记录开始和结束时间相减，计算程序运行时间</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object是类层次结构的根，每个类都可以将Object作为超类（父类），所有类都直接或者间接的继承自该类</p><p>构造方法：public Object()</p><p>常用方法如下：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String toString()</td><td>用于返回一个简明扼要的字符串来描述该对象，默认为“包名+类名+@+存储地址”，推荐子类重写</td></tr><tr><td>public boolean equals（Object obj）</td><td>比较对象是否相等，默认比较地址，重写可以比较内容</td></tr></tbody></table><p><strong>IDEA编译器中可用Alt+Insert自动生成子类的重写方法</strong></p><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>Arrays类包含用于操作数组的各种方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表示形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按照数字顺序排列指定的数组</td></tr></tbody></table><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据，常用的操作之一是用于基本数据类型与字符串之间的转换</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><ul><li><p>装箱：把基本数据类型转换为对应的包装类类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=Integer.valueOf(<span class="number">100</span>);<span class="comment">//装箱</span></span><br><span class="line">Integer ii=<span class="number">100</span>;<span class="comment">//自动装箱，自动转换成上一行代码</span></span><br></pre></td></tr></table></figure></li><li><p>拆箱：把包装类类型转换为对应的基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="number">100</span>;</span><br><span class="line">i=i.intValue()+<span class="number">200</span>;<span class="comment">//先拆箱，再自动装箱</span></span><br><span class="line">i+=<span class="number">200</span>;<span class="comment">//自动拆箱，自动装箱</span></span><br></pre></td></tr></table></figure><p>注：在使用包装类类型的时候，如果做操作，最好先判断不为null，推荐只要是对象，在使用前就必须进行不为null的判断</p></li></ul><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Date代表了一个特定的时间，精确到毫秒</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒</td></tr><tr><td>public Date(long date)</td><td>分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数</td></tr><tr><td>public long getTime()</td><td>获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，给的是毫秒值</td></tr></tbody></table><h3 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h3><p>用于以区域设置敏感的方式格式化和解析日期，日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从‘A’到‘Z’以及从‘a’到‘z’引号的字符被解释为表示日期或时间字符串的组件的模式字母</p><p>常用模式字母对应如下：</p><ul><li>y——年</li><li>M——月</li><li>d——日</li><li>H——时</li><li>m——分</li><li>s——秒</li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>构造一个SimpleDateFormat，使用默认模式和日期格式</td></tr><tr><td>public SimpleDateFormat(String pattern)</td><td>构造一个SimpleDateFormat，使用给定的模式和默认的日期格式</td></tr></tbody></table><div class="tip warning"><p></p><p>其中String pattern使用常用模式字母书写，如：2021年08月09日 21:24:19，对应的pattern写作：“yyyy年MM月dd日 HH:mm:ss”</p><p></p></div><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public final String format(Date date)</td><td>（Date到String）从将日期格式化成日期/时间字符串</td></tr><tr><td>public Date parse(String source)</td><td>（String到Date）从给定字符串的开始解析文本以生成日期</td></tr></tbody></table><div class="tip warning"><p></p><p>使用parse方法时，需要SimpleDateFormat对象的模式和字符串内容模式相符，且需要抛出异常或用try/catch包围，后者在IDEA中可使用Alt+Enter选择解决方案进行自动修改</p><p></p></div><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><p>Calendar为某一时刻和一组日历字段之间的转换提供了一些方法，并未操作日历字段提供了一些方法</p><p>Calendar提供一个类方法get    Instance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar rightNow=Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>对已有的Calendar对象，可以使用方法名为：public int get(int field) 的方法获取具体的日历字段，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year=c.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> month=c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//MONTH是从0开始计算的，故而在获取值的基础上+1</span></span><br><span class="line"><span class="keyword">int</span> date=c.get(Calendar.DATE);</span><br></pre></td></tr></table></figure><p>其他常用方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public abstract void add(int field,int amount)</td><td>根据日历的规则，将指定的时间量(field)添加或减去给定的日历字段(amount)</td></tr><tr><td>public final void set(int year,int month,int date)</td><td>设置当前日历的年月日</td></tr></tbody></table><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常即程序出现了非正常的情况，所有错误或异常均为Thowable类的直接子类或间接子类，异常体系如下：</p><p> <img src="/2021/08/19/Java%E5%AD%A6%E4%B9%A0-4/1.jpg" alt="1"></p><p>Error：严重问题，不需要处理</p><p>Exception：称为异常类，它表示程序本身可以处理的问题</p><ul><li>RuntimeException（运行时异常）：也称非受检异常，在编译期不检查，出现问题后需要重新修改代码</li><li>非RuntimeException（编译时异常）：也称受检异常，编译期必须处理，否则程序不能通过编译，更不能正常运行</li></ul><p><strong>JVM的默认处理方案</strong></p><p>在程序出现问题且没有做任何处理时，JVM会做默认的处理：</p><ol><li>将异常名称，原因，以及出现的位置等信息输出在控制台</li><li>程序停止执行</li></ol><h2 id="Throwable的成员方法"><a href="#Throwable的成员方法" class="headerlink" title="Throwable的成员方法"></a>Throwable的成员方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此throwable的详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回此throwable的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出在控制台</td></tr></tbody></table><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果程序出现异常，有两种处理方案：</p><ul><li>try…catch…</li><li>throws</li></ul><h3 id="try…catch…"><a href="#try…catch…" class="headerlink" title="try…catch…"></a>try…catch…</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的代码;</span><br><span class="line">&#125; <span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">    异常的处理代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程：</p><ol><li>程序从try中的代码开始执行</li><li>出现异常时自动生成一个异常类对象，该异常类对象将被提交给Java运行时系统</li><li>当Java运行时系统接收到异常对象时，会到catch中找匹配的异常类，找到后进行异常的处理</li><li>执行完毕后，程序还可以继续往下执行</li></ol><h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>对于try…catch…处理程序异常，但是并不是所有的情况我们都有权限进行异常处理，所以提供了另一种throws的处理方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throws</span> 异常类名; <span class="comment">//这个格式跟随在方法的括号后写</span></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> method <span class="keyword">throws</span> ArrayIndexOutOfBoundsException&#123;</span><br><span class="line">    <span class="comment">//此处省略方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>通过throws抛出异常实际上并没有处理异常，只是在方法内运行发生异常时，将该异常抛出，在调用方法时仍旧需要用try…catch…处理异常</p><p></p></div><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>Java已经提供的异常不一定能满足程序的所有需求，故而产生了自定义异常，实际上就是让自定义的类继承自Exception或RuntimeException类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 异常类名 <span class="keyword">extends</span> <span class="title">Exception</span>/<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    无参构造</span><br><span class="line">    带参构造</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般带参构造为：</span></span><br><span class="line"><span class="comment">    public 异常类名(String message)&#123;</span></span><br><span class="line"><span class="comment">    super(message);//让异常信息逐层调用父类构造</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他类中，可以使用以下语句抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名();</span><br></pre></td></tr></table></figure><p>且对继承自Exception的异常类，在含有该抛出异常对象语句的方法也应抛出对应的异常类，如继承自RuntimeException类则不必要</p><h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><table><thead><tr><th>throws</th><th>throw</th></tr></thead><tbody><tr><td>用在方法声明后面，跟的是异常类名</td><td>用在方法体内，跟的是异常对象名</td></tr><tr><td>表示抛出异常，由该方法的调用者来处理</td><td>表示抛出异常，由方法体内的语句处理</td></tr><tr><td>表示出现异常的一种可能性，并不一定会发生异常</td><td>执行throw一定是抛出了某种异常</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Java常用的API，异常及异常处理，Junit单元测试</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="基础" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://zwiewings.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-3</title>
    <link href="https://zwiewings.github.io/2021/08/09/Java%E5%AD%A6%E4%B9%A0-3/"/>
    <id>https://zwiewings.github.io/2021/08/09/Java%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-08-09T12:35:04.000Z</published>
    <updated>2021-08-19T13:06:37.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包（Package）"><a href="#包（Package）" class="headerlink" title="包（Package）"></a>包（Package）</h1><p>包是为了java程序编写时对类分类管理而创建的文件夹</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">package</span> 包名;(多级包用.隔开)</span><br><span class="line">如：<span class="keyword">package</span> JavaProject.first;</span><br><span class="line">实际上是创建了JavaProject文件夹，并在文件夹下创建first文件夹</span><br></pre></td></tr></table></figure><p>在编译带包的java文件时，可以手动创建包并将编译好的class文件放入包中，或者是通过命令“javac -d .文件名.java”在文件所在目录下自动创建包并完成编译，执行时需要带包执行，即“java JavaProject.first.文件名”</p><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>使用不同包下的类时，需要使用类的全路径，为了简化带包的操作，java提供了导包的功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">import</span> 包名;</span><br><span class="line">如：<span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">即导入java/util文件夹下的Scanner文件夹内所有类</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><table><thead><tr><th>访问权限</th><th>类</th><th>包</th><th>子类</th><th>其他包</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>∨</td><td>∨</td><td>∨</td><td>∨</td><td>对任何人都是可用的</td></tr><tr><td>protect</td><td>∨</td><td>∨</td><td>∨</td><td>×</td><td>继承的类可以访问以及和private一样的权限</td></tr><tr><td>default</td><td>∨</td><td>∨</td><td>×</td><td>×</td><td>包访问权限，即在整个包内均可被访问</td></tr><tr><td>private</td><td>∨</td><td>×</td><td>×</td><td>×</td><td>除类型创建者和类型的内部方法之外的任何人都不能访问的元素</td></tr></tbody></table><h3 id="状态修饰符"><a href="#状态修饰符" class="headerlink" title="状态修饰符"></a>状态修饰符</h3><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p>final（最终态）：可以修饰成员方法，成员变量，类</p><ul><li>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong></li><li>修饰变量：表明该变量时常量，<strong>不能再次被赋值</strong></li><li>修饰类：表明该类时最终类，<strong>不能被继承</strong></li><li>修饰局部变量：当变量是<strong>基本类型</strong>时，<strong>数据值不能改变</strong>，当变量时<strong>引用类型</strong>时，地址值不能改变，但<strong>数据值可以改变</strong></li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static（静态）：可以修饰成员方法和成员变量</p><p>static修饰的特点：</p><ul><li>被类的所有对象共享</li><li>可以通过对象名和类名调用，推荐类名调用</li></ul><p>static访问的特点：静态成员方法只能访问静态成员</p><h1 id="集合基础"><a href="#集合基础" class="headerlink" title="集合基础"></a>集合基础</h1><p>集合类可以提供一种存储空间可变的存储模型，存储的数据容量可以发生改变，较常用的有ArrayList</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList&lt; E&gt;：位于util包下，实现可调整大小的数组，其中&lt; E&gt;是一种特殊的数据类型，泛型，可用引用数据类型替换</p><h3 id="构造方法和添加方法"><a href="#构造方法和添加方法" class="headerlink" title="构造方法和添加方法"></a>构造方法和添加方法</h3><ul><li>public ArrayList()：创建一个空的集合对象</li><li>public boolean add(E e)：将指定的元素追加到此集合的末尾</li><li>public void add(int index,E element)：在此集合的指定位置插入指定的元素</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">创建ArrayList：</span><br><span class="line">    ArrayList&lt;数据类型&gt; 变量名=<span class="keyword">new</span> ArrayList&lt;数据类型&gt;();</span><br><span class="line">例如：ArrayList&lt;String&gt; array=<span class="keyword">new</span> ArrayList&lt;数据类型&gt;();</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public boolean remove(Object o)：删除指定的元素，返回删除是否成功</li><li>public E remove(int index)：删除指定索引处的元素，返回被删除的元素</li><li>public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素</li><li>public E get(int index)：返回指定索引处的元素</li><li>public int size()：返回集合中的元素的个数</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>string类在java.lang下，所以使用不需要导入包</p><p><strong>字符串的特点：</strong></p><ul><li>字符串不可变，值在创建后不能被更改</li><li>虽然String值不可变，但是可以被共享</li><li>字符串效果上相当于字符数组（char[]），但底层原理是字节数组（byte[]）【JDK8及以前是字符数组，JDK9及以后是字节数组】</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String（）</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public String（char[] chs）</td><td>根据字符数组的内容，创建字符串对象</td></tr><tr><td>public String（byte[] bys）</td><td>根据字节数组的内容，创建字符串对象</td></tr><tr><td>String s=“abc”；</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr></tbody></table><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>通过new创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址值不同</li><li>以“ ”方式给出的字符串，只要字符序列相同，无论在程序代码中出现几次，都只会创建一个String对象，并在字符串池中维护</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>使用==比较时：</p><ul><li>基本类型：比较的是数据值是否相同</li><li>引用类型：比较的是地址值是否相同</li></ul><p>字符串本身是对象，比较内容是否相同，需要通过方法实现：<strong>equals（）</strong></p><p>public boolean equals（Object anObeject）：将此字符串和指定对象进行比较，由于比较的是字符串对象，所以参数直接传递一个字符串</p><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>public char charAt(int index)：返回字符串指定索引处的char值</li><li>public int length()：返回字符串长度</li></ol><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder是一个可变的字符串类，在拼接字符串时不会新建一个String对象，避免浪费空间</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>public StringBuilder()：创建一个空白可变字符串对象，不含有任何内容</li><li>public StringBuilder(String str)：根据字符串的内容来创建可变字符串对象</li></ul><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>public StringBuilder append（任意类型）：添加数据，并返回对象本身【可链式编程】</li><li>public StringBuilder reverse()：返回相反的字符序列</li></ul><h3 id="和String的互相转换"><a href="#和String的互相转换" class="headerlink" title="和String的互相转换"></a>和String的互相转换</h3><ol><li><strong>StringBuilder转换为String</strong>：public String toString()</li><li><strong>String转换为StringBuilder</strong>：public StringBuilder(String s)</li></ol><h1 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h1><p>一种公共的规范标准，java中的接口更多体现在堆行为的抽象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口的定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;&#125;</span><br><span class="line">类实现接口：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>接口不能实例化——但可以通过实现类对象实例化</li><li>接口的实现类要么重写接口中所有抽象方法，要么还是抽象类</li></ul><div class="tip warning"><p></p><p>方法的形参和返回值是接口名时，实际需要和返回的是该接口的实现类对象</p><p></p></div><h2 id="接口的成员特点"><a href="#接口的成员特点" class="headerlink" title="接口的成员特点"></a>接口的成员特点</h2><ul><li><p>成员变量：</p><p>只能是常量</p><p>默认的修饰符为<strong>public static final</strong></p></li><li><p>构造方法：</p><p>接口没有构造方法，因为接口主要对行为进行抽象，没有具体存在</p><p><strong>一个类如果没有父类，默认继承自Object类</strong></p></li><li><p>成员方法：</p><p>只能是抽象方法</p><p>默认修饰符为<strong>public abstract</strong></p></li></ul><h2 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h2><p>类和接口可以是实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类名 <span class="title">implement</span> 接口1名,接口2名……</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口和接口可以是继承关系，可以单继承，也可以多继承</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 接口1名,接口2名……</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ul><li><p>成员区别</p><table><thead><tr><th></th><th>允许具有的成员</th></tr></thead><tbody><tr><td>抽象类</td><td>变量，常量，构造方法，抽象方法和非抽象方法</td></tr><tr><td>接口</td><td>常量，抽象方法</td></tr></tbody></table></li><li><p>关系区别</p><table><thead><tr><th></th><th>允许的关系</th></tr></thead><tbody><tr><td>类与类</td><td>继承，单继承</td></tr><tr><td>类与接口</td><td>实现，可以单实现也可以多实现</td></tr><tr><td>接口与接口</td><td>继承，单继承，多继承</td></tr></tbody></table></li><li><p>设计理念区别</p><table><thead><tr><th></th><th>设计理念</th></tr></thead><tbody><tr><td>抽象类</td><td>对类抽象，包括属性，行为</td></tr><tr><td>接口</td><td>对行为抽象，主要是行为</td></tr></tbody></table></li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类：在一个类中定义一个类，如在类A中定义一个类B，则类B是类A的内部类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问特点：</p><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建内部类的对象</li></ul><p>按照内部类在类中定义的位置不同，可以分为两种：</p><ul><li>在类的成员位置：成员内部类</li><li>在类的局部位置：局部内部类</li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">非私有时可用以下格式在类外创建内部类对象：</span><br><span class="line">    外部类名.内部类名 对象名=外部类对象.内部类对象;</span><br><span class="line">例如：</span><br><span class="line">    Outer.Inner oi=<span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">当内部类私有时，则在外部类中写入公开方法，在类内创建内部类对象：</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="comment">//此处省略内部类内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Inner i=<span class="keyword">new</span> Inner();</span><br><span class="line">            <span class="comment">//i即为创建的内部类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="comment">//此处省略内部类内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        Inner i=<span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="comment">//i即为创建的内部类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，局部内部类Inner定义在方法InnerMethod中，使用内部类时需要直接在方法中创建内部类对象并调用内部类的方法，如果只创建内部类无法调用内部类的成员方法</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类的前提：存在一个类或接口，可以是具体类或抽象类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">    <span class="keyword">new</span> 类名或接口名()&#123;</span><br><span class="line">    重写方法;</span><br><span class="line">&#125;;</span><br><span class="line">例如：</span><br><span class="line">    <span class="keyword">new</span> Inner()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//被重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名内部类本质上是一个继承了该类或实现了该接口的子类匿名对象,所以调用匿名内部类的方法时可以写作如下形式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InnerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        new Inner()&#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">            public void show()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;匿名内部类&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">        以上只创建了匿名内部类，没有调用方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        new Inner()&#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void show()</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;匿名内部类&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;.show();</span></span><br><span class="line"><span class="comment">        匿名内部类本质是一个匿名对象，所以直接可以通过对象调用方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Inner i=<span class="keyword">new</span> Inner()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        i.show();</span><br><span class="line">        <span class="comment">//这个匿名的对象本身继承了该类或实现了该接口，故而可以将其赋值给其父类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用匿名内部类可以简化操作，免去重新创建一个文件书写使用次数不多的类，而是将该类作为一个匿名内部类包含在同一个文件里，形如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a=<span class="keyword">new</span> A();<span class="comment">//A为B的接口操作类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bc();<span class="comment">//Bc为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bd();<span class="comment">//Bd为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Be();<span class="comment">//Be为B子类</span></span><br><span class="line">B b=<span class="keyword">new</span> Bf();<span class="comment">//Bf为B子类</span></span><br><span class="line"><span class="comment">//此处省略多个B的子类</span></span><br><span class="line">a.method(b);<span class="comment">//method方法的参数为B类对象</span></span><br><span class="line"><span class="comment">//以上需要创建A接口类，B类，Bc类，Bd类，Be类，Bf类……等B的子类，但这些B的子类使用次数不多，甚至是一次性时，就会造成这些子类本身没什么用，而文件数量又过多</span></span><br><span class="line"></span><br><span class="line">a.method(<span class="keyword">new</span> B()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//此处省略对B函数的重写</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用匿名内部类作为参数时，也实现了子类对父类函数的重写，虽然代码量差不多，但是免去了创建无用的子类文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java包与修饰符，接口与内部类概要</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="基础" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://zwiewings.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-2</title>
    <link href="https://zwiewings.github.io/2021/07/30/Java%E5%AD%A6%E4%B9%A0-2/"/>
    <id>https://zwiewings.github.io/2021/07/30/Java%E5%AD%A6%E4%B9%A0-2/</id>
    <published>2021-07-30T07:42:23.000Z</published>
    <updated>2021-08-13T14:51:41.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类的定义：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量的定义</span></span><br><span class="line">    <span class="comment">//成员方法的定义（没有static关键字）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//成员变量的定义</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="comment">//成员方法的定义（没有static关键字）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendPassage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">创建对象：类名 对象=<span class="keyword">new</span> 类名();</span><br><span class="line">例如：Phone p=<span class="keyword">new</span> Phone();</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>在c++中，不重载&lt;&lt;运算符时直接输出对象会报错，但java中可以直接输出对象，得到的是对象的地址，在编译器中实际输出应该为对象的包名.类名@对象的具体地址。</p><p></p></div><h2 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h2><table><thead><tr><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>类中位置不同</td><td>类中方法外</td><td>方法内或声明上</td></tr><tr><td>内存中位置不同</td><td>堆内存</td><td>栈内存</td></tr><tr><td>生命周期不同</td><td>随对象存在和消失</td><td>随方法调用存在和消失</td></tr><tr><td>初始化值不同</td><td>有默认初始值</td><td>没有默认的初始化值，必须先定义，赋值，才能够使用</td></tr></tbody></table><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>针对不想在类外直接访问的变量或方法，可以通过将public关键字替换为private（变量省略关键字时默认是public，需要在数据类型前面添加private关键字），体现类的封装。</p><p><strong>封装的好处：</strong></p><ul><li>通过方法来控制成员变量的操作，提高代码的安全性</li><li>把代码用方法进行封装，提高了代码的复用性</li></ul><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>java中的this关键字和c++的this指针是同一个作用，用于解决局部变量隐藏成员变量，书写格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.变量名</span><br><span class="line">例如：<span class="keyword">this</span>.name</span><br></pre></td></tr></table></figure><p>this修饰的变量用于指代成员变量：</p><ul><li>方法的形参如果和成员变量同名，不带this修饰的变量指的是形参而不是成员变量</li><li>方法的形参没有和成员变量同名，不带this修饰的变量指的是成员变量</li></ul><p><strong>this代表所在类的对象引用，方法被哪个对象引用，this就代表哪个对象</strong></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line"><span class="comment">//构造方法写在类内</span></span><br><span class="line">修饰符 类名（参数）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和c++一样，当代码给出了任意构造方法后，系统将不再自动提供默认的无参构造</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象三大特征之一，可以使子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名</span>&#123;&#125;</span><br><span class="line">如：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line">表示子类Student继承自父类Person</span><br></pre></td></tr></table></figure><ul><li>优点：提高代码的复用性，提高代码的维护性</li><li>弊端：让类和类产生了关系，父类改变时子类不得不改变</li></ul><p><strong>继承中变量的访问特点：</strong></p><p>在子类方法中访问一个变量：</p><ol><li>在子类局部范围找</li><li>在子类成员范围找</li><li>在父类成员范围找</li><li>否则报错（不考虑父类的父类的继承）</li></ol><p><strong>继承中构造方法的访问特点：</strong></p><p>子类中所有的构造方法默认都会访问父类中无参的构造方法，理由如下：</p><ul><li>子类会继承父类中的数据，可能还会使用父类的数据，所以要先初始化父类数据</li><li>每一个子类构造方法的第一条语句默认都是：super（）</li></ul><p>如果父类中没有无参构造方法，只有带参构造方法：</p><ul><li>通过使用super关键字去显示的调用父类的带参构造方法</li><li>在父类中自己提供一个无参构造方法（推荐）</li></ul><p><strong>继承中成员方法的访问特点：</strong></p><p>通过子类对象访问一个方法：</p><ul><li>子类成员范围找</li><li>父类成员范围找</li><li>否则报错（不考虑父类的父类的继承）</li></ul><h3 id="继承的注意事项"><a href="#继承的注意事项" class="headerlink" title="继承的注意事项"></a>继承的注意事项</h3><ul><li>java中类只支持单继承，不支持多继承</li><li>java中类支持多层继承，但变量和成员方法不考虑父类的父类</li></ul><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类中出现了和父类中一样的方法声明，但功能子类需要具有特有的内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类的特有内容</p><p>注意事项：</p><p>私有方法是不能被重写的（类似c++父类私有函数在子类不可见）</p><p>子类方法访问权限不能更低（public&gt;默认&gt;私有）</p><div class="tip warning"><p></p><p>@Override是一个方法重写的注解，可以帮助检查重写方法的方法声明的正确性</p><p></p></div><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>super关键字的用法和this关键字的用法相似</p><ul><li><strong>this：</strong>代表本类对象的引用</li><li><strong>super：</strong>代表父类存储空间的标识（可以理解为父类对象引用）</li></ul><table><thead><tr><th>关键字</th><th>访问成员变量</th><th>访问构造方法</th><th>访问成员方法</th></tr></thead><tbody><tr><td>this</td><td>this.成员变量，访问本类成员变量</td><td>this（…），访问本类构造方法</td><td>this.成员方法（…），访问本类成员方法</td></tr><tr><td>super</td><td>super.成员变量，访问父类成员变量</td><td>super（…），访问父类构造方法</td><td>super.成员方法，访问父类成员方法</td></tr></tbody></table><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态分为具体类多态，抽象类多态，接口多态</p><h3 id="多态的前提和实现"><a href="#多态的前提和实现" class="headerlink" title="多态的前提和实现"></a>多态的前提和实现</h3><ul><li>有继承/实现关系</li><li>有方法重写</li><li>有父（类/接口）引用指向（子/实现）类对象</li></ul><h3 id="成员的访问特点"><a href="#成员的访问特点" class="headerlink" title="成员的访问特点"></a>成员的访问特点</h3><p>成员变量使用父类成员变量，成员方法使用子类重写的父类成员方法，如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> Cat();</span><br></pre></td></tr></table></figure><p>对于Animal类中不存在，但Cat类中存在的成员变量是无法使用的，因为创建的变量a是Animal类；但在Cat类中重写了Animal类的成员方法后，使用该成员方法时，将会调用Cat类重写之后的成员方法。</p><p>两者存在区别的原因是由于成员方法有重写而成员变量没有重写，对于Animal类和Cat类继承下来的同一个方法入口构成了类似重载的关系</p><h3 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h3><p>好处：提高了程序的扩展性——定义方法的时候，使用父类作为参数，在使用的时候，可以使用具体的子类型传参</p><p>弊端：不能使用子类的特有功能</p><h3 id="多态中的转型"><a href="#多态中的转型" class="headerlink" title="多态中的转型"></a>多态中的转型</h3><ol><li>向上转型——Animal a=new Cat();<ul><li>从子到父</li><li>父类引用指向子类对象</li></ul></li><li>向下转型——Cat c=(Cat)a;<ul><li>从父到子</li><li>父类引用转为子类对象</li></ul></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>一个没有方法体的方法该定义为抽象方法，类中如果有抽象方法，该类必须定义为抽象类</p><p>java中抽象使用abstract关键字修饰：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">//含有抽象方法的类必须为抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//抽象方法必须位于抽象类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h3><ul><li>抽象类和抽象方法必须使用abstract修饰</li><li>抽象类中不一定有抽象方法，但有抽象方法的一定是抽象类</li><li>抽象类不能实例化，即不能创建对象，它只能通过子类对象实例化</li><li>抽象类的子类要么重写抽象类中所有抽象方法，要么是抽象类</li></ul><h3 id="抽象类的成员特点"><a href="#抽象类的成员特点" class="headerlink" title="抽象类的成员特点"></a>抽象类的成员特点</h3><ul><li>成员变量：可以是变量也可以是常量</li><li>构造方法：有构造方法，但不能实例化，构造方法用于子类访问父类数据的初始化</li><li>成员方法：可以有抽象方法，限定子类必须具有某些方法，也可以有非抽象方法，用于提高代码复用性</li></ul>]]></content>
    
    
    <summary type="html">Java类和对象基础</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="基础" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://zwiewings.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-5</title>
    <link href="https://zwiewings.github.io/2021/06/21/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-5/"/>
    <id>https://zwiewings.github.io/2021/06/21/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-5/</id>
    <published>2021-06-21T11:44:17.542Z</published>
    <updated>2021-06-21T12:36:39.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript是一种web页面中的脚本编程语言，不需要编译，而是直接嵌入到html页面中，完成动态网页的交互并响应事件，能够实现页面加载完成或单击某个元素时调用指定的JavaScript，或者是读取和改变当前页面某个元素的内容，在提交数据前进行数据的检测，亦或是检测访问者的浏览器，创建cookies等。</p><h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>JavaScript插入到html文档中有两种方法：</p><p>1.直接在html中插入行内javascript</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">/*插入的JavaScript语句*/</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在html中导入一个javascript文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js文件路径&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript中基本的数据类型有以下几种：</p><p>数值型：可以有小数点也可以没有</p><p>字符串型：用引号引起来的文本</p><p>null类型：表示未赋值的项，只有null一种取值，引用一个没有定义的变量将会返回null</p><p>undefined类型：用于确定一个已经创建但没有初值的变量</p><p>string对象的属性与方法的使用：参考c++类的对象获取对象属性和调用类的成员函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串对象名.字符串属性名；</span><br><span class="line">字符串对象名.字符串方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure><p>math对象的属性与方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">math.属性名</span><br><span class="line">math.方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于javascript脚本语言编写js文件</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="网页设计" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="javascript" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/javascript/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-10:关联式容器STL set</title>
    <link href="https://zwiewings.github.io/2021/06/04/c++%E5%AD%A6%E4%B9%A0-14/"/>
    <id>https://zwiewings.github.io/2021/06/04/c++%E5%AD%A6%E4%B9%A0-14/</id>
    <published>2021-06-04T12:39:34.000Z</published>
    <updated>2021-06-09T12:27:14.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>对于set容器来说，只能存储键与值相等的数据，无法实现如map容器那样的存储，并且set容器的数据并没有强制性的const修饰，但c++标准也对此做出了限制以免用户修改set容器中的数据，由于这些限制，在修改其元素时，应先删除该元素，再插入修改后的元素，以免破坏set容器的有序性</p><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 set 容器中存有元素的个数</td></tr><tr><td>max_size()</td><td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>insert()</td><td>向 set 容器中插入元素</td></tr><tr><td>erase()</td><td>删除 set 容器中存储的元素</td></tr><tr><td>swap()</td><td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同</td></tr><tr><td>clear()</td><td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(val)</td><td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1</td></tr></tbody></table><h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>set 容器配置的迭代器类型为双向迭代器。即若 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符</p><p>且set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器，成员函数如下：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td></tr></tbody></table><div class="tip warning"><p>注：以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.insert(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.begin(); iter != myset.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>1、myset size = 0<br>2、myset size = 3<br>a<br>b<br>c</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器set及其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-9:关联式容器STL multimap</title>
    <link href="https://zwiewings.github.io/2021/06/03/c++%E5%AD%A6%E4%B9%A0-13/"/>
    <id>https://zwiewings.github.io/2021/06/03/c++%E5%AD%A6%E4%B9%A0-13/</id>
    <published>2021-06-03T12:25:28.000Z</published>
    <updated>2021-06-04T12:42:07.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="multimap容器"><a href="#multimap容器" class="headerlink" title="multimap容器"></a>multimap容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对</p><p>同map一样，multimap定义时一样有四个参数值，键的类型，值的类型，排序规则，分配器对象的类型</p><p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p><ol><li>通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap;</span><br></pre></td></tr></table></figure><ol start="2"><li>当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">&quot;1a&quot;</span>,<span class="string">&quot;a1&quot;</span>&#125;,&#123;<span class="string">&quot;2b&quot;</span>,<span class="string">&quot;b2&quot;</span>&#125;,&#123;<span class="string">&quot;3c&quot;</span>,<span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>&#123;key, value&#125;</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p><p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(mymultimap);</span><br></pre></td></tr></table></figure><p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p><p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multimap&lt;string, string&gt; dismultimap() &#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;tempmultimap&#123; </span><br><span class="line">        &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(dismultimap());</span><br></pre></td></tr></table></figure><p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数</p><blockquote><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致</p></blockquote><ol start="4"><li>multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(++mymultimap.begin(), mymultimap.end());</span><br></pre></td></tr></table></figure><p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器</p><ol start="5"><li>前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>mymultimap 容器中键值对的存储顺序为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a,1&gt;</span><br><span class="line">&lt;b,2&gt;</span><br></pre></td></tr></table></figure><p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>,greater&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>其内部键值对的存储顺序为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b,2&gt;</span><br><span class="line">&lt;a,1&gt;</span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 multimap 容器中存有键值对的个数</td></tr><tr><td>max_size()</td><td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>insert()</td><td>向 multimap 容器中插入键值对</td></tr><tr><td>erase()</td><td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td>swap()</td><td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td></tr><tr><td>clear()</td><td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(key)</td><td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回</td></tr></tbody></table><p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个<br>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到</p><p>值得一提的是，对multimap容器提供的所有函数，map容器都提供，并且其用法相同，所以具体用法直接参见map容器的成员函数说明即可</p><p>点击链接跳转：<a href="https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/">https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</a></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.count(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.begin(); iter != mymultimap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>4<br>2<br>a 10<br>b 20<br>b 15<br>c 30</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器multimap及其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-8:关联式容器STL map</title>
    <link href="https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/"/>
    <id>https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</id>
    <published>2021-05-25T12:27:57.000Z</published>
    <updated>2021-06-03T12:54:07.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>map容器是关联式容器的一种，存储的全都是pair对象，即用pair类模板创建的键值对，其中各个键值对的键和值可以是任何数据类型，包括基本数据类型或结构体或自定义的类，通常来说，map容器中各个键值对都选用string字符串作为键的类型</p><p><strong>map容器会根据键的大小将元素按既定顺序排列</strong>，默认使用less&lt; T &gt;排序规则，会根据键的大小对所有键值作升序排序，但也可以手动指定或自定义这种排序规则</p><p><strong>对于map容器中的键值对来说，键的值不可以重复也不能修改</strong>，即每个键都是独一无二的对应一个元素，且类型使用const修饰</p><p>map容器定义在头文件&lt; map &gt;中，其容器模板有键类型、值类型、排序规则、分配器对象的类型，以上4个参数，其中后两者都有默认值，最后一个参数几乎不会用到</p><p>其中，已有可供修改的排序规则包括：greater&lt; T&gt;【降序】、less&lt; T &gt;【升序】</p><p>map容器常见创建方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line"><span class="comment">//创建空的map容器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; map2&#123;&#123;<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>&#125;,&#123;<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//创建map容器并初始化存入两个键值对</span></span><br><span class="line">map&lt;string,int&gt; map3(map1);</span><br><span class="line"><span class="comment">//复制创建map3</span></span><br><span class="line">map&lt;string,int&gt; map4()//将临时map对象传递给需要初始化的map容器</span><br><span class="line">&#123;</span><br><span class="line">map&lt;string,int&gt; map5(map2);</span><br><span class="line"><span class="keyword">return</span>  map4;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string,int&gt; map6(++map2.begin(),map2.end());</span><br><span class="line"><span class="comment">//取已建map容器中指定区域内的键值对，创建并初始化新的map容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回最后一个元素+1位置的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 map 容器中存有键值对的个数</td></tr><tr><td>max_size()</td><td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>operator[]</td><td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值</td></tr><tr><td>at(key)</td><td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常</td></tr><tr><td>insert()</td><td>向 map 容器中插入键值对</td></tr><tr><td>erase()</td><td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td>swap()</td><td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td></tr><tr><td>clear()</td><td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(key)</td><td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1</td></tr></tbody></table><br><br><h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>map 容器配备的是双向迭代器（bidirectional iterator），也就是map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td></tr></tbody></table><p>其中lower_bound(key)和upper_bound(key)更加多用于multimap容器，在map容器中很少用到</p><p>equal_range(key)可以看做是lower_bound(key)和upper_bound(key)的结合，返回一个pair对象，两个元素都是迭代器类型，其中pair.first是lower_bound(key)的返回值，pair.second是upper_bound(key)的返回值，其本身表示键值对中键的值都为key的一个范围</p><div class="tip warning"><p></p><p>由于map容器中键值对的键都是唯一的，所以调用equal_range(key)函数时，其范围内也最多只有一个键值对</p><p></p></div><h3 id="按键索值"><a href="#按键索值" class="headerlink" title="按键索值"></a>按键索值</h3><p>map类模板对[]运算符进行了重载，可以借助类似数组下标的方式直接访问数组中元素，通过指定的键可以得到其对应的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; map1&#123;<span class="number">1</span>,<span class="string">&quot;first&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;second&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;third&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> value=map1[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//此时value的值等于second</span></span><br></pre></td></tr></table></figure><p>当无法在已有map容器的元素中找到对应键时，会向map容器中添加一个符合要求的新键值对，其对应值默认为0</p><p>map容器也提供at()成员函数，通过输入键查找对应的值，但如果查找失败不会创建新键值对，而是抛出out_of_range异常</p><p>同样，使用find()函数也可以间接的实现这个功能，但返回的是一个迭代器，指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>同上，[]运算符在没有查找到对应键时会添加键值对，配合map容器本身的排序功能便可以实现插入</p><p>除此之外，insert()成员函数专门用于向map中插入键值对数据</p><div class="tip warning"><p></p><p>注：这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整</p><p></p></div><p>insert()既可以不指定插入位置，直接将键值对添加到map容器中，又可以向map容器的指定位置插入键值对</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不指定位置</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const value_type&amp;val);</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_interator position,<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator position,p&amp;&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入其他map容器中指定区域的所有键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="comment">//其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性插入多个键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，不指定位置时，val是键值对类型的变量，该方法会返回一个pair对象，pair.first代表迭代器，pair.second为bool型变量：</p><ul><li>如果成功插入val，返回的pair对象中的迭代器指向val，bool为true</li><li>如果插入失败，返回的pair对象中的迭代器指向和val的键相同的键值对p，bool为false</li></ul><p>指定位置时，val依旧是键值对类型变量，而insert()的返回值将会是迭代器而不再是pair对象：</p><ul><li>如果插入成功，insert()返回一个指向map容器中已插入键值对的迭代器</li><li>如果插入失败，insert()返回一个map容器中指向和val的键相同的键值对</li></ul><div class="tip warning"><p></p><p>以上除指定位置的差别外，语法格式区别在于传参方式不同，局部和全局变量都采用普通引用传参，对于临时的键值对变量则以右值引用方式传参</p><p>而即使指定位置，insert()插入之后map容器依旧会对自己进行排序，决定插入位置的不是insert()传入的迭代器，而是新键值对中的键的值</p><p></p></div><p>除了 insert() ，map 类模板还提供 emplace() 和 emplace_hint() ，它们也可以完成向 map 容器中插入键值对的操作，且效率还比 insert() 高</p><p>其中，emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li><li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li></ul><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ol><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ol><p><strong>和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置</strong></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>map容器删除数据的函数只有如下两个：</p><ul><li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li><li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li></ul><p>用法可参照前面的其他容器的用法，此处不详细说明</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">map的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名；</p><p>——创建空的map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名{以{“键”,”值”}的格式列举键值对}；</p><p>——创建map容器并初始化存入键值对</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一个容器名)；</p><p>——复制创建map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(函数参数表){函数体部分，需要返回一个map对象}</p><p>——将函数中的临时map对象传递给需要初始化的map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一容器的初始位置,另一容器的末位置)；</p><p>——取已建map容器中指定区域内的键值对，创建并初始化新的map容器</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li><li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li><li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li><li>只能进行 ++p、p++、–p、p–、*p 操作</li><li>只能使用 == 或者 != 运算符进行比较</li><li>lower_bound(key)——返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器</li><li>upper_bound(key) ——返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器</li><li>equal_range(key)——返回键值对可以看做是&lt;lower_bound(key),upper_bound(key) &gt;</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>以[]运算符访问已知键对应的值，如果查找失败则插入为新元素，值默认为0</li><li>使用at()函数访问，查找失败返回out_of_range错误</li><li>使用find()函数，返回一个迭代器指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>插入元素：</p><ul><li><p>不指定位置：</p><p>pair&lt;iterator,bool&gt; insert(const value_type&amp;val);<br>——引用传递一个键值对</p><p>template&lt; class p &gt;<br>pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p></li><li><p>指定位置</p><p>iterator insert(const_interator position,const value_type&amp;val);<br>——引用传递一个键值对</p><p>template&lt; class p &gt;<br>  iterator insert(const_iterator position,p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p></li><li><p>插入其他map容器中指定区域的所有键值对<br>template &lt; class InputIterator &gt;<br>  void insert (InputIterator first, InputIterator last);<br>——其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</p></li><li><p>——一次性插入多个键值对<br>void insert ({val1, val2, …});</p></li></ul><p>删除元素：</p><ul><li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li><li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.insert(STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-3&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>ret.iter = &lt;{2,2-2}, 1&gt;<br>ret.iter = &lt;{1,1-2}, 1&gt;<br>ret.iter = &lt;{2,2-2}, 0&gt;</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.insert(it, STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2-3&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>2 2-2<br>1 1-2<br>2 2-2</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap&#123; &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3-2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++mymap.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = mymap.end();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.insert(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.begin(); iter != copymap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>3 3-2<br>2 2-2</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器中STL map和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-7:关联式容器STL pair</title>
    <link href="https://zwiewings.github.io/2021/05/21/c++%E5%AD%A6%E4%B9%A0-11/"/>
    <id>https://zwiewings.github.io/2021/05/21/c++%E5%AD%A6%E4%B9%A0-11/</id>
    <published>2021-05-21T11:46:27.000Z</published>
    <updated>2021-05-31T12:19:50.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pair类模板"><a href="#pair类模板" class="headerlink" title="pair类模板"></a>pair类模板</h1><h2 id="键值对数据类型"><a href="#键值对数据类型" class="headerlink" title="键值对数据类型"></a>键值对数据类型</h2><p>关联式容器存储的是”键值对“形式的数据，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&quot;a&quot;,&quot;121&quot;&gt;</span><br><span class="line">&lt;&quot;b&quot;,&quot;144&quot;&gt;</span><br><span class="line">&lt;&quot;c&quot;,&quot;156&quot;&gt;</span><br></pre></td></tr></table></figure><p>以上每行都表示一个键值对，其中第一个元素作为键，第二个元素作为值，由于键值对不是普通数据类型，c++STL标准库提供了pair类模板，用于将两个普通元素a和b，创建成一个新元素&lt;a,b&gt;</p><h2 id="pair对象构造"><a href="#pair对象构造" class="headerlink" title="pair对象构造"></a>pair对象构造</h2><p>pair类模板定义在&lt; utility &gt;头文件中，所以在使用该类模板之前，需要引入该头文件，且pair类模板提供了共五种构造函数，如下：</p><ul><li>默认构造函数，即创建空的 pair 对象：pair();</li><li>直接使用 2 个元素初始化成 pair 对象：pair (const first_type&amp; a, const second_type&amp; b);</li><li>拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象：template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</li><li>移动构造函数：template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</li><li>使用右值引用参数，创建 pair 对象：template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</li></ul><h3 id="关于右值引用"><a href="#关于右值引用" class="headerlink" title="关于右值引用"></a>关于右值引用</h3><p>注：对于右值引用，能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式为“右值”，一般来说，左值可以取地址，右值不可以。非const变量都是左值，函数调用的返回值若不是引用，则该函数调用就是右值，在不专门指出时，引用基本都是引用变量的，即左值引用。c++11中新增了一种右值引用，可以引用无名的临时变量，使用符号为“&amp;&amp;”</p><p>引入右值引用的主要目的是提高程序运行的效率。有些对象是无名临时变量，但在复制时却需要进行深复制，往往非常耗时。合理使用右值引用可以避免没有必要的深复制操作</p><h2 id="赋值和比较"><a href="#赋值和比较" class="headerlink" title="赋值和比较"></a>赋值和比较</h2><p>pair对象是允许手动赋值的，可用.first和.second分别访问pair对象的键和值，同样，也可以使用make_pair()函数，向其中传入两个参数代表对象的键和值</p><p>&lt; utility &gt;头文件中，除了提供创建pair对象的方法之外，还为pair对象重载了以下6种运算符：&lt;、&lt;=、&gt;、&gt;=、==、!=，其运算规则是先比较键的大小，如果键的大小相等，再比较值的大小，且对于比较的两个pair对象，其对应的键和值的类型应该相同，否则编译器将找不到合适的重载运算符</p><p>除此之外，当键和值的类型都相同时，可以使用swap()成员函数交换两个pair对象的的键值对，同其他容器中的swap()效果相同</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair2(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4(<span class="built_in">make_pair</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair5(<span class="built_in">string</span>(<span class="string">&quot;3&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;7&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair1: 0<br>pair2: 1 9<br>pair3: 1 9<br>pair4: 2 8<br>pair5: 3 7</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;1&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3(<span class="string">&quot;2&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair != pair2<br>pair2 != pair3</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.swap(pair2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair1: pair2 20<br>pair2: pair 10</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器中STL pair和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-7:序列式容器STL list</title>
    <link href="https://zwiewings.github.io/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/"/>
    <id>https://zwiewings.github.io/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/</id>
    <published>2021-05-20T11:50:22.000Z</published>
    <updated>2021-06-04T12:53:32.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>list容器，又称双向链表容器，底层实现为双向链表形式，元素可分散存储在内存空间中，前后顺序靠指针维系，每个元素都配备指向前驱和后继的两个指针，第一个元素前驱为NULL，最后一个元素后继为NULL</p><p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/1.jpg" alt="1"></p><p>list容器可以在序列已知的任何位置快速插入和删除元素，并且在list容器中移动元素的效率也比其他容器高，但它不能直接通过位置访问元素，而是需要顺序遍历前面的所有元素直到找到该位置</p><p>所以当需要对序列大量添加、删除元素，却不常直接访问元素数据时，list容器最为高效适用，其创建如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;<span class="comment">//创建空list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建包含10个元素的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建包含10个元素且初值为5的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value3</span><span class="params">(value1)</span></span>;<span class="comment">//拷贝创建一个和value1一样的list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;<span class="comment">//拷贝普通数组创建list 容器</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt;arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values(arr.begin()+<span class="number">2</span>, arr.end());<span class="comment">//拷贝其它容器，创建list 容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素，该函数和 push_front() 的功能相同，但效率更高</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素，该函数和 push_back() 的功能相同，但效率更高</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素，该函数和 insert() 功能相同，但效率更高</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的</td></tr><tr><td>resize()</td><td>调整容器的大小</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序</td></tr></tbody></table><h2 id="list容器迭代器"><a href="#list容器迭代器" class="headerlink" title="list容器迭代器"></a>list容器迭代器</h2><p>list容器的迭代器相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p><p><strong>但list容器配备的迭代器类型为双向迭代器，不再是之前的随机访问迭代器</strong></p><p>这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1–、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：</p><ul><li>p1[i]：不能通过下标访问 list 容器中指定位置处的元素</li><li>双向迭代器不支持使用 -=、+=、+、- 运算符</li><li>双向迭代器不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li></ul><div class="tip warning"><p></p><p>list容器在插入insert（）、接合splice（）等操作时不会造成原有list迭代器失效，删除操作时也仅有指向被删除元素的迭代器失效，其他迭代器不受影响</p><p></p></div><h2 id="访问list容器"><a href="#访问list容器" class="headerlink" title="访问list容器"></a>访问list容器</h2><p>由于list容器不支持随机访问，未提供下标操作符[ ]和at（）成员函数，也没有data（）成员函数，只能使用front（）成员函数和back（）成员函数，用于返回list容器中第一个元素和最后一个元素的引用</p><p>如果想要访问list容器存储的其他元素，只能使用list容器的迭代器，例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于修改容器中指定元素的值，list模板类提供专门的成员函数assign（）：</p><ul><li>assign(count, value) ：其中count是值的个数，value是分配给元素的值</li><li>assign(begin，end)：其中begin为起始位置，end为结束位置，常作将元素从已有列表复制过来，并覆盖该列表原来的元素值</li></ul><p>除此之外，assign（）函数还可以实现不同容器之间，相容类型的赋值或者是对不能使用赋值符“=”进行赋值的数据类型赋值</p><h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>list容器中，通用的增添元素方法依旧适用，如：</p><ul><li>push_front()：向 list 容器首个元素前添加新元素</li><li>push_back()：向 list 容器最后一个元素后添加新元素</li><li>emplace_front()：在容器首个元素前直接生成新的元素</li><li>emplace_back()：在容器最后一个元素后直接生成新的元素</li><li>emplace()：在容器的指定位置直接生成新的元素</li><li>insert()：在指定位置插入新元素</li></ul><p>而除deque等容器增删元素的方法外，list容器还有一个成员函数splice（），用于将其他list容器存储的多个元素添加到当前list容器的指定位置</p><table><thead><tr><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>void splice (iterator position, list&amp; x);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator i);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td></tr></tbody></table><div class="tip warning"><p></p><p>splice() 成员方法移动元素的方式，是将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中，也就是当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除，实现的过程相当于是“剪切”而不是“复制”</p><p></p></div><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>list容器中，通用的删除元素方法依旧适用，如：</p><ul><li>pop_front()    删除位于 list 容器头部的一个元素</li><li>pop_back()    删除位于 list 容器尾部的一个元素</li><li>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</li><li>clear()    删除 list 容器存储的所有元素</li></ul><p>而list容器中新增的方法成员函数有：</p><ul><li>remove(val)    删除容器中所有等于 val 的元素</li><li>remove_if()    删除容器中满足条件的元素</li><li>unique()    删除容器中相邻的重复元素，只保留一份</li></ul><p>其中unique（）可以直接无参使用，也可以自定义传入一个二元谓词函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span><span class="comment">//二元谓词函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(first) == <span class="keyword">int</span>(second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">4.6</span> &#125;;</span><br><span class="line">    <span class="comment">//删除相邻重复的元素，仅保留一份</span></span><br><span class="line">    mylist.unique();<span class="comment">//&#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//demo 为二元谓词函数，是自定义的去重规则</span></span><br><span class="line">    mylist.unique(demo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>1 1.2 3 4 4.5 4.61 3 4</p></div><div class="tip warning"><p></p><p>谓词函数是一个判断式，一个返回bool值的函数或者仿函数。几元就是函数有几个参数，至于定义和使用，函数定义和一般的函数定义一样，仿函数就是写个类，然后重载operator()。可以在需要返回bool值的函数作参数的函数里使用。</p><p></p></div><p>此外，将自定义的谓词函数传给remove_if()成员函数，list容器中能使函数成立的元素都会被删除：</p><p>remove_if(begin,end,op)：其中begin是起始位置，end为结束位置，op为传入的回调函数，如果返回true，则将当前指向的参数移到尾部（故而需要和erase一起使用才能真正删除元素），其返回值为被移动区域的首个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">15</span>, <span class="number">36</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 mylist 容器中能够使表达式成立的所有元素</span></span><br><span class="line">    mylist.remove_if([](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> (value &lt; <span class="number">10</span>); &#125;); <span class="comment">//&#123;15 36 17 20 39&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>15 36 17 20 39</p></div><div class="tip warning"><p></p><p>回调函数就是一个被作为参数传递的函数。上述代码中，mylist.remove_if( [ ] (int value) {return (value &lt; 10); });相当于前两个参数默认使用了mylist的begin和end位置，回调函数的参数是int类型的value，当value&lt;10时，回调函数将返回这个表达式的值（false/true）</p><p></p></div><h2 id="更加高效的list——forward-list"><a href="#更加高效的list——forward-list" class="headerlink" title="更加高效的list——forward_list"></a>更加高效的list——forward_list</h2><p>forward_list是c++11标准新添加的一类容器，底层实现和list一样采用链表，但采用的是单链表（相邻元素间只有从前驱指向后驱的指针），list采用的是双链表（相邻元素间有从前向后的指针，也有从后向前的指针）</p><p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/2.gif" alt="2"></p><p>相较list，forward_list同样擅长在序列的任何位置进行插入或删除，而不擅长随机访问元素，而且由于指针从前驱指向后驱，所以配备的迭代器也只有前向迭代器，而不是双向迭代器</p><p>使用forward_list的意义主要是效率高，且在存储相同个数元素时单链表所用空间更少，空间利用率更高，对于某些操作的执行效率也更高，故当list和forward_list都能完成时，应该首选forward_list容器</p><p>以下为forward_list的成员函数：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>before_begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td></tr><tr><td>begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td></tr><tr><td>end()</td><td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td></tr><tr><td>insert_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>erase_after()</td><td>删除容器中某个指定位置或区域内的所有元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice_after()</td><td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序</td></tr></tbody></table><p>如上，forward_list容器迭代器的移动除了使用++运算符单步移动之外，还能使用advance()函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.begin();</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，在forward_list容器中是没有提供size（）函数的，想要获取forward_list容器中的存储元素的个数，可以使用头文件&lt; iterator &gt;中的distance（）函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = distance(begin(my_words),end(my_words));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">list的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li>list&lt;数据类型&gt; 容器名：创建空list容器</li><li>list&lt;数据类型&gt; 容器名(n, a)：创建包含n个元素，初值为a的容器（a可省略）</li><li>list&lt;数据类型&gt; 容器名(另一个容器名)：拷贝另一个容器创建list</li><li>list&lt;数据类型&gt; 容器名(begin迭代器, end迭代器)：拷贝区间内元素创建list</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li><li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li><li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li><li>不能通过下标访问 list 容器中指定位置处的元素</li><li>不支持使用 -=、+=、+、- 运算符</li><li>不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>front（）和back（）函数——返回容器中第一个和最后一个元素的引用</li><li>因为存储空间不连续不能使用指针，而只能使用list的迭代器访问</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>添加元素：</p><ul><li>push_front()：向 list 容器首个元素前添加新元素</li><li>push_back()：向 list 容器最后一个元素后添加新元素</li><li>emplace_front()：在容器首个元素前直接生成新的元素</li><li>emplace_back()：在容器最后一个元素后直接生成新的元素</li><li>emplace()：在容器的指定位置直接生成新的元素</li><li>insert()：在指定位置插入新元素</li><li>splice()：将其他 list 容器存储的多个元素剪切到当前 list 容器的指定位置处</li></ul><p>删除元素：</p><ul><li><p>pop_front()    删除位于 list 容器头部的一个元素</p></li><li><p>pop_back()    删除位于 list 容器尾部的一个元素</p></li><li><p>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</p></li><li><p>clear()    删除 list 容器存储的所有元素</p></li><li><p>remove(val)    删除容器中所有等于 val 的元素</p></li><li><p>remove_if()    删除容器中满足条件的元素</p></li><li><p>unique()    删除容器中相邻的重复元素，只保留一份，可以直接无参使用，也可以自定义传入一个二元谓词函数</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.push_back(<span class="number">3.1</span>);</span><br><span class="line">    values.push_back(<span class="number">2.2</span>);</span><br><span class="line">    values.push_back(<span class="number">2.9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.sort();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>values size：3<br>2.2 2.9 3.1</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//使用begin()/end()迭代器函数对输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::reverse_iterator it = values.rbegin(); it != values.rend();++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p><a href="http://c.biancheng.net/">http://c.biancheng.net</a><br>ten.gnehcnaib.c//:ptth</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 2 个 list 容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ++mylist1.begin(); <span class="comment">//指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    mylist1.splice(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(), mylist1.end());<span class="comment">//mylist1:</span></span><br><span class="line">                                                                             <span class="comment">//mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mylist2 容器中存储的数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.begin(); iter != mylist2.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>mylist1 包含 0个元素<br>mylist2 包含 7个元素<br>mylist2:1 10 20 30 3 4 2</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL list和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UE4-溶解特效</title>
    <link href="https://zwiewings.github.io/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/"/>
    <id>https://zwiewings.github.io/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/</id>
    <published>2021-05-20T11:24:16.000Z</published>
    <updated>2021-06-02T00:30:04.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="溶解特效制作"><a href="#溶解特效制作" class="headerlink" title="溶解特效制作"></a>溶解特效制作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文中可以学到4个之前暂时跳过的全新知识点</p><ul><li>材质参数集资产<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/1.png" alt="1"></li><li>材质中的”已遮罩”混合模式<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/2.png" alt="2"></li><li>材质中的if节点以及过场动画中的”材质参数轨道”<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/3.png" alt="3"> </li></ul><p>总之都是干货啦，开始吧~</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>首先，先准备好溶解特效的蒙版贴图</p><div class="snote download yellow"><a href="https://docs.unrealengine.com/Images/AnimatingObjects/Sequencer/HowTo/TracksMaterialParameter/T_Dissolve.png">点此获取样例蒙版贴图</a></div><p>将贴图导入后，新建一个材质参数集资产并起名为”溶解参数集”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/4.png" alt="4"></p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/5.png" alt="5"></p><p>打开参数集，添加一个标量参数，起名为“Alpha”，意为不透明度，1为正常，0为完全溶解消失。<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/6.png" alt="6"></p><div class="tip warning"><p></p><p>材质参数集的作用就是可以在游戏运行时改变材质中的一些数值，可以产生材质的动态变化。</p><p></p></div><p>随后打开要被做成溶解特效的材质，以金币材质为例,</p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/7.png" alt="7" style="zoom:50%;"><p>看上去相当复杂，但不用管，只需稍加改造即可。</p><p>首先去细节面板，将混合模式改为“已遮罩”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/8.png" alt="8"></p><table><thead><tr><th align="center">混合模式</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">不透明</td><td align="center">普通不透明的材质</td></tr><tr><td align="center">已遮罩</td><td align="center">相当于材质只覆盖了表面的一层，可以修改局部的不透明度</td></tr><tr><td align="center">半透明</td><td align="center">常用于玻璃水面等材质，可以有折射特效，但只能对整体进行不透明度的修改</td></tr></tbody></table><p>然后将“溶解参数集”拖入，参数名选择Alpha</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/10.png" alt="10"></p><p>将贴图拖入，并建一个if节点，按如下摆放并与“不透明蒙版”相连</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/9.png" alt="9"></p><div class="tip warning"><p></p><p>解释：贴图是一张黑白图，黑白图的RGB为同一个数，而不透明蒙版中输入0为全透明，1为完全不透明，因此可在运行时调整Alpha（从0到1），使贴图蒙版中红色（因是黑白图，所以取哪个都是一样，因为要浮点与浮点才能比较，所以只能取其中一个值，而不能取RGB，因为RGB是向量Vector类型的变量）大于等于那个值的部分显示（蒙版输入1）小于那个值的部分消失（蒙版输入0）。TexCoord之前有提过，按T加左键，用于缩放贴图的密度，UV数字越大密度越高，案例中将U和V都设置成了4。</p><p></p></div><p>if节点的作用：</p><table><thead><tr><th align="center">输入</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">输入一个浮点值</td></tr><tr><td align="center">B</td><td align="center">输入一个浮点值</td></tr><tr><td align="center">A&gt;B</td><td align="center">A&gt;B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr><tr><td align="center">A==B</td><td align="center">A=B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr><tr><td align="center">A&lt;B</td><td align="center">A&lt;B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr></tbody></table><p>到此就建立完毕了，所有套用了这个材质或者所有以这个材质为父类建立的材质实例的物体都会应用溶解的效果</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="过场动画中的使用"><a href="#过场动画中的使用" class="headerlink" title="过场动画中的使用"></a>过场动画中的使用</h3><p>建立一个过场动画，添加一条材质参数集轨道，选择之前建立的“溶解参数集”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/11.png" alt="11"></p><p>随后添加一个Alpha轨道</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/12.png" alt="12"></p><p>添加一些关键帧（如图分别为0，1，0）</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/13.png" alt="13"></p><p>拖动时间轴可以看到物体溶解然后复原</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/14.png" alt="14"></p><h3 id="蓝图中的使用"><a href="#蓝图中的使用" class="headerlink" title="蓝图中的使用"></a>蓝图中的使用</h3><p>在蓝图中调用这个节点“设置标量参数值”，Collection输入创建的参数集，Parameter Name输入要改变的参数，Parameter Value输入值</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/15.png" alt="15"></p>]]></content>
    
    
    <summary type="html">通过溶解特效的制作学习有关材质参数集资产以及其他相关知识点</summary>
    
    
    
    <category term="课外拓展" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/UE4/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-7</title>
    <link href="https://zwiewings.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/"/>
    <id>https://zwiewings.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/</id>
    <published>2021-05-19T12:06:19.000Z</published>
    <updated>2021-06-09T12:47:46.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图（多对多关系）"><a href="#图（多对多关系）" class="headerlink" title="图（多对多关系）"></a>图（多对多关系）</h1><h2 id="定义及名词解释"><a href="#定义及名词解释" class="headerlink" title="定义及名词解释"></a>定义及名词解释</h2><ul><li><strong>图：</strong>顶点的有穷非空集合和边的集合，常用G表示一个图，V表示顶点集合，E是边的集合，其中图至少有一个顶点，且顶点数量为有限个，边的集合可以为空</li><li><strong>有向图和无向图：</strong>图按有无方向可以分为无向图和有向图，无向图称顶点和边，有向图中称顶点和弧，箭头指向的一方为弧头</li><li><strong>稀疏图和稠密图：</strong>图按边和弧的多少分稀疏图和稠密图</li><li><strong>完全图和简单图：</strong>任意两个顶点间都存在边叫完全图，无重复边或顶点到自身的边叫简单图</li><li><strong>度、出度、入度：</strong>图中顶点有邻接点、依附的概念，无向图顶点边数叫度，有向图顶点分出度和入度</li><li><strong>网：</strong>当图的边或弧带有权值，则称其为网</li><li><strong>环/回路和简单路径：</strong>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复的叫简单路径</li><li><strong>连通图：</strong>若任意两顶点都是连通的，则图就是连通图，有向图称为强连通图</li><li><strong>连通分量：</strong>图中有子图，若子图达到极大连通则就是连通分量，有向图中称为强连通分量</li><li><strong>生成森林和有向树：</strong>无向图中连通且n个顶点n-1条边称为生成树，有向图中一顶点入度为0其余顶点入度为1的叫有向树，一个有向图由若干棵有向树构成生成森林</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>可表示为一个二维数组，如图所示</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/1.jpg" alt="1"></p><ol><li><p>当图为无向图时，默认为双向，即整个矩阵沿对角线对称</p></li><li><p>当图为有向图时，由a指向b的边将在矩阵中以array【a】【b】=1的方式表示</p></li><li><p>当图不带权值时，1表示两点连通，0表示不连通</p></li><li><p>当图带权值时，连通时矩阵中的值为两点间的权值，点和它自己标为0，不连通的两点标为无穷</p></li></ol><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>以一维数组存储顶点值，并各自作为头结点，连接其邻接元素的链表，如图所示</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/2.jpg" alt="2"></p><p>其中链表结点的顺序是不固定的，不一定要按顺序排列，而链表部分中，结点的adjvex区域存储的是头结点元素的邻接元素的下标，而不是具体元素的值</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/3.jpg" alt="3"></p><p>十字链表是有向图的链式存储，结合了有向图的邻接表和逆邻接表</p><p>一维数组存储了顶点的值，并作为后续链表的头结点，出弧指针域指向邻接元素（如上图的v0的出弧指针域指向存有弧尾0，弧头1的结点），而入弧指针域指向有弧指向头结点的元素（如上图中的v0的入弧指针域指向存有弧尾2，弧头0的结点）</p><p>在非头结点的结点内部，存有弧头和弧尾元素的下标，以及指向弧头相同的其他结点和弧尾相同的其他结点的指针</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/4.gif" alt="4"></p><p>邻接多重表是针对无向图和无向网的，可看作是邻接表和十字链表的结合</p><p>以一维数组存储了顶点的值，并作为后续链表的头结点，非头结点的结点中包括用于标记是否被操作过的标志域(mark)，存储图中边两端的顶点下标的数据域（ivex和jvex，顺序不分），以及指向同一个ivex和同一个jvex的其他结点的指针域（ilink和jlink，顺序不分），除此之外，有时还多设一个用于存储边的权值的数据域</p><p>由于邻接多重表的空间利用率过低，最好还是使用邻接表和邻接矩阵</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历类似于树的先序遍历，大致思路以下图为例</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/5.png" alt="5"></p><ol><li>任意取一个未被遍历过的顶点（如v1），标记为已访问</li><li>遍历v1的邻接点（如v2），并标记为已访问，逐步向下，遍历v2的邻接点，即v4，然后访问v8，再访问v5，都标记为已访问</li><li>当遍历v5的邻接点时，v2和v8都已经被标记为已访问，故而回退到v8，同理回退到v4，v2，最后到v1</li><li>在v1处找到未访问的顶点v3，故而停止回退，继续遍历v3的邻接点v6，然后v7</li><li>遍历v7的邻接点都已经被访问，于是回退到v6，v3，最后回到v1</li><li>判断是否所有顶点都被访问，如果还有未被访问的，继续按照以上方法访问，否则结束遍历</li></ol><p><strong>深度优先遍历总的来说是个不断回溯的过程</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//标记为true</span></span><br><span class="line">    visitVex( G,  v); <span class="comment">//访问第v 个顶点</span></span><br><span class="line">    <span class="comment">//从该顶点的第一个边开始，一直到最后一个边，对处于边另一端的顶点调用DFS函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstAdjVex(G,v); w&gt;=<span class="number">0</span>; w = NextAdjVex(G,v,w))&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位false，证明未被访问，调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位为false，则调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            DFS( G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    DFSTraverse(G);<span class="comment">//深度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历类似于树的层次遍历，即从某一个顶点开始，遍历其所有邻接点，然后再顺序遍历这些邻接点的所有邻接点，直到所有邻接的顶点被访问后，判断图中是否还有未被访问的结点，若有则重复以上过程</p><p>广度优先遍历的实现借助了队列的结构，实现代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作顶点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue ** Q)</span></span>&#123;</span><br><span class="line">    (*Q)=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    (*Q)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点元素v进队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Queue **Q,VertexType v)</span></span>&#123;</span><br><span class="line">    Queue * element=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    element-&gt;data=v;</span><br><span class="line">    Queue * temp=(*Q);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头元素出队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue **Q,<span class="keyword">int</span> *u)</span></span>&#123;</span><br><span class="line">    (*u)=(*Q)-&gt;next-&gt;data;</span><br><span class="line">    (*Q)-&gt;next=(*Q)-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue *Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    Queue * Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            visited[v]=<span class="literal">true</span>;</span><br><span class="line">            visitVex(G, v);</span><br><span class="line">            EnQueue(&amp;Q, G.vexs[v]);</span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">                <span class="keyword">int</span> u;</span><br><span class="line">                DeQueue(&amp;Q, &amp;u);</span><br><span class="line">                u=LocateVex(&amp;G, u);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w=FirstAdjVex(G, u); w&gt;=<span class="number">0</span>; w=NextAdjVex(G, u, w)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                        visited[w]=<span class="literal">true</span>;</span><br><span class="line">                        visitVex(G, w);</span><br><span class="line">                        EnQueue(&amp;Q, G.vexs[w]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    BFSTraverse(G);<span class="comment">//广度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h3><p>普里姆算法（Prim算法）或称DJP算法，可在加权连通图里搜索最小生成树。由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.png" alt="6"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.jpg" alt="6"></p><h3 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h3><p>克鲁斯卡尔算法从边的角度求网的最小生成树，和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树</p><p>对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择</p><p>由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点：</p><ul><li>生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路</li><li>对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点</li></ul><p><strong>连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边</strong></p><p>所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。</p><div class="tip warning"><p></p><p>判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。</p><p></p></div><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/7.png" alt="7"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/8.png" alt="8"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/9.png" alt="9"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/10.png" alt="10"></p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>操作步骤</strong></p><ol><li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]</li><li>从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k</li><li>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离</li><li>重复步骤(2)和(3)，直到遍历完所有顶点</li></ol><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/11.jpg" alt="11"></p><h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法是一种在具有正或负边缘权重（但没有负环）的加权图中找到最短路径的算法，即支持负权值但不支持负权环。</p><p>相较而言，迪杰斯特拉计算的是单源最短路径，而弗洛伊德计算的是多源最短路径，其时间复杂度为O(n³)。虽然它不返回路径本身的细节，但是可以通过对算法的简单修改来重建路径，我们利用这个思想，通过递归的方式访问每条路径经过的中间节点，对最终的路径进行输出。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/12.jpg" alt="12"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对一个<strong>有向无环图</strong>进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。<br>在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列，由AOV网构造拓扑序列的过程叫做拓扑排序。<strong>AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。</strong></p><p>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止：</p><ol><li>选择一个入度为0的顶点并输出</li><li>从网中删除此顶点及所有出边</li></ol><p>循环结束后，若输出的顶点数小于网中的顶点数，则有回路，否则输出的顶点序列就是一种拓扑序列。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/13.jpg" alt="13"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>在AOE网中，从始点到终点具有最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径，通过优化关键路径能够实现有效的程序优化，<strong>同拓扑排序一样，关键路径也不是唯一的</strong>。</p><p>由于AOE网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/14.jpg" alt="14"></p><p>如图，由v1到v9即一条关键路径，其关键路径长度为29，当其他路线中边的权值相加相等时，图中也可能出现多条关键路径</p>]]></content>
    
    
    <summary type="html">关于图的概念及其四种算法同拓扑排序和关键路径</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-6:序列式容器STL deque</title>
    <link href="https://zwiewings.github.io/2021/05/19/c++%E5%AD%A6%E4%B9%A0-9/"/>
    <id>https://zwiewings.github.io/2021/05/19/c++%E5%AD%A6%E4%B9%A0-9/</id>
    <published>2021-05-19T08:08:50.000Z</published>
    <updated>2021-05-31T12:18:24.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>deque容器即双端队列容器，擅长在序列头部和尾部添加或删除元素，不擅长在序列中间添加或删除元素，且deque容器可以根据需要修改自身容量大小，但deque容器存储时，并不能保证所有元素都存储到连续的内存空间中</p><p>当需要向序列两端频繁添加或删除元素时，应该首选deque容器，同样需要引用同名头文件&lt; deque &gt;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;<span class="comment">//创建一个空deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建具有10个元素的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">2</span>)</span></span>;<span class="comment">//创建具有10个元素，且初值为2的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;<span class="comment">//以d2为模板拷贝构造一个deque容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a,a+<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//拷贝构造一个装有其他类型容器中指定区域的元素的deque容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>size()</td><td>返回实际元素个数</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，我们很少会用到这个函数</td></tr><tr><td>resize()</td><td>改变实际元素的个数</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>assign()</td><td>用新元素替换原有内容</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素</td></tr><tr><td>erase()</td><td>移除一个元素或一段元素</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程</td></tr></tbody></table><div class="tip warning"><p></p><p>和vector容器相比，额外增加了在容器头部添加和删除元素的成员函数，并删除了capacity()、reserve()和data()成员函数</p><p></p></div><h2 id="deque容器迭代器"><a href="#deque容器迭代器" class="headerlink" title="deque容器迭代器"></a>deque容器迭代器</h2><p>deque容器的迭代器类型是随机访问迭代器，相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p><div class="note danger flat"><p>迭代器的功能是遍历容器，在遍历的同时可以访问甚至修改容器中元素，但迭代器不能用来初始化空的deque容器（这一点和vector是一样的），故而如下代码错误：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    *first = <span class="number">1</span>;<span class="comment">//该处错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>对于空的deque容器，可以通过push_back()、push_front()、resize()成员函数实现添加元素</p></div><p>此外，向deque容器添加元素时，deque容器会申请更多的内存空间，其包含的所有元素可能会被复制或移动到新的内存地址，导致之前创建的迭代器失效（这点和vector容器也是一样的）</p><h2 id="访问deque容器"><a href="#访问deque容器" class="headerlink" title="访问deque容器"></a>访问deque容器</h2><ol><li>容器名[n]——可能越界【通用】</li><li>at（）函数访问——性能较前者会有所损耗，但较安全【通用】</li><li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li></ol><div class="tip warning"><p></p><p>注：deque容器没有提供data（）函数，同时deque容器存储时不保证存储在连续空间中，故而应该尽可能避免用指针去访问deque容器中指定位置处的元素</p><p></p></div><h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><p>deque提供增删元素的成员函数如下：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部</td></tr><tr><td>pop_back()</td><td>移除容器尾部的一个元素</td></tr><tr><td>push_front()</td><td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部</td></tr><tr><td>pop_front()</td><td>移除容器尾部的一个元素</td></tr><tr><td>emplace_back()</td><td>C++11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td></tr><tr><td>emplace_front()</td><td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td></tr><tr><td>insert()</td><td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置</td></tr><tr><td>emplace()</td><td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程</td></tr><tr><td>erase()</td><td>移除一个元素或某一区域内的多个元素</td></tr><tr><td>clear()</td><td>删除容器中所有的元素</td></tr></tbody></table><p><strong>在实际应用中，常用emplace()、emplace_front()和emplace_back()分别替代函数insert()、push_front()和push_back()</strong></p><p>其中insert()可以有四种语法格式：insert（pos，elem）、insert（pos，n，elem）、insert（pos，first，last）以及insert（pos initlist），具体使用参见vector容器篇的说明</p><p><strong>emplace系列函数参数说明：</strong></p><ul><li>emplace(pos,args)函数：pos为指定位置，元素将插入到该位置之前，args对应元素数据类型的构造函数参数</li><li>emplace_first(args)函数：将元素插入到容器头部，args对应元素数据类型的构造函数参数</li><li>emplace_back(args)函数：将元素插入到容器尾部，args对应元素数据类型的构造函数参数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li>deque&lt;数据类型&gt; 数组名(数据个数，初始值)；【参数可省】</li><li>deque&lt;数据类型&gt; 数组名(另一个deque容器)；</li><li>deque&lt;数据类型&gt; 数组名(首地址，尾地址)；</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>容器名[n]——可能越界</li><li>at（）函数访问——性能较前者会有所损耗，但较安全</li><li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li><li>deque容器没有data（）函数，且存储空间不连续，不建议用指针</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><ul><li>增添元素：insert()、push_front()、push_back</li><li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li><li>删除元素：erase()【删除一部分】、clear()【清空容器】</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.push_back(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.push_back(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.push_front(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.size());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.begin(); i &lt; d.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>元素个数为：4<br>0 1 2 3</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> end = d.cend();</span><br><span class="line">    <span class="comment">//常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6;//尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10;//尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">//常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;end)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>1 2 3 4 5</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改首元素</span></span><br><span class="line">    d.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改尾元素</span></span><br><span class="line">    d.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>deque 首元素为：1<br>deque 尾元素为：5<br>deque 新的首元素为：10<br>deque 新的尾元素为：20</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL deque和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-5:序列式容器STL vector</title>
    <link href="https://zwiewings.github.io/2021/05/16/c++%E5%AD%A6%E4%B9%A0-8/"/>
    <id>https://zwiewings.github.io/2021/05/16/c++%E5%AD%A6%E4%B9%A0-8/</id>
    <published>2021-05-16T14:06:41.000Z</published>
    <updated>2021-05-31T12:18:15.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>vector是stl中最常用的容器之一，和array非常相似，但vector实现的是可以插入删除的动态数组，且会自动调整所占用的内存空间，而array只是静态的，容量固定的数组</p><p>vector被称为向量容器，在尾部插入和删除元素效率很高，而下头部或中部插入删除的话效率稍低，定义时需要引用头文件&lt; vector &gt;，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure><p>以上生成了一个空的vector容器，因为没有元素，所以也并没有分配空间，当添加第一个元素时，vector会自动分配内存</p><p>同样也可以在创建的同时指定初始值以及元素个数，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>如上，创建了一个有5个元素的vector容器</p><p>或者是直接指定元素个数，所有默认初始值都为0,也可以自行赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>,<span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如上创建了一个含20个double类型的数据的vector容器，并且设定的初始值都为1.0</p><p>另外，圆括号中的两个参数都可以用变量代替，而且存储元素类型相同的vector容器也可以用于创建新的vector容器（复制的方式）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value1(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value2(value1);</span><br></pre></td></tr></table></figure><p>在此基础上，如果不想复制其他容器中所有的内容，可以用指针或迭代器来指定初始值的范围：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>);<span class="comment">//values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value2(<span class="built_in">std</span>::begin(value1),<span class="built_in">std</span>::begin(value1)+<span class="number">3</span>);<span class="comment">//新创建的value2包含&#123;1,2,3&#125;这3个元素</span></span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>由于vector的类模板也位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略（上述已经省略）</p><p></p></div><br><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; vector &gt;中也封装并提供了可供使用的成员函数：</p><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>size()</td><td>返回实际元素个数</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td></tr><tr><td>resize()</td><td>改变实际元素的个数</td></tr><tr><td>capacity()</td><td>返回当前容量</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>reserve()</td><td>增加容器的容量</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>assign()</td><td>用新元素替换原有内容</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素</td></tr></tbody></table><h2 id="vector容器迭代器"><a href="#vector容器迭代器" class="headerlink" title="vector容器迭代器"></a>vector容器迭代器</h2><p>vector容器的迭代器也是随机访问迭代器，并且vector模板类提供的操作迭代器的成员函数也和array一样</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中首元素的正向迭代器</td></tr><tr><td>end()</td><td>返回指向容器”尾元素+1“的正向迭代器，此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向尾元素的反向迭代器</td></tr><tr><td>rend()</td><td>返回指向“首元素-1”的反向迭代器，通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td></tr></tbody></table><p>此外，c++11新增的begin（）和end（）全局函数也同样适用，和表中的两个同名成员函数作用相同</p><h3 id="vector迭代器的特点"><a href="#vector迭代器的特点" class="headerlink" title="vector迭代器的特点"></a>vector迭代器的特点</h3><p>vector容器可以随存储元素的增加，自行申请更多的存储空间，故而创建一个空的vector容器并不会影响该容器后续的使用</p><p>但<strong>在初始化空的vector时，不能使用迭代器</strong>（没有存储数据的容器是没有分配存储空间的，也就没有指向这个空间的指针），因为对于空的vector容器来说，begin（）和end（）成员函数返回的迭代器是相同的，可以看做指针指向同一个位置</p><div class="note danger flat"><p>故而，因为创建的vector容器values为空，没有分配存储空间，使用迭代器初始化不成功，如下代码将没有输出</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.begin(); first &lt; values.end(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;<span class="comment">//初始化的同时输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>对于空的vector容器来说，可以通过调用push_back()或者借助resize()成员函数实现初始化容器的目的</p></div><p><strong>此外，vector容器在申请更多内存时，容器中的所有元素可能会被复制或移动到新的内存地址，会导致之前创建的迭代器失效</strong></p><div class="note danger flat"><p>如下，values 容器在增加容量之后，元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    values.reserve(<span class="number">20</span>);<span class="comment">//增加 values 的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将在输出以下结果后崩溃：</p><div class="snote paperclip light"><p>values 容器首个元素的地址：0096DFE8</p><p>values 容器首个元素的地址：00965560</p><p></p></div><div class="note success flat"><p>为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍，修改的部分代码如下：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">first = values.begin();</span><br><span class="line">end = values.end();</span><br><span class="line"><span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">    ++first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><div class="snote paperclip light"><p>values 容器首个元素的地址：0164DBE8</p><p>values 容器首个元素的地址：01645560</p><p>123</p><p></p></div><h2 id="访问vector容器"><a href="#访问vector容器" class="headerlink" title="访问vector容器"></a>访问vector容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>vector容器同样可以使用容器名[i]【因为有[]运算符重载，但该重载为了提高效率，同样没有设置边界检查操作】和at（）成员函数的方式获取容器中的元素的值，亦或是data（）成员函数【用于返回指向首个元素的指针】</p><p>除此之外，vector容器还提供两个成员函数，front（）可以返回第一个元素的引用，back（）返回最后一个元素的引用</p><h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>vector依旧有提供size（）成员函数作为循环结束的条件帮助完成容器遍历</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>注：size（）成员函数返回的是实际存储元素的个数，而capacity（）成员函数返回的是vector容器的总容积，两者有所差别</p><p></p></div><p>或者使用for(auto &amp;c:s)完成基于范围的循环，配合begin（）成员函数和end（）成员函数成对使用也可以完成用vector迭代器对vector容器的遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first=values.begin(); first&lt;values.end(); ++first) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加容器中的元素"><a href="#增加容器中的元素" class="headerlink" title="增加容器中的元素"></a>增加容器中的元素</h2><h3 id="从容器尾部添加"><a href="#从容器尾部添加" class="headerlink" title="从容器尾部添加"></a>从容器尾部添加</h3><p>能够用于给容器添加元素的函数，在vector容器提供的成员函数中有两个，分别是push_back()和emplace_back()函数</p><p>push_back()和emplace_back()函数都是在vector容器尾部添加一个元素，用法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);<span class="comment">//上下两行代码实现的效果相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，push_back()和emplace_back()函数的使用方法完全一样，看上去就像是直接替代而已</p><div class="tip warning"><p></p><p>两者的区别在于底层实现的机制不同，push_back()会先随便创建一个元素m，然后将元素的值拷贝或移动到容器的元素n中，会多一个将元素m复制给n，然后析构m的过程，而emplace_back()则是直接在容器尾部创建元素n，故而后者的效率比前者高，但考虑到兼顾c++11标准以前的版本，前者也依然保留使用</p><p></p></div><h3 id="从容器中间插入"><a href="#从容器中间插入" class="headerlink" title="从容器中间插入"></a>从容器中间插入</h3><p>在vector容器中的指定位置插入元素可以调用成员函数insert()和emplace()</p><p>insert()有四种语法格式：</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>insert（pos，elem）</td><td>在迭代器pos指定的位置之前插入一个新元素elem，返回表示新元素插入位置的迭代器</td></tr><tr><td>insert（pos，n，elem）</td><td>在迭代器pos指定的位置之前插入n个元素elem，并返回表示第一个新元素插入位置的迭代器</td></tr><tr><td>insert（pos，first，last）</td><td>在迭代器pos指定的位置之前，插入其他容器（不限于vector中位于[first，last）区域的所有元素，并返回第一个新元素插入位置的迭代器</td></tr><tr><td>insert（pos，initlist）</td><td>在迭代器pos指定的位置之前，插入初始化列表中的所有元素，并返回表示第一个新插入元素位置的迭代器</td></tr></tbody></table><p>相较insert（），emplace（）是c++11标准新增加的成员函数，用于在vector中指定位置之前插入<strong>一个</strong>新的元素，函数声明如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator pos,args……)</span></span>;</span><br></pre></td></tr></table></figure><p>pos为指定插入位置的迭代器，args对应新插入元素构造函数的多个参数，返回值为新插入元素位置的迭代器</p><p>同push_back()和emplace_back()函数的关系一样，insert()和emplace()函数插入单个元素时效果是一样的，但emplace()是直接在指定位置构造元素，而不需要移动，所以效率比insert()高，但无法兼顾c++11标准前的编译器</p><h2 id="删除容器中的元素"><a href="#删除容器中的元素" class="headerlink" title="删除容器中的元素"></a>删除容器中的元素</h2><p>对于访问、添加、插入元素来说，都只能借助vector模板类提供的成员函数，但删除vector容器元素还可以借助一些全局函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中<strong>最后一个元素</strong>，该容器的size减1，capacity不变</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td></tr><tr><td>swap(begin)、pop_back()</td><td>先调用 swap()函数【需要引入头文件algorithm或者utility】交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素，<strong>容器中元素顺序会被打乱</strong></td></tr><tr><td>erase(begin,end)</td><td><strong>删除</strong> vector 容器中位于<strong>迭代器 [begin,end)指定区域内的所有元素</strong>，并返回指向被删除的下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td></tr><tr><td>remove()</td><td><strong>删除容器中所有和指定元素值相等</strong>的元素【需要引用头文件algorithm】，并返回指向最后一个元素下一个位置的迭代器，由于该容器的size和capacity均不变，所以遍历需要借助remove()返回的迭代器，否则可能溢出</td></tr><tr><td>clear()</td><td><strong>删除 vector 容器中所有的元素</strong>，使其变成空的 vector 容器。该容器的size减为0，capacity不变</td></tr></tbody></table><p>remove()函数删除掉容器中多个指定元素后，容器大小和容量都没有改变，其剩余位置还保留了之前存储的元素，这些无用的元素可以用erase()删除，故此，remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用,如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::remove(demo.begin(), demo.end(), <span class="number">3</span>);<span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.erase(iter, demo.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出剩余的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>size is :3<br>capacity is :6<br>1 4 5</p><p></p></div><h2 id="容器扩容问题"><a href="#容器扩容问题" class="headerlink" title="容器扩容问题"></a>容器扩容问题</h2><p>vector容器本身是动态存储的，而多数stl版本中vector容器的自动扩容后容量都会提高到原来的两倍，然后将存储的所有元素按序复制到新的存储空间中，并析构以前存储的元素，释放旧的存储空间，由此可知，整个过程是十分耗时的</p><p>故而，虽然vector容器在增添新元素且容量不足时会自动扩容，但考虑到程序效率，还是应该在创建后用reverse()函数设定元素容量为足够大，尽可能避免在原有存储空间已满的情况下还添加新元素，以免vector容器进行不必要的扩容</p><h2 id="vector-lt-bool-gt"><a href="#vector-lt-bool-gt" class="headerlink" title="vector&lt; bool &gt;"></a>vector&lt; bool &gt;</h2><p>vector&lt; bool &gt;并不是存储bool类型的vector容器，和普通vector&lt; T &gt;模板的底层实现是不一样的，被特殊处理过，存储单位是bit而不是常用的byte</p><p>由于其特殊性，vector&lt; bool &gt;不能支持一些容器该有的基本操作，一般来说尽可能避免使用vector&lt; bool &gt;，取而代之的是，<strong>可以使用deque&lt; bool &gt;来取代，两者功能基本相同</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="vector"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#vector-1">定义方式</button></li><li class="tab"><button type="button" data-href="#vector-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#vector-3">迭代器特点</button></li><li class="tab"><button type="button" data-href="#vector-4">访问元素</button></li><li class="tab"><button type="button" data-href="#vector-5">添删元素</button></li><li class="tab"><button type="button" data-href="#vector-6">其他注意</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="vector-1"><ul><li>vector&lt;数据类型&gt; 容器名{每个元素的值}；</li><li>vector&lt;数据类型&gt; 容器名(数据个数，初始值)；【参数可省】</li><li>vector&lt;数据类型&gt; 容器名(另一个vector容器)；</li><li>vector&lt;数据类型&gt; 容器名(首地址，尾地址)；</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-3"><ul><li>初始化空的vector时，不可以使用迭代器</li><li>在申请更多内存时，容器中元素存储地址可能被更新，造成之前创建的迭代器失效</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-4"><p>对于单个元素：</p><ul><li>用容器名[i]的方式——直接访问，性能最高</li><li>使用at()函数——可避免越界</li><li>使用front()和back()函数——返回第一个/最后一个元素的引用</li><li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li></ul><p>对于多个元素：</p><ul><li>使用size（）函数作为条件循环获取</li><li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-5"><ul><li>增添元素：insert()、push_front()、push_back</li><li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li><li>删除元素：</li><li><ul><li>pop_back()【删除最后一个元素】</li><li>erase()【删除一部分，后续前移】</li><li>clear()【清空容器】</li><li>remove()【删除和指定值相等的元素】</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-6"><ul><li>vector容器虽然能够自动扩容，但耗时较多，应该用reverse（）函数修改容量而避免不必要的自动扩容</li><li>vector&lt; bool &gt;不是存储bool类型的vector容器，不支持基本操作，可以使用deque&lt; bool &gt;替代</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value;<span class="comment">//初始化一个空vector容量</span></span><br><span class="line">    value.push_back(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;L&#x27;</span>);<span class="comment">//向value容器中的尾部依次添加 S、T、L 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, value.size());<span class="comment">//调用 size() 成员函数容器中的元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = value.begin(); i &lt; value.end(); i++) <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    value.insert(value.begin(), <span class="string">&#x27;C&#x27;</span>);<span class="comment">//向容器开头插入字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; value.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>元素个数为：3</p><p>S T L</p><p>首个元素为：C</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    <span class="keyword">while</span> (first != end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>1 2 3 4 5</p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL vector和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-4:序列式容器STL array</title>
    <link href="https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/"/>
    <id>https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/</id>
    <published>2021-05-14T10:55:15.000Z</published>
    <updated>2021-05-31T12:18:07.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="array-lt-T-N-gt-（数组容器）"><a href="#array-lt-T-N-gt-（数组容器）" class="headerlink" title="array&lt;T,N&gt;（数组容器）"></a>array&lt;T,N&gt;（数组容器）</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>在c++的普通数组上新增了一些成员函数和全局函数的容器，使用时需要调用对应的&lt; array &gt;头文件，示意如下图：</p><p><img src="/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/1.png" alt="1"></p><p>在array&lt;T,N&gt;类模板中，T用于指明数据类型，N表示数据个数，一旦建立则长度固定不变，即不能增加和删除，只能改变某个元素的值，故N也必须是常量，不可以用变量表示</p><p>如下语句为创建一个具有5个char类型元素的array容器，其名为value，{}负责初始化（没有初始化可省略），未被初始化的值将默认设为0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,5&gt; values&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>由于array的类模板位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略</p><p></p></div><br><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; array &gt;中不仅封装了array容器的定义，也提供了可供使用的成员函数，调用成员函数的时候可以直接通过类的方式调用，即：array容器的名称.成员函数（）</p><p>【此处有关迭代器的成员函数被后置到下一个小标题，可通过目录跳转查看】</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>此外，get（）全局函数也被array头文件重载，该重载函数的功能是访问容器中指定元素并返回该元素的引用<br><br></p><h2 id="array容器迭代器"><a href="#array容器迭代器" class="headerlink" title="array容器迭代器"></a>array容器迭代器</h2><p>array容器配备的迭代器是功能最为强大的随机访问迭代器</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><div class="tip warning"><p></p><p>注：代码中的auto关键字可以使编译器自动判定变量的类型，并完成该类型变量的定义，以上函数在实际使用时，都可以用auto代替其返回值类型，编译器可以自行判断出该迭代器的类型</p><p></p></div><h3 id="begin（）-end（）和cbegin（）-cend（）"><a href="#begin（）-end（）和cbegin（）-cend（）" class="headerlink" title="begin（）/end（）和cbegin（）/cend（）"></a>begin（）/end（）和cbegin（）/cend（）</h3><p>begin()和end()返回正向迭代器对象，分别指向“首元素”和“尾元素+1”的位置，在实际使用中，可以利用其完成初始化容器和遍历容器中元素</p><p>由于c++11的全局中begin（）和end（）函数也能够从容器中获取迭代器，且当操作对象是array时，能够与封装的函数通用，故而以下两者是等价的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = values.begin();<span class="comment">//用封装的函数begin（）定义</span></span><br><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::begin(values);<span class="comment">//用全局函数begin（）定义</span></span><br></pre></td></tr></table></figure><p>cbegin（）/cend（）返回的是const类型的正向迭代器，可以用于遍历容器中元素，可以访问元素，但无法修改所存储的元素，这一点和c++中被const关键字控制的数据和函数都无法进行元素修改</p><h3 id="rbegin（）-rend（）和crbegin（）-crend（）"><a href="#rbegin（）-rend（）和crbegin（）-crend（）" class="headerlink" title="rbegin（）/rend（）和crbegin（）/crend（）"></a>rbegin（）/rend（）和crbegin（）/crend（）</h3><p>rbegin（）/rend（）可以分别返回指向最后一个元素和指向第一个元素前一个位置的随机访问迭代器，又称反向迭代器，用于逆序的方式处理元素。</p><div class="tip warning"><p></p><p>注：在使用反向迭代器进行++和–运算的时候，++指的是迭代器向左移动一位，–指的是迭代器向右移动一位，即和正向时相比，两个运算符的功能也互换了</p><p></p></div><p>而crbegin（）和crend（）和上述的唯一差别也在于返回的迭代器为const类型，不能用于修改容器中的元素，除此之外，使用上和上述完全相同</p><h2 id="访问array容器"><a href="#访问array容器" class="headerlink" title="访问array容器"></a>访问array容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>首先，可以通过**容器名[]**的方式直接访问和使用容器中的元素，和普通数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2</span>*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2</span>*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句相比，当发生越界时，程序会抛出out_of_range异常，所以除非确定没有越界，否则at（）比直接引用会更加安全</p><p>当然，如果每次访问元素都去检查是否越界的话，无疑会产生很多性能开销，当不可能越界时，还是避免为好</p><p>array 容器还提供了 get&lt; n &gt; 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素，但是其中n只能是一个常量表达式，不可以是循环变量</p><p>array的成员函数中还有着data（）函数，该函数返回一个指向元素的指针，可以使用【*（a+i）】的方式访问容器中各个元素的值</p><h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>可以利用size（）函数【返回值为size_t】作为循环条件访问：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.size() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，对于任何可以使用迭代器的容器都可以使用基于范围的循环：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>注：for(auto &amp;c:s)是在c11标准下可以执行的特殊格式的for循环语句，区别在于引用类型可以改变原来的值，可以对容器中的内容进行赋值，即可通过对c赋值来做到容器s的填充，在不加“&amp;”引用符号时，可以利用c遍历并获得s容器中的每个值，但c无法改变s容器中的元素</p><p></p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="array"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#array-1">定义方式</button></li><li class="tab"><button type="button" data-href="#array-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#array-3">访问元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="array-1"><p>array&lt;数据类型，数据个数（常数）&gt; 数组名{可省略的初始化列表}；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-3"><p>对于单个元素：</p><ul><li>用容器名[i]的方式——直接访问，性能最高</li><li>使用at()函数——可避免越界</li><li>使用get&lt; n &gt;对固定位置的元素访问——n只能使用常量</li><li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li></ul><p>对于多个元素：</p><ul><li>使用size（）函数作为条件循环获取</li><li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;//需要引入 array 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values&#123;&#125;;<span class="comment">//初始化 values 容器为 &#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        values.at(i) = i;<span class="comment">//使用 get() 重载函数输出指定位置元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">3</span>&gt;(values) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//如果容器不为空，则输出容器中所有的元素</span></span><br><span class="line">    <span class="keyword">if</span> (!values.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val = values.begin(); val &lt; values.end(); val++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>3<br>0 1 2 3</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values1;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; values1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.at(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="keyword">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.begin(); i &lt; values1.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.begin(); i &lt; values2.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>values1[0] is : 0<br>values1[1] is : 1<br>values1[2] is : 2<br>Values1 is : 0 1 2 3 4<br>Values2 is : 10 11 12 13 14</p><p></p></div><br><br><div class="tip warning"><p></p><p>题外话：由于STL标准库不是只有array容器，当迭代器指向容器中一个特定元素时，迭代器不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，迭代器到底指向array容器还是vector容器</p><p>（即：只知道一个数据的类型和存储它的地址，无法判断这一整组数据是静态数组还是动态数组）</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL array和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-3：STL库基础</title>
    <link href="https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/"/>
    <id>https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/</id>
    <published>2021-05-13T11:24:16.000Z</published>
    <updated>2021-05-31T12:18:00.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL库基本组成"><a href="#STL库基本组成" class="headerlink" title="STL库基本组成"></a>STL库基本组成</h1><table><thead><tr><th>STL组成</th><th>含义</th></tr></thead><tbody><tr><td>容器</td><td>封装数据结构的模板类，如vector向量容器、list列表等</td></tr><tr><td>算法</td><td>许多被设计成模板的数据结构算法在命名空间中定义，大部分包含在algorithm头文件中，少部分位于numeric头文件</td></tr><tr><td>迭代器</td><td>在C++STL中，对容器中数据的读和写，是通过迭代器完成的</td></tr><tr><td>函数对象</td><td>一个将运算符重载为成员函数的类叫函数对象类，这个类的对象就是函数对象</td></tr><tr><td>适配器</td><td>可以使一个类的接口（模板的参数适配成用户指定的形式，让本来不能在一起工作的两个类工作在一起</td></tr><tr><td>内存分配器</td><td>为容器类模板提供自定义的内存申请和释放功能</td></tr></tbody></table><p>C++标准中，STL头文件被组织为13个：</p><ul><li>iterator：定义了一些迭代器模板</li><li>functional：定义一些函数对象类型和支持函数对象的功能</li><li>vector：类似数组，需要所有元素为统一类型，定义vector容器和vector对象的操作</li><li>deque：封装双端队列，定义deque容器和deque对象操作</li><li>list：封装列表，定义list容器和list对象操作</li><li>queue：封装队列（只有一端可操作，有点栈的感觉，但先进先出），定义queue容器和queue对象操作</li><li>stack：封装堆栈，定义stack容器和stack对象操作</li><li>set：封装二叉树（红黑树），定义set对象和set对象操作</li><li>map：封装加权二叉树（红黑树），定义map对象和map对象操作</li><li>algorithm：定义多种算法，例如升降序排序、查找之类的</li><li>numeric：定义了基础性的数值算法</li><li>memory</li><li>utility</li></ul><br><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>STL容器就是封装了数据结构的模板类的集合，提有三类标准容器：序列容器、排序容器和哈希容器，后两类有时也统称关联容器。</p><table><thead><tr><th>容器种类</th><th>功能</th></tr></thead><tbody><tr><td>序列容器</td><td>主要包括vector向量容器、list列表容器以及deque双端队列容器。元素在容器中的位置同元素值无关，插入元素时指定在什么位置，元素就位于什么位置。</td></tr><tr><td>排序容器</td><td>包括set集合容器、multiset多重集合容器、map映射容器、multimap多重映射容器。元素默认从小到大排列，插入元素时同样插入到合适的位置，所以在查找时具有非常好的性能。</td></tr><tr><td>哈希容器</td><td>包括4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。容器中的元素是未排序的，位置由哈希函数决定。【c++11的编译器下才能使用，VS支持，gcc/g++编译器是不支持的】</td></tr></tbody></table><h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>以线性排列来存储数据，且不进行排序的容器，有如下几种：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li>vector&lt; T &gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li>deque&lt; T &gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li>list&lt; T &gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt; T &gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt; T &gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><div class="tip warning"><p>注：虽然stack< T >和queue< T >本质上也是序列容器，但都是在deque的基础上改造的，更习惯称为容器适配器</p><p></p></div><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器，在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比序列式容器，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。</p><p>相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。</p><br><h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>迭代器和c++的指针非常相似，可以是任何需要的类型，通过迭代器可以指向容器中的某个元素，也可以执行读写操作。</p><p>迭代器的功能强弱决定了容器是否支持STL的某种算法。</p><p>常用迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p><p>【其中输入/输出迭代器不是把数组和容器当做操作对象，而是将输入/输出流作为对象，较为特殊。】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-2">双向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-3">随机访问迭代器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>已知p是一个前向迭代器，则p支持++p，p++，*p操作，可以被复制或赋值，可以用==和！=运算符进行比较，且两个正向迭代器可以相互赋值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>具有正向迭代器的所有功能，同时具有–p或p–的操作（即一次向后移动一个位置）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>具有双向迭代器的全部功能，可以用&lt;、&gt;、&lt;=、&gt;=运算符比较，且p2-p1有意义，为p2指向元素和p1指向元素的序号差</p><p>当i为整型变量或常量时：</p><ul><li>p+=i：往后移动i个元素</li><li>p-=i：往前移动i个元素</li><li>p+i：返回p后面第i个元素的迭代器</li><li>p-i：返回p前面第i个元素的迭代器</li><li>p[i]：返回p后面第i个元素的引用</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>容器</th><th>对应迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set/multiset</td><td>双向迭代器</td></tr><tr><td>map/multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map/unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set/unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><div class="tip warning"><p>注：容器适配器stack和queue没有迭代器，其本身具有一些成员函数，用于对元素进行访问</p><p></p></div><br><h1 id="迭代器定义方式"><a href="#迭代器定义方式" class="headerlink" title="迭代器定义方式"></a>迭代器定义方式</h1><table><thead><tr><th>定义方式</th><th>格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器（反向迭代器适配器）</td><td>::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>::const_reverse_iterator 迭代器名;</td></tr></tbody></table><div class="tip warning"><p></p><p>注意事项：</p><ul><li>读取迭代器指向的元素使用和指针一样的方法：*迭代器名</li><li>反向迭代器和正向迭代器：正向迭代器使用p++时，迭代器指向容器中后一个元素，而反向迭代器使用p++时，迭代器指向前一个元素</li><li>常量迭代器和非常量迭代器：常量迭代器同c++中const声明是几乎一样的，所以只有通过非常量迭代器才能修改其指向的元素</li><li>如容器array、deque、vector同时支持4种，但并不是每个容器都适用以上4种定义迭代器的方式，如forward_list只支持正向迭代器而不支持反向迭代器</li></ul><p></p></div><p>以下为范例1：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;//需要引入vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="comment">//v被初始化为有5个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第1次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)<span class="comment">//可以通过v.size()的方式得到元素个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以像普通数组一样使用vector容器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第2次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"><span class="keyword">for</span> (i = v.begin(); i ！= v.end(); i++)<span class="comment">//能用v.begin()和v.end()的方式获得首末元素的地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以用*迭代器名的方式获取元素值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第3次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = v.begin();</span><br><span class="line"><span class="keyword">while</span> (i &lt; v.end())<span class="comment">//实现间隔一个元素输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i += <span class="number">2</span>;<span class="comment">//随机访问迭代器支持“+=整型”的操作</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上运行结果为：</p><div class="snote paperclip light"><p></p><p>第1次遍历v<br>1 2 3 4 5 6<br>第2次遍历v<br>1 2 3 4 5 6<br>第3次遍历v<br>1 3 5</p><p></p></div><div class="tip warning"><p></p><p>注：VisualStudio在调试时不会检查迭代器越界问题，但运行时系统会弹窗报错”cannot seek vector iterator after end”</p><p></p></div><br><p>以下为范例2：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>以下代码合法：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i != v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用”&lt;”比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i &lt; v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用下标随机访问比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于c++实际应用中的STL库组成及迭代器详细</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-4</title>
    <link href="https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/"/>
    <id>https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/</id>
    <published>2021-05-13T07:10:39.000Z</published>
    <updated>2021-05-31T12:16:24.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>css中的盒模型相当于礼物的外包装盒，封装周围的HTML元素，包括外边距（margin），边框（border），内边距（padding）和实际内容（content），常用的div元素就是一种区块容器标记，可以将网页分隔为不同的部分，以实现网页的规划和布局。</p><p>纵深结构来说，盒模型自下而上为：外边距、背景颜色、背景图像、内边距、内容、边框</p><p><img src="/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/1.PNG" alt="1"></p><div class="tip important font5 fas fa-bell"><p>css代码中的宽和高（width和height）指的是如下部分：</p><p>盒子的总宽度=width+左右内边框之和+左右边框宽度之和+左右外边距之和</p><p>盒子的总高度=height+上下内边距之和+上下边框宽度之和+上下外边框之和</p></div><br><h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><p>边框主要包括边框宽度、边框样式、边框颜色、此外还有border的综合属性，在CSS3中添加了圆角边距，图片边距属性。</p><ul><li><p>边框宽度（border-width）：用于设置元素边框的宽度值</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-width</span>：上边距宽度<span class="selector-attr">[右边距宽度 下边距宽度 左边距宽度]</span>;</span><br><span class="line"></span><br><span class="line">其中，宽度由数字和单位组成，不可为负数，常以像素（<span class="selector-tag">px</span>）为单位，且设定1个值时全部应用，设定2~3个值时，省略的部分将使用对边的样式</span><br></pre></td></tr></table></figure></li><li><p>边框样式（border-style）：用于设置样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-style</span>：上边框样式<span class="selector-attr">[右边框样式 下边框样式 左边框样式]</span>;</span><br><span class="line"></span><br><span class="line">其中，设置时必须按上右下左的顺时针顺序，当设置1个值时为4边，2个值为上下/左右，3个值为上/左右/下，也可以通过形如<span class="selector-tag">border-left-style</span>的方式分别设置</span><br></pre></td></tr></table></figure><p>样式取值共9种，如下：</p><table><thead><tr><th>属性</th><th>含义</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>none</td><td>不显示边框（默认）</td><td>groove</td><td>边框带有立体感的沟槽</td></tr><tr><td>dotted</td><td>点线</td><td>ridge</td><td>边框成脊形</td></tr><tr><td>dashed</td><td>虚线</td><td>inset</td><td>使整个方框凹陷</td></tr><tr><td>solid</td><td>实线</td><td>outset</td><td>使整个方框凸起</td></tr><tr><td>double</td><td>双实线</td><td></td><td></td></tr></tbody></table></li><li><p>边框颜色（border-color）：用于定义边框的颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-color</span>:上边框颜色<span class="selector-attr">[右边框颜色 下边框颜色 左边框颜色]</span>;</span><br><span class="line"></span><br><span class="line">其中，颜色值符合定义法，有十六进制<span class="selector-id">#RRGGBB</span>和<span class="selector-tag">RGB</span>代码、<span class="selector-tag">rgb</span>(<span class="selector-tag">r</span>,<span class="selector-tag">g</span>,<span class="selector-tag">b</span>)三种，仅定义几个值的样式应用方式同上两种，可以通过形如<span class="selector-tag">border-left-color</span>的方式分别定义，（上使用<span class="selector-tag">top</span>，下使用<span class="selector-tag">bottom</span>）</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>边框综合属性（border）</p><p>border为复合属性，前三者的简写方式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">border&lt;边框宽度&gt;|&lt;边框样式&gt;|&lt;颜色&gt;;</span><br><span class="line"></span><br><span class="line">在复合属性中，边框<span class="selector-tag">border</span>同时设置4条边，如只需要1条边框应用该样式，需要通过形如<span class="selector-tag">border-left</span>的方式分别设置</span><br></pre></td></tr></table></figure></li></ul><h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><h3 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h3><p>主要用于调整内容在盒子中的值，指内容content和边框border的距离，也被称作内填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>:上内边距值<span class="selector-attr">[右内边距值 下内边距值 左内边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>边距值为数字和单位组成，不可为负值，常用像素（px）为单位，也可以是百分比，随父元素width变化而变化，和height无关</li><li>padding遵循复制原则，也可以通过形如padding-left的方式设置样式</li></ul><h3 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h3><p>margin指元素边框和相邻元素之间的距离（盒子和盒子的距离）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>:上外边距值<span class="selector-attr">[右外边距值 下外边距值 左外边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>margin为复合属性，同padding用法类似，但可以使用负值，使相邻元素重叠，若盒元素使用了宽度属性，设margin为auto时，可以实现盒元素居中</li><li>margin也遵循复制原则，可通过形如margin-left的方式设置样式</li></ul>]]></content>
    
    
    <summary type="html">关于CSS盒模型的运用</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="网页设计" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="css" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/css/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-6</title>
    <link href="https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/"/>
    <id>https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</id>
    <published>2021-04-27T12:46:05.000Z</published>
    <updated>2021-05-31T12:19:22.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul><li>树：一个有限集，可以为空，非空时有且只有一个根结点，其余结点可以分为多个不相交的有限集（子树）</li><li>结点的度：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶子结点：度为0的结点</li><li>父结点：有子树的结点是其子树的根节点的父结点</li><li>子结点/孩子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点</li><li>兄弟结点：具有同一个父结点的各结点彼此是兄弟结点</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk。ni是ni+1的父结点。路径所包含边的个数为路径的长度</li><li>祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li><li>子孙结点：某一结点的子树中的所有结点是这个结点的子孙</li><li>结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>二叉树：一个有穷的结点集合。这个集合可以为空；若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。</p><p><strong>二叉树的五种基本形态：</strong></p><p>斜二叉树：只有左子节点或只有右子节点的二叉树，度为1，只有左子节点或右子节点</p><p>满二叉树/ 完美二叉树：除最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树</p><p>完全二叉树：有n个结点的二叉树，对树中结点从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中的位置相同（能和满二叉树完全重叠，编号相同）</p><p><strong>按从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：（顺序存储）</strong></p><ul><li>根结点的序号为1</li><li>非根结点（序号i&gt;1）的父结点的序号是：i / 2</li><li>结点（序号为i）的左孩子结点的序号是：2 * i，若2*i &gt; n，则没有左孩子</li><li>结点（序号为i）的右孩子结点的序号是：2 * i + 1，若2*i+1 &gt; n，则没有右孩子</li></ul><p><strong>普遍规律：</strong></p><p>一个二叉树第i层的最大结点数为：2i-1，i≥1</p><p>深度为k的二叉树有最大结点总数为：2k-1，k≥1</p><p>对任何非空二叉树T，叶结点个数为n0，度为1的结点个数为n1，度为2的结点个数为n2，则二叉树的总边数：N=2*n2+n1，总结点数：N′=n0+n1+n2，总叶子结点数：n0=n2+1</p><p><strong>二叉树的三种遍历：</strong></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/1.png" alt="1"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/2.png" alt="2"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/3.png" alt="3"></p><h3 id="二叉树操作"><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h3><h4 id="创建-初始化"><a href="#创建-初始化" class="headerlink" title="创建/初始化"></a>创建/初始化</h4><p>由于树的顺序表结构分配的空间通常只适用于完全二叉树，会造成普通二叉树的空间浪费，所以二叉树一般使用链式结构存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span>&#123;</span></span><br><span class="line">Elemtype data;<span class="comment">//二叉树的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">left</span>;</span><span class="comment">//二叉树的左指针，指向左子树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">Right</span>;</span><span class="comment">//二叉树的右指针，指向右子树</span></span><br><span class="line">&#125;*BTree;</span><br></pre></td></tr></table></figure><p>由于二叉树用递归算法较快，涉及到的先序、中序、后序三种输入方式时，只需要调整根节点的输入顺序即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Create</span><span class="params">(BTree &amp;T)</span><span class="comment">//传入要操作的结点T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elemtype a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;<span class="comment">//当输入为“#”时，判断二叉树创建完毕，结束递归</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        T=<span class="keyword">new</span> BTnode;<span class="comment">//创建一个新的二叉树结点</span></span><br><span class="line">        T-&gt;data=a;<span class="comment">//设置数据域为输入值</span></span><br><span class="line">        Create(T-&gt;left);<span class="comment">//递归创建T的左子树</span></span><br><span class="line">        Create(T-&gt;right);  <span class="comment">//递归创建T的右子树</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>在创建的时候，相当于也就遍历了一次二叉树，故而除却赋值之外的结构都十分相似,而且由于二叉树已经建立，可以通过二叉树的结点指针是否为空判断遍历是否结束</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下位置遍历的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//如果T为空，则结束遍历</span></span><br><span class="line">&#123;</span><br><span class="line">Traverse(T-&gt;left);<span class="comment">//递归遍历T的左子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">//输出T结点的数据</span></span><br><span class="line">Traverse(T-&gt;right);<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算深度"><a href="#计算深度" class="headerlink" title="计算深度"></a>计算深度</h4><p>二叉树深度为左右子树中深度较大者加1，故而需要递归求取左右子树的深度，再比较后加1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下求取深度的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当递归到叶子结点时，结束递归</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=depth(T-&gt;left);<span class="comment">//将左子树的深度存入m</span></span><br><span class="line">        n=depth(T-&gt;right);<span class="comment">//将右子树的深度存入n</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);<span class="comment">//如果左子树深度大于右子树则返回m+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);<span class="comment">//反之，返回n+1</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>线索二叉树将二叉树中空置的左右指针域利用起来，存储沿某种顺序遍历二叉树后继结点的地址，比二叉树多设置左右标志，当标志为1（true）时，表示有对应的子节点（左标志为1，左指针域存储左孩子的地址），否则对应指针域则存储某种顺序遍历二叉树时的下一个结点的地址</p><p><strong>其中，左指针域为线索时，指向前驱，右指针域为线索时指向后继</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> ltag,rtag;</span><br><span class="line">&#125;*DBTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序线索化"><a href="#二叉树中序线索化" class="headerlink" title="二叉树中序线索化"></a>二叉树中序线索化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBTnode *p;<span class="comment">//p为全局变量，是指向线索二叉树结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dchild</span><span class="params">(DBTree T)</span><span class="comment">//以T为根的子树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//当T不为空时</span></span><br><span class="line">&#123;</span><br><span class="line">Dchild(T-&gt;left);<span class="comment">//将左子树递归线索化</span></span><br><span class="line"><span class="keyword">if</span>(!T-&gt;left)<span class="comment">//如果左指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">T-&gt;ltag=<span class="literal">false</span>;<span class="comment">//则左标志为false，表示左指针域为线索指针域</span></span><br><span class="line">T-&gt;left=p;<span class="comment">//左指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> T-&gt;ltag=<span class="literal">true</span>;<span class="comment">//否则左标志为true，表示左指针域指向左孩子</span></span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)<span class="comment">//如果p的右指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//则右标志为false，表示右指针域为线索指针域</span></span><br><span class="line">p-&gt;right=p1;<span class="comment">//右指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p-&gt;rtag=<span class="literal">true</span>;<span class="comment">//否则右标志为true，表示右指针域指向右孩子</span></span><br><span class="line">p=T;<span class="comment">//p指向子树的根节点处</span></span><br><span class="line">Dchild(p-&gt;right);<span class="comment">//将右子树递归线索化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DOchild</span><span class="params">(DBTree &amp;T,DBTree D)</span><span class="comment">//带头结点的二叉树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T=<span class="keyword">new</span> DBTnode;<span class="comment">//创建头结点</span></span><br><span class="line">    T-&gt;Ltag=<span class="literal">true</span>;<span class="comment">//若树非空，则头结点的左孩子为树根，左标志为true</span></span><br><span class="line">    T-&gt;rtag=<span class="literal">false</span>;<span class="comment">//头结点没有右孩子，右标志为false</span></span><br><span class="line">    T-&gt;right=T;<span class="comment">//初始化时，头结点的右指针域指向自己</span></span><br><span class="line">    <span class="keyword">if</span>(!T) T-&gt;left=T;<span class="comment">//若树空，则头结点的左指针也指向自己</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    T-&gt;left=D;<span class="comment">//否则，头结点的左指针域指向原二叉树的根节点D</span></span><br><span class="line">        p=T;<span class="comment">//p指向原二叉树根节点D的前驱</span></span><br><span class="line">        Dchild(D);<span class="comment">//递归线索化二叉树D</span></span><br><span class="line">        p-&gt;right=T;<span class="comment">//递归线索化后，p指向中序遍历的最后一个结点，右指针域指向头结点</span></span><br><span class="line">        p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//p指向结点的右标志为false，表示没有右孩子</span></span><br><span class="line">        T-&gt;right=p;<span class="comment">//将头结点的右指针域指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历中序线索二叉树-非递归"><a href="#遍历中序线索二叉树-非递归" class="headerlink" title="遍历中序线索二叉树(非递归)"></a>遍历中序线索二叉树(非递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OTraverse</span><span class="params">(DBTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p=T-&gt;left;<span class="comment">//p指向头结点的左孩子，即二叉树的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)<span class="comment">//当树空或遍历结束时，将有p==T，结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="literal">true</span>) <span class="comment">//当左标志为false时，即直到没有左孩子时结束循环</span></span><br><span class="line">            p=p-&gt;left;<span class="comment">//p沿左子树向下遍历</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//输出左子树为空的结点的值</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag==<span class="literal">false</span>&amp;&amp;p-&gt;right!=T)<span class="comment">//当右标志为true，即有右孩子且p的后继不是头结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;right;<span class="comment">//p沿右子树向下遍历</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//沿右子树访问后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;right;<span class="comment">//转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于树与二叉树的概念说明，以及二叉树的创建/初始化、遍历、深度计算等代码实现</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5</title>
    <link href="https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/"/>
    <id>https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</id>
    <published>2021-04-26T11:52:16.000Z</published>
    <updated>2021-05-31T12:19:12.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串类型"><a href="#串类型" class="headerlink" title="串类型"></a>串类型</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>串的存储结构可以使用顺序和链式结构，顺序结构中又分为定长和堆式存储结构，但由于链式不如顺序结构灵活，操作简单，故而此处只写入顺序结构</p><h3 id="顺序-定长存储"><a href="#顺序-定长存储" class="headerlink" title="顺序-定长存储"></a>顺序-定长存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch[maxsize+<span class="number">1</span>];<span class="comment">//定义字符数组，串的最大长度为maxsize，多申请防止溢出的存储空间</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;Sstring;</span><br></pre></td></tr></table></figure><h3 id="顺序-堆式存储"><a href="#顺序-堆式存储" class="headerlink" title="顺序-堆式存储"></a>顺序-堆式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;<span class="comment">//如果是非空串，则按串长分配存储区，否则ch指向NULL;</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>串的模式匹配用于在主串中寻找子串，如果匹配成功，则确定相匹配的子串中第一个字符在主串s中出现的位置</p><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;<span class="comment">//否则，i回到开始匹配的位置（执行for语句的i++后移到下一个位置</span></span><br><span class="line">            j=<span class="number">0</span>;<span class="comment">//j被重置为0（然后执行for语句的j++后变为j=1）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];<span class="comment">//KMP相比BF算法节省时间的原因</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(Sstring t,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function">    <span class="comment">//求子串t的next函数值并且存进数组next</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i=<span class="number">1</span>,next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义i，j，以及next数组的第一个值</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;t.length;)<span class="comment">//i不超过子串t长度时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||t.ch[i]==t.ch[j])<span class="comment">//如果j为0或是前后两个字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(t.ch[i]!=t.ch[j])<span class="comment">//如果前后两个字符不相同</span></span><br><span class="line">                next[i]=j;<span class="comment">//令下次比较从j开始</span></span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组的顺序存储"><a href="#二维数组的顺序存储" class="headerlink" title="二维数组的顺序存储"></a>二维数组的顺序存储</h2><p>已知一维数组中a【i】的存储位置在a+i处，二维数组因主序不同分为两种存储结构（常用行序）</p><p>设每个数据元素占L个存储单元，则二维数组A[0…m-1,0…n-1]（下标从0开始，共有m行n列）中任一元素a【i】【j】的存储位置如下：</p><p><strong>行为主序的存储结构</strong>：</p><p>$$<br>LOC(i , j) = LOC(0 , 0) + (n * i + j) L<br>$$<br><strong>列为主序的存储结构：</strong><br>$$<br>LOC(i , j) = LOC(0 , 0) + (m * j + i) L<br>$$<br>其中，LOC(i,j)是a【i】【j】的存储位置</p><p>LOC（0，0）是a【0】【0】的存储位置，即二维数组A的起始存储位置、也称为基地址或基址</p><p><strong>故而总结可知：</strong><br>$$<br>LOC(i , j) = 基址 + (副序长度 * 主序标号 + 另一标号) * 数据所占存储单元<br>$$</p><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>特点：在n*n的矩阵a中，1&lt;= i，j &lt;= n<br>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。</p><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/1.png" alt="1"></p><p>上下三角中的元素均为：n(n+1) / 2<br>可以以行序为主序将元素存放在一个一维数组a[n(n+1) / 2]中，a[k]的位置可如下公式确定<br>$$<br>k=主序序号（主序序号-1）/2+副序序号-1，主序&gt;=副序<br>$$<br>注：上式的k从0开始计算</p><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/2.png" alt="2"></p><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-1.png" alt="3-1"></p><h3 id><a href="#" class="headerlink" title></a><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-2.png" alt="3-2"></h3><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/4.png" alt="4"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>一般记作LS（a1，a2，……，an），其中LS为广义表的名称，n为广义表的长度，其中的元素可以是单个数据（原子）也可以是广义表（子表），一般小写为原子，大写为子表</p><p><strong>广义表示例：</strong></p><ul><li>A=（）——空表，长度为0</li><li>B=（e）——只有一个原子，为e，长度为1</li><li>C=（a，（b，c，d））——有一个原子a和一个子表（b，c，d），共两个元素，长度为2</li><li>D=（A，B，C）——有三个子表，即三个元素，长度为3</li><li>E=（a，E）——一个递归的表，长度为2</li></ul><p>注：广义表A=（（））和广义表B=（）是不相同的，A为有一个空子表，长度为1的广义表，而B是一个空表，长度为0</p>]]></content>
    
    
    <summary type="html">关于串的存储结构、模式匹配算法与数组的特殊存储以及广义表的说明</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
