<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="https://zwiewings.github.io/atom.xml" rel="self"/>
  
  <link href="https://zwiewings.github.io/"/>
  <updated>2021-06-21T12:36:39.944Z</updated>
  <id>https://zwiewings.github.io/</id>
  
  <author>
    <name>Zweiwings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网页设计-5</title>
    <link href="https://zwiewings.github.io/2021/06/21/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-5/"/>
    <id>https://zwiewings.github.io/2021/06/21/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-5/</id>
    <published>2021-06-21T11:44:17.542Z</published>
    <updated>2021-06-21T12:36:39.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript是一种web页面中的脚本编程语言，不需要编译，而是直接嵌入到html页面中，完成动态网页的交互并响应事件，能够实现页面加载完成或单击某个元素时调用指定的JavaScript，或者是读取和改变当前页面某个元素的内容，在提交数据前进行数据的检测，亦或是检测访问者的浏览器，创建cookies等。</p><h2 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h2><p>JavaScript插入到html文档中有两种方法：</p><p>1.直接在html中插入行内javascript</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/JavaScript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="comment">/*插入的JavaScript语句*/</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在html中导入一个javascript文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js文件路径&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript中基本的数据类型有以下几种：</p><p>数值型：可以有小数点也可以没有</p><p>字符串型：用引号引起来的文本</p><p>null类型：表示未赋值的项，只有null一种取值，引用一个没有定义的变量将会返回null</p><p>undefined类型：用于确定一个已经创建但没有初值的变量</p><p>string对象的属性与方法的使用：参考c++类的对象获取对象属性和调用类的成员函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串对象名.字符串属性名；</span><br><span class="line">字符串对象名.字符串方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure><p>math对象的属性与方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">math.属性名</span><br><span class="line">math.方法名(参数<span class="number">1</span>,参数<span class="number">2</span>……)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于javascript脚本语言编写js文件</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="网页设计" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="javascript" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/javascript/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-10:关联式容器STL set</title>
    <link href="https://zwiewings.github.io/2021/06/04/c++%E5%AD%A6%E4%B9%A0-14/"/>
    <id>https://zwiewings.github.io/2021/06/04/c++%E5%AD%A6%E4%B9%A0-14/</id>
    <published>2021-06-04T12:39:34.000Z</published>
    <updated>2021-06-09T12:27:14.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="set容器"><a href="#set容器" class="headerlink" title="set容器"></a>set容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>对于set容器来说，只能存储键与值相等的数据，无法实现如map容器那样的存储，并且set容器的数据并没有强制性的const修饰，但c++标准也对此做出了限制以免用户修改set容器中的数据，由于这些限制，在修改其元素时，应先删除该元素，再插入修改后的元素，以免破坏set容器的有序性</p><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 set 容器中存有元素的个数</td></tr><tr><td>max_size()</td><td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>insert()</td><td>向 set 容器中插入元素</td></tr><tr><td>erase()</td><td>删除 set 容器中存储的元素</td></tr><tr><td>swap()</td><td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同</td></tr><tr><td>clear()</td><td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(val)</td><td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1</td></tr></tbody></table><h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>set 容器配置的迭代器类型为双向迭代器。即若 p 为此类型的迭代器，则其只能进行 ++p、p++、–p、p–、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符</p><p>且set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器，成员函数如下：</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。通常和 rbegin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值</td></tr><tr><td>find(val)</td><td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(val)</td><td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(val)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）</td></tr></tbody></table><div class="tip warning"><p>注：以上成员函数返回的迭代器，指向的只是 set 容器中存储的元素，而不再是键值对。另外，以上成员方法返回的迭代器，无论是 const 类型还是非 const 类型，都不能用于修改 set 容器中的值。</p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空set容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; myset;</span><br><span class="line">    <span class="comment">//空set容器不存储任何元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向myset容器中插入新元素</span></span><br><span class="line">    myset.insert(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    myset.insert(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、myset size = &quot;</span> &lt;&lt; myset.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//利用双向迭代器，遍历myset</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = myset.begin(); iter != myset.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>1、myset size = 0<br>2、myset size = 3<br>a<br>b<br>c</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器set及其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-9:关联式容器STL multimap</title>
    <link href="https://zwiewings.github.io/2021/06/03/c++%E5%AD%A6%E4%B9%A0-13/"/>
    <id>https://zwiewings.github.io/2021/06/03/c++%E5%AD%A6%E4%B9%A0-13/</id>
    <published>2021-06-03T12:25:28.000Z</published>
    <updated>2021-06-04T12:42:07.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="multimap容器"><a href="#multimap容器" class="headerlink" title="multimap容器"></a>multimap容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对</p><p>同map一样，multimap定义时一样有四个参数值，键的类型，值的类型，排序规则，分配器对象的类型</p><p>multimap 类模板内部提供有多个构造函数，总的来说，创建 multimap 容器的方式可归为以下 5 种。</p><ol><li>通过调用 multimap 类模板的默认构造函数，可以创建一个空的 multimap 容器：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap;</span><br></pre></td></tr></table></figure><ol start="2"><li>当然，在创建 multimap 容器的同时，还可以进行初始化操作。比如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123; &#123;<span class="string">&quot;1a&quot;</span>,<span class="string">&quot;a1&quot;</span>&#125;,&#123;<span class="string">&quot;2b&quot;</span>,<span class="string">&quot;b2&quot;</span>&#125;,&#123;<span class="string">&quot;3c&quot;</span>,<span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>注意，使用此方式初始化 multimap 容器时，其底层会先将每一个<code>&#123;key, value&#125;</code>创建成 pair 类型的键值对，然后再用已建好的各个键值对初始化 multimap 容器。</p><p>实际上，我们完全可以先手动创建好键值对，然后再用其初始化 multimap 容器。下面程序使用了 2 种方式创建 pair 类型键值对，再用其初始化 multimap 容器，它们是完全等价的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>),</span><br><span class="line">    <span class="built_in">make_pair</span>(<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>)&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>除此之外，通过调用 multimap 类模板的拷贝（复制）构造函数，也可以初始化新的 multimap 容器。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(mymultimap);</span><br></pre></td></tr></table></figure><p>由此，就成功创建一个和 mymultimap 完全一样的 newmultimap 容器。</p><p>在 C++ 11 标准中，还为 multimap 类增添了移动构造函数。即当有临时的 multimap 容器作为参数初始化新 multimap 容器时，其底层就会调用移动构造函数来实现初始化操作。举个例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">multimap&lt;string, string&gt; dismultimap() &#123;</span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;tempmultimap&#123; </span><br><span class="line">        &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">return</span> tempmultimap;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(dismultimap());</span><br></pre></td></tr></table></figure><p>上面程序中，由于 dismultimap() 函数返回的 tempmultimap 容器是一个临时对象，因此在实现初始化 newmultimap 容器时，底层调用的是 multimap 容器的移动构造函数，而不再是拷贝构造函数</p><blockquote><p>注意，无论是调用复制构造函数还是调用拷贝构造函数，都必须保证这 2 个容器的类型完全一致</p></blockquote><ol start="4"><li>multimap 类模板还支持从已有 multimap 容器中，选定某块区域内的所有键值对，用作初始化新 multimap 容器时使用。例如：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;mymultimap&#123;</span><br><span class="line">    &#123;<span class="string">&quot;1a&quot;</span>, <span class="string">&quot;a1&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;2b&quot;</span>, <span class="string">&quot;b2&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;3c&quot;</span>, <span class="string">&quot;c3&quot;</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;newmultimap(++mymultimap.begin(), mymultimap.end());</span><br></pre></td></tr></table></figure><p>这里使用了 multimap 容器的迭代器，选取了 mymultimap 容器中的最后 2 个键值对，用于初始化 newmultimap 容器</p><ol start="5"><li>前面讲到，multimap 类模板共可以接收 4 个参数，其中第 3 个参数可用来修改 multimap 容器内部的排序规则。默认情况下，此参数的值为<code>std::less&lt;T&gt;</code>，这意味着以下 2 种创建 multimap 容器的方式是等价的：</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>, <span class="built_in">std</span>::less&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>mymultimap 容器中键值对的存储顺序为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a,1&gt;</span><br><span class="line">&lt;b,2&gt;</span><br></pre></td></tr></table></figure><p>下面程序利用了 STL 模板库提供的<code>std::greater&lt;T&gt;</code>排序函数，实现令 multimap 容器对存储的键值对做降序排序：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>,greater&lt;<span class="keyword">char</span>&gt;&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>其内部键值对的存储顺序为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b,2&gt;</span><br><span class="line">&lt;a,1&gt;</span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 multimap 容器中查找首个键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 multimap 容器中第一个大于 key 的键值对的迭代器。如果 multimap 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 multimap 容器中存有键值对的个数</td></tr><tr><td>max_size()</td><td>返回 multimap 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>insert()</td><td>向 multimap 容器中插入键值对</td></tr><tr><td>erase()</td><td>删除 multimap 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td>swap()</td><td>交换 2 个 multimap 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td></tr><tr><td>clear()</td><td>清空 multimap 容器中所有的键值对，使 multimap 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 multimap 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 multimap 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(key)</td><td>在当前 multimap 容器中，查找键为 key 的键值对的个数并返回</td></tr></tbody></table><p>和 map 容器相比，multimap 未提供 at() 成员方法，也没有重载 [] 运算符。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个<br>另外值的一提的是，由于 multimap 容器可存储多个具有相同键的键值对，因此表 1 中的 lower_bound()、upper_bound()、equal_range() 以及 count() 成员方法会经常用到</p><p>值得一提的是，对multimap容器提供的所有函数，map容器都提供，并且其用法相同，所以具体用法直接参见map容器的成员函数说明即可</p><p>点击链接跳转：<a href="https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/">https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</a></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 multimap 容器</span></span><br><span class="line">    <span class="built_in">multimap</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;mymultimap&#123; &#123;<span class="string">&#x27;a&#x27;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">20</span>&#125;,&#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">15</span>&#125;, &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">30</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器存储键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mymultimap 容器中存储键为 &#x27;b&#x27; 的键值对的数量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymultimap.count(<span class="string">&#x27;b&#x27;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mymultimap.begin(); iter != mymultimap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>4<br>2<br>a 10<br>b 20<br>b 15<br>c 30</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器multimap及其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-8:关联式容器STL map</title>
    <link href="https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/"/>
    <id>https://zwiewings.github.io/2021/05/25/c++%E5%AD%A6%E4%B9%A0-12/</id>
    <published>2021-05-25T12:27:57.000Z</published>
    <updated>2021-06-03T12:54:07.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map容器"><a href="#map容器" class="headerlink" title="map容器"></a>map容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>map容器是关联式容器的一种，存储的全都是pair对象，即用pair类模板创建的键值对，其中各个键值对的键和值可以是任何数据类型，包括基本数据类型或结构体或自定义的类，通常来说，map容器中各个键值对都选用string字符串作为键的类型</p><p><strong>map容器会根据键的大小将元素按既定顺序排列</strong>，默认使用less&lt; T &gt;排序规则，会根据键的大小对所有键值作升序排序，但也可以手动指定或自定义这种排序规则</p><p><strong>对于map容器中的键值对来说，键的值不可以重复也不能修改</strong>，即每个键都是独一无二的对应一个元素，且类型使用const修饰</p><p>map容器定义在头文件&lt; map &gt;中，其容器模板有键类型、值类型、排序规则、分配器对象的类型，以上4个参数，其中后两者都有默认值，最后一个参数几乎不会用到</p><p>其中，已有可供修改的排序规则包括：greater&lt; T&gt;【降序】、less&lt; T &gt;【升序】</p><p>map容器常见创建方法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; map1;</span><br><span class="line"><span class="comment">//创建空的map容器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; map2&#123;&#123;<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;value1&quot;</span>&#125;,&#123;<span class="string">&quot;key2&quot;</span>,<span class="string">&quot;value2&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//创建map容器并初始化存入两个键值对</span></span><br><span class="line">map&lt;string,int&gt; map3(map1);</span><br><span class="line"><span class="comment">//复制创建map3</span></span><br><span class="line">map&lt;string,int&gt; map4()//将临时map对象传递给需要初始化的map容器</span><br><span class="line">&#123;</span><br><span class="line">map&lt;string,int&gt; map5(map2);</span><br><span class="line"><span class="keyword">return</span>  map4;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string,int&gt; map6(++map2.begin(),map2.end());</span><br><span class="line"><span class="comment">//取已建map容器中指定区域内的键值对，创建并初始化新的map容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回最后一个元素+1位置的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false</td></tr><tr><td>size()</td><td>返回当前 map 容器中存有键值对的个数</td></tr><tr><td>max_size()</td><td>返回 map 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同</td></tr><tr><td>operator[]</td><td>map容器重载了 [] 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值</td></tr><tr><td>at(key)</td><td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常</td></tr><tr><td>insert()</td><td>向 map 容器中插入键值对</td></tr><tr><td>erase()</td><td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</td></tr><tr><td>swap()</td><td>交换 2 个 map 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同</td></tr><tr><td>clear()</td><td>清空 map 容器中所有的键值对，即使 map 容器的 size() 为 0</td></tr><tr><td>emplace()</td><td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高</td></tr><tr><td>emplace_hint()</td><td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数</td></tr><tr><td>count(key)</td><td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1</td></tr></tbody></table><br><br><h2 id="容器迭代器"><a href="#容器迭代器" class="headerlink" title="容器迭代器"></a>容器迭代器</h2><p>map 容器配备的是双向迭代器（bidirectional iterator），也就是map 容器迭代器只能进行 ++p、p++、–p、p–、*p 操作，并且迭代器之间只能使用 == 或者 != 运算符进行比较</p><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的键值对</td></tr><tr><td>find(key)</td><td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>lower_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>upper_bound(key)</td><td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器</td></tr><tr><td>equal_range(key)</td><td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）</td></tr></tbody></table><p>其中lower_bound(key)和upper_bound(key)更加多用于multimap容器，在map容器中很少用到</p><p>equal_range(key)可以看做是lower_bound(key)和upper_bound(key)的结合，返回一个pair对象，两个元素都是迭代器类型，其中pair.first是lower_bound(key)的返回值，pair.second是upper_bound(key)的返回值，其本身表示键值对中键的值都为key的一个范围</p><div class="tip warning"><p></p><p>由于map容器中键值对的键都是唯一的，所以调用equal_range(key)函数时，其范围内也最多只有一个键值对</p><p></p></div><h3 id="按键索值"><a href="#按键索值" class="headerlink" title="按键索值"></a>按键索值</h3><p>map类模板对[]运算符进行了重载，可以借助类似数组下标的方式直接访问数组中元素，通过指定的键可以得到其对应的值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; map1&#123;<span class="number">1</span>,<span class="string">&quot;first&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;second&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;third&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> value=map1[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//此时value的值等于second</span></span><br></pre></td></tr></table></figure><p>当无法在已有map容器的元素中找到对应键时，会向map容器中添加一个符合要求的新键值对，其对应值默认为0</p><p>map容器也提供at()成员函数，通过输入键查找对应的值，但如果查找失败不会创建新键值对，而是抛出out_of_range异常</p><p>同样，使用find()函数也可以间接的实现这个功能，但返回的是一个迭代器，指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>同上，[]运算符在没有查找到对应键时会添加键值对，配合map容器本身的排序功能便可以实现插入</p><p>除此之外，insert()成员函数专门用于向map中插入键值对数据</p><div class="tip warning"><p></p><p>注：这里所谓的“插入”，指的是 insert() 方法可以将新的键值对插入到 map 容器中的指定位置，但这与 map 容器会自动对存储的键值对进行排序并不冲突。当使用 insert() 方法向 map 容器的指定位置插入新键值对时，其底层会先将新键值对插入到容器的指定位置，如果其破坏了 map 容器的有序性，该容器会对新键值对的位置进行调整</p><p></p></div><p>insert()既可以不指定插入位置，直接将键值对添加到map容器中，又可以向map容器的指定位置插入键值对</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不指定位置</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(const value_type&amp;val);</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定位置</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(const_interator position,<span class="keyword">const</span> value_type&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//引用传递一个键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(const_iterator position,p&amp;&amp;val)</span></span>;</span><br><span class="line"><span class="comment">//以右值引用的方式传递键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入其他map容器中指定区域的所有键值对</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="comment">//其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一次性插入多个键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(&#123;val1, val2, ...&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，不指定位置时，val是键值对类型的变量，该方法会返回一个pair对象，pair.first代表迭代器，pair.second为bool型变量：</p><ul><li>如果成功插入val，返回的pair对象中的迭代器指向val，bool为true</li><li>如果插入失败，返回的pair对象中的迭代器指向和val的键相同的键值对p，bool为false</li></ul><p>指定位置时，val依旧是键值对类型变量，而insert()的返回值将会是迭代器而不再是pair对象：</p><ul><li>如果插入成功，insert()返回一个指向map容器中已插入键值对的迭代器</li><li>如果插入失败，insert()返回一个map容器中指向和val的键相同的键值对</li></ul><div class="tip warning"><p></p><p>以上除指定位置的差别外，语法格式区别在于传参方式不同，局部和全局变量都采用普通引用传参，对于临时的键值对变量则以右值引用方式传参</p><p>而即使指定位置，insert()插入之后map容器依旧会对自己进行排序，决定插入位置的不是insert()传入的迭代器，而是新键值对中的键的值</p><p></p></div><p>除了 insert() ，map 类模板还提供 emplace() 和 emplace_hint() ，它们也可以完成向 map 容器中插入键值对的操作，且效率还比 insert() 高</p><p>其中，emplace() 方法的语法格式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> pair&lt;iterator,bool&gt; emplace (Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p>参数 (Args&amp;&amp;… args) 指的是，这里只需要将创建新键值对所需的数据作为参数直接传入即可，此方法可以自行利用这些数据构建出指定的键值对。另外，该方法的返回值也是一个 pair 对象，其中 pair.first 为一个迭代器，pair.second 为一个 bool 类型变量：</p><ul><li>当该方法将键值对成功插入到 map 容器中时，其返回的迭代器指向该新插入的键值对，同时 bool 变量的值为 true；</li><li>当插入失败时，则表明 map 容器中存在具有相同键的键值对，此时返回的迭代器指向此具有相同键的键值对，同时 bool 变量的值为 false。</li></ul><p>emplace_hint() 方法的功能和 emplace() 类似，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"> <span class="function">iterator <span class="title">emplace_hint</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><p>显然和 emplace() 语法格式相比，有以下 2 点不同：</p><ol><li>该方法不仅要传入创建键值对所需要的数据，还需要传入一个迭代器作为第一个参数，指明要插入的位置（新键值对键会插入到该迭代器指向的键值对的前面）；</li><li>该方法的返回值是一个迭代器，而不再是 pair 对象。当成功插入新键值对时，返回的迭代器指向新插入的键值对；反之，如果插入失败，则表明 map 容器中存有相同键的键值对，返回的迭代器就指向这个键值对。</li></ol><p><strong>和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置</strong></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>map容器删除数据的函数只有如下两个：</p><ul><li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li><li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li></ul><p>用法可参照前面的其他容器的用法，此处不详细说明</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">map的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名；</p><p>——创建空的map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名{以{“键”,”值”}的格式列举键值对}；</p><p>——创建map容器并初始化存入键值对</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一个容器名)；</p><p>——复制创建map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(函数参数表){函数体部分，需要返回一个map对象}</p><p>——将函数中的临时map对象传递给需要初始化的map容器</p></li><li><p>map&lt;键类型,值类型,排序方式(可省)，分配器对象类型(不常用)&gt; 容器名(另一容器的初始位置,另一容器的末位置)；</p><p>——取已建map容器中指定区域内的键值对，创建并初始化新的map容器</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li><li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li><li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li><li>只能进行 ++p、p++、–p、p–、*p 操作</li><li>只能使用 == 或者 != 运算符进行比较</li><li>lower_bound(key)——返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器</li><li>upper_bound(key) ——返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器</li><li>equal_range(key)——返回键值对可以看做是&lt;lower_bound(key),upper_bound(key) &gt;</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>以[]运算符访问已知键对应的值，如果查找失败则插入为新元素，值默认为0</li><li>使用at()函数访问，查找失败返回out_of_range错误</li><li>使用find()函数，返回一个迭代器指向查找到的键值对，查找失败时返回最后一个键值对之后的位置</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>插入元素：</p><ul><li><p>不指定位置：</p><p>pair&lt;iterator,bool&gt; insert(const value_type&amp;val);<br>——引用传递一个键值对</p><p>template&lt; class p &gt;<br>pair&lt;iterator,bool&gt; insert(p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p></li><li><p>指定位置</p><p>iterator insert(const_interator position,const value_type&amp;val);<br>——引用传递一个键值对</p><p>template&lt; class p &gt;<br>  iterator insert(const_iterator position,p&amp;&amp;val);<br>——以右值引用的方式传递键值对</p></li><li><p>插入其他map容器中指定区域的所有键值对<br>template &lt; class InputIterator &gt;<br>  void insert (InputIterator first, InputIterator last);<br>——其中first和last都是迭代器，&lt;first,last&gt;可以表示某map容器中的指定区域</p></li><li><p>——一次性插入多个键值对<br>void insert ({val1, val2, …});</p></li></ul><p>删除元素：</p><ul><li>erase() ：删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对</li><li>clear() ：清空 map 容器中所有的键值对，使 map 容器的 size() 为 0</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个接收 insert() 方法返回值的 pair 对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//插入 STL，由于 STL 并不是临时变量，因此会以第一种方式传参</span></span><br><span class="line">    ret = mymap.insert(STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//以右值引用的方式传递临时的键值对变量</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    ret = mymap.insert(&#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-3&quot;</span> &#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ret.iter = &lt;&#123;&quot;</span> &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; ret.first-&gt;second &lt;&lt; <span class="string">&quot;&#125;, &quot;</span> &lt;&lt; ret.second &lt;&lt; <span class="string">&quot;&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>ret.iter = &lt;{2,2-2}, 1&gt;<br>ret.iter = &lt;{1,1-2}, 1&gt;<br>ret.iter = &lt;{2,2-2}, 0&gt;</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mymap;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//创建一个真实存在的键值对变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; STL = &#123; <span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span> &#125;;</span><br><span class="line">    <span class="comment">//指定要插入的位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator it = mymap.begin();</span><br><span class="line">    <span class="comment">//向 it 位置以普通引用的方式插入 STL</span></span><br><span class="line">    <span class="keyword">auto</span> iter1 = mymap.insert(it, STL);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter1-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter1-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//向 it 位置以右值引用的方式插入临时键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter2 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter2-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter2-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//插入失败样例</span></span><br><span class="line">    <span class="keyword">auto</span> iter3 = mymap.insert(it, <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;2-3&quot;</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter3-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter3-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>2 2-2<br>1 1-2<br>2 2-2</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;mymap&#123; &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1-2&quot;</span>&#125;,</span><br><span class="line">                                                &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;3-2&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="comment">//创建一个空 map 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;copymap;</span><br><span class="line">    <span class="comment">//指定插入区域</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator first = ++mymap.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::iterator last = mymap.end();</span><br><span class="line">    <span class="comment">//将&lt;first,last&gt;区域内的键值对插入到 copymap 中</span></span><br><span class="line">    copymap.insert(first, last);</span><br><span class="line">    <span class="comment">//遍历输出 copymap 容器中的键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = copymap.begin(); iter != copymap.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>3 3-2<br>2 2-2</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器中STL map和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-7:关联式容器STL pair</title>
    <link href="https://zwiewings.github.io/2021/05/21/c++%E5%AD%A6%E4%B9%A0-11/"/>
    <id>https://zwiewings.github.io/2021/05/21/c++%E5%AD%A6%E4%B9%A0-11/</id>
    <published>2021-05-21T11:46:27.000Z</published>
    <updated>2021-05-31T12:19:50.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pair类模板"><a href="#pair类模板" class="headerlink" title="pair类模板"></a>pair类模板</h1><h2 id="键值对数据类型"><a href="#键值对数据类型" class="headerlink" title="键值对数据类型"></a>键值对数据类型</h2><p>关联式容器存储的是”键值对“形式的数据，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;&quot;a&quot;,&quot;121&quot;&gt;</span><br><span class="line">&lt;&quot;b&quot;,&quot;144&quot;&gt;</span><br><span class="line">&lt;&quot;c&quot;,&quot;156&quot;&gt;</span><br></pre></td></tr></table></figure><p>以上每行都表示一个键值对，其中第一个元素作为键，第二个元素作为值，由于键值对不是普通数据类型，c++STL标准库提供了pair类模板，用于将两个普通元素a和b，创建成一个新元素&lt;a,b&gt;</p><h2 id="pair对象构造"><a href="#pair对象构造" class="headerlink" title="pair对象构造"></a>pair对象构造</h2><p>pair类模板定义在&lt; utility &gt;头文件中，所以在使用该类模板之前，需要引入该头文件，且pair类模板提供了共五种构造函数，如下：</p><ul><li>默认构造函数，即创建空的 pair 对象：pair();</li><li>直接使用 2 个元素初始化成 pair 对象：pair (const first_type&amp; a, const second_type&amp; b);</li><li>拷贝（复制）构造函数，即借助另一个 pair 对象，创建新的 pair 对象：template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);</li><li>移动构造函数：template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);</li><li>使用右值引用参数，创建 pair 对象：template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);</li></ul><h3 id="关于右值引用"><a href="#关于右值引用" class="headerlink" title="关于右值引用"></a>关于右值引用</h3><p>注：对于右值引用，能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式为“右值”，一般来说，左值可以取地址，右值不可以。非const变量都是左值，函数调用的返回值若不是引用，则该函数调用就是右值，在不专门指出时，引用基本都是引用变量的，即左值引用。c++11中新增了一种右值引用，可以引用无名的临时变量，使用符号为“&amp;&amp;”</p><p>引入右值引用的主要目的是提高程序运行的效率。有些对象是无名临时变量，但在复制时却需要进行深复制，往往非常耗时。合理使用右值引用可以避免没有必要的深复制操作</p><h2 id="赋值和比较"><a href="#赋值和比较" class="headerlink" title="赋值和比较"></a>赋值和比较</h2><p>pair对象是允许手动赋值的，可用.first和.second分别访问pair对象的键和值，同样，也可以使用make_pair()函数，向其中传入两个参数代表对象的键和值</p><p>&lt; utility &gt;头文件中，除了提供创建pair对象的方法之外，还为pair对象重载了以下6种运算符：&lt;、&lt;=、&gt;、&gt;=、==、!=，其运算规则是先比较键的大小，如果键的大小相等，再比较值的大小，且对于比较的两个pair对象，其对应的键和值的类型应该相同，否则编译器将找不到合适的重载运算符</p><p>除此之外，当键和值的类型都相同时，可以使用swap()成员函数交换两个pair对象的的键值对，同其他容器中的swap()效果相同</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair2(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;9&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair3(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair4(<span class="built_in">make_pair</span>(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;8&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; pair5(<span class="built_in">string</span>(<span class="string">&quot;3&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;7&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair1: 0<br>pair2: 1 9<br>pair3: 1 9<br>pair4: 2 8<br>pair5: 3 7</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;1&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair3(<span class="string">&quot;2&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">//pair1和pair2的key不同，value相同</span></span><br><span class="line">    <span class="keyword">if</span> (pair1 != pair2) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair != pair2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pair2和pair3的key相同，value不同</span></span><br><span class="line">    <span class="keyword">if</span> (pair2 != pair3) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2 != pair3&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair != pair2<br>pair2 != pair3</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;      // pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;       // string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="string">&quot;pair&quot;</span>, <span class="number">10</span>);                   </span><br><span class="line">    <span class="built_in">pair</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2(<span class="string">&quot;pair2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//交换 pair1 和 pair2 的键值对</span></span><br><span class="line">    pair1.swap(pair2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pair2: &quot;</span> &lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>pair1: pair2 20<br>pair2: pair 10</p><p></p></div>]]></content>
    
    
    <summary type="html">关于关联式容器中STL pair和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-7:序列式容器STL list</title>
    <link href="https://zwiewings.github.io/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/"/>
    <id>https://zwiewings.github.io/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/</id>
    <published>2021-05-20T11:50:22.000Z</published>
    <updated>2021-06-04T12:53:32.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list容器"><a href="#list容器" class="headerlink" title="list容器"></a>list容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>list容器，又称双向链表容器，底层实现为双向链表形式，元素可分散存储在内存空间中，前后顺序靠指针维系，每个元素都配备指向前驱和后继的两个指针，第一个元素前驱为NULL，最后一个元素后继为NULL</p><p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/1.jpg" alt="1"></p><p>list容器可以在序列已知的任何位置快速插入和删除元素，并且在list容器中移动元素的效率也比其他容器高，但它不能直接通过位置访问元素，而是需要顺序遍历前面的所有元素直到找到该位置</p><p>所以当需要对序列大量添加、删除元素，却不常直接访问元素数据时，list容器最为高效适用，其创建如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; values;<span class="comment">//创建空list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建包含10个元素的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value2</span><span class="params">(<span class="number">10</span>, <span class="number">5</span>)</span></span>;<span class="comment">//创建包含10个元素且初值为5的list容器</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value3</span><span class="params">(value1)</span></span>;<span class="comment">//拷贝创建一个和value1一样的list容器</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">values</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;<span class="comment">//拷贝普通数组创建list 容器</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt;arr&#123; <span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;values(arr.begin()+<span class="number">2</span>, arr.end());<span class="comment">//拷贝其它容器，创建list 容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的双向迭代器</td></tr><tr><td>end()</td><td>返回指向容器中最后一个元素所在位置的下一个位置的双向迭代器</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向双向迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的反向双向迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>size()</td><td>返回当前容器实际包含的元素个数</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素，该函数和 push_front() 的功能相同，但效率更高</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素</td></tr><tr><td>emplace_back()</td><td>在容器尾部直接生成一个元素，该函数和 push_back() 的功能相同，但效率更高</td></tr><tr><td>push_back()</td><td>在容器尾部插入一个元素</td></tr><tr><td>pop_back()</td><td>删除容器尾部的一个元素</td></tr><tr><td>emplace()</td><td>在容器中的指定位置插入元素，该函数和 insert() 功能相同，但效率更高</td></tr><tr><td>insert()</td><td>在容器中的指定位置插入元素</td></tr><tr><td>erase()</td><td>删除容器中一个或某区域内的元素</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的</td></tr><tr><td>resize()</td><td>调整容器的大小</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素</td></tr><tr><td>splice()</td><td>将一个 list 容器中的元素插入到另一个容器的指定位置</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序</td></tr></tbody></table><h2 id="list容器迭代器"><a href="#list容器迭代器" class="headerlink" title="list容器迭代器"></a>list容器迭代器</h2><p>list容器的迭代器相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p><p><strong>但list容器配备的迭代器类型为双向迭代器，不再是之前的随机访问迭代器</strong></p><p>这意味着，假设 p1 和 p2 都是双向迭代器，则它们支持使用 ++p1、 p1++、 p1–、 p1++、 *p1、 p1==p2 以及 p1!=p2 运算符，但不支持以下操作（其中 i 为整数）：</p><ul><li>p1[i]：不能通过下标访问 list 容器中指定位置处的元素</li><li>双向迭代器不支持使用 -=、+=、+、- 运算符</li><li>双向迭代器不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li></ul><div class="tip warning"><p></p><p>list容器在插入insert（）、接合splice（）等操作时不会造成原有list迭代器失效，删除操作时也仅有指向被删除元素的迭代器失效，其他迭代器不受影响</p><p></p></div><h2 id="访问list容器"><a href="#访问list容器" class="headerlink" title="访问list容器"></a>访问list容器</h2><p>由于list容器不支持随机访问，未提供下标操作符[ ]和at（）成员函数，也没有data（）成员函数，只能使用front（）成员函数和back（）成员函数，用于返回list容器中第一个元素和最后一个元素的引用</p><p>如果想要访问list容器存储的其他元素，只能使用list容器的迭代器，例如:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = mylist.begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    <span class="keyword">while</span> (it!=mylist.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于修改容器中指定元素的值，list模板类提供专门的成员函数assign（）：</p><ul><li>assign(count, value) ：其中count是值的个数，value是分配给元素的值</li><li>assign(begin，end)：其中begin为起始位置，end为结束位置，常作将元素从已有列表复制过来，并覆盖该列表原来的元素值</li></ul><p>除此之外，assign（）函数还可以实现不同容器之间，相容类型的赋值或者是对不能使用赋值符“=”进行赋值的数据类型赋值</p><h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>list容器中，通用的增添元素方法依旧适用，如：</p><ul><li>push_front()：向 list 容器首个元素前添加新元素</li><li>push_back()：向 list 容器最后一个元素后添加新元素</li><li>emplace_front()：在容器首个元素前直接生成新的元素</li><li>emplace_back()：在容器最后一个元素后直接生成新的元素</li><li>emplace()：在容器的指定位置直接生成新的元素</li><li>insert()：在指定位置插入新元素</li></ul><p>而除deque等容器增删元素的方法外，list容器还有一个成员函数splice（），用于将其他list容器存储的多个元素添加到当前list容器的指定位置</p><table><thead><tr><th>语法格式</th><th>功能</th></tr></thead><tbody><tr><td>void splice (iterator position, list&amp; x);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器。 此格式的 splice() 方法的功能是，将 x 容器中存储的所有元素全部移动当前 list 容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator i);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；i 也是一个迭代器，用于指向 x 容器中某个元素。 此格式的 splice() 方法的功能是将 x 容器中 i 指向的元素移动到当前容器中 position 指明的位置处。</td></tr><tr><td>void splice (iterator position, list&amp; x, iterator first, iterator last);</td><td>position 为迭代器，用于指明插入位置；x 为另一个 list 容器；first 和 last 都是迭代器，[fist,last) 用于指定 x 容器中的某个区域。 此格式的 splice() 方法的功能是将 x 容器 [first, last) 范围内所有的元素移动到当前容器 position 指明的位置处。</td></tr></tbody></table><div class="tip warning"><p></p><p>splice() 成员方法移动元素的方式，是将存储该元素的节点从 list 容器底层的链表中摘除，然后再链接到当前 list 容器底层的链表中，也就是当使用 splice() 成员方法将 x 容器中的元素添加到当前容器的同时，该元素会从 x 容器中删除，实现的过程相当于是“剪切”而不是“复制”</p><p></p></div><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>list容器中，通用的删除元素方法依旧适用，如：</p><ul><li>pop_front()    删除位于 list 容器头部的一个元素</li><li>pop_back()    删除位于 list 容器尾部的一个元素</li><li>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</li><li>clear()    删除 list 容器存储的所有元素</li></ul><p>而list容器中新增的方法成员函数有：</p><ul><li>remove(val)    删除容器中所有等于 val 的元素</li><li>remove_if()    删除容器中满足条件的元素</li><li>unique()    删除容器中相邻的重复元素，只保留一份</li></ul><p>其中unique（）可以直接无参使用，也可以自定义传入一个二元谓词函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">demo</span><span class="params">(<span class="keyword">double</span> first, <span class="keyword">double</span> second)</span><span class="comment">//二元谓词函数的定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>(first) == <span class="keyword">int</span>(second));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; mylist&#123; <span class="number">1</span>,<span class="number">1.2</span>,<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4.5</span>,<span class="number">4.6</span> &#125;;</span><br><span class="line">    <span class="comment">//删除相邻重复的元素，仅保留一份</span></span><br><span class="line">    mylist.unique();<span class="comment">//&#123;1, 1.2, 3, 4, 4.5, 4.6&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//demo 为二元谓词函数，是自定义的去重规则</span></span><br><span class="line">    mylist.unique(demo);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>1 1.2 3 4 4.5 4.61 3 4</p></div><div class="tip warning"><p></p><p>谓词函数是一个判断式，一个返回bool值的函数或者仿函数。几元就是函数有几个参数，至于定义和使用，函数定义和一般的函数定义一样，仿函数就是写个类，然后重载operator()。可以在需要返回bool值的函数作参数的函数里使用。</p><p></p></div><p>此外，将自定义的谓词函数传给remove_if()成员函数，list容器中能使函数成立的元素都会被删除：</p><p>remove_if(begin,end,op)：其中begin是起始位置，end为结束位置，op为传入的回调函数，如果返回true，则将当前指向的参数移到尾部（故而需要和erase一起使用才能真正删除元素），其返回值为被移动区域的首个元素</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist&#123; <span class="number">15</span>, <span class="number">36</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">39</span>, <span class="number">4</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//删除 mylist 容器中能够使表达式成立的所有元素</span></span><br><span class="line">    mylist.remove_if([](<span class="keyword">int</span> value) &#123;<span class="keyword">return</span> (value &lt; <span class="number">10</span>); &#125;); <span class="comment">//&#123;15 36 17 20 39&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; *it;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>15 36 17 20 39</p></div><div class="tip warning"><p></p><p>回调函数就是一个被作为参数传递的函数。上述代码中，mylist.remove_if( [ ] (int value) {return (value &lt; 10); });相当于前两个参数默认使用了mylist的begin和end位置，回调函数的参数是int类型的value，当value&lt;10时，回调函数将返回这个表达式的值（false/true）</p><p></p></div><h2 id="更加高效的list——forward-list"><a href="#更加高效的list——forward-list" class="headerlink" title="更加高效的list——forward_list"></a>更加高效的list——forward_list</h2><p>forward_list是c++11标准新添加的一类容器，底层实现和list一样采用链表，但采用的是单链表（相邻元素间只有从前驱指向后驱的指针），list采用的是双链表（相邻元素间有从前向后的指针，也有从后向前的指针）</p><p><img src="/2021/05/20/c++%E5%AD%A6%E4%B9%A0-10/2.gif" alt="2"></p><p>相较list，forward_list同样擅长在序列的任何位置进行插入或删除，而不擅长随机访问元素，而且由于指针从前驱指向后驱，所以配备的迭代器也只有前向迭代器，而不是双向迭代器</p><p>使用forward_list的意义主要是效率高，且在存储相同个数元素时单链表所用空间更少，空间利用率更高，对于某些操作的执行效率也更高，故当list和forward_list都能完成时，应该首选forward_list容器</p><p>以下为forward_list的成员函数：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>before_begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素之前的位置。</td></tr><tr><td>begin()</td><td>返回一个前向迭代器，其指向容器中第一个元素的位置。</td></tr><tr><td>end()</td><td>返回一个前向迭代器，其指向容器中最后一个元素之后的位置。</td></tr><tr><td>cbefore_begin()</td><td>和 before_begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。</td></tr><tr><td>max_size()</td><td>返回容器所能包含元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td></tr><tr><td>front()</td><td>返回第一个元素的引用。</td></tr><tr><td>assign()</td><td>用新元素替换容器中原有内容。</td></tr><tr><td>push_front()</td><td>在容器头部插入一个元素。</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td></tr><tr><td>pop_front()</td><td>删除容器头部的一个元素。</td></tr><tr><td>emplace_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。和 insert_after() 的功能相同，但效率更高。</td></tr><tr><td>insert_after()</td><td>在指定位置之后插入一个新元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>erase_after()</td><td>删除容器中某个指定位置或区域内的所有元素。</td></tr><tr><td>swap()</td><td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td></tr><tr><td>resize()</td><td>调整容器的大小。</td></tr><tr><td>clear()</td><td>删除容器存储的所有元素。</td></tr><tr><td>splice_after()</td><td>将某个 forward_list 容器中指定位置或区域内的元素插入到另一个容器的指定位置之后。</td></tr><tr><td>remove(val)</td><td>删除容器中所有等于 val 的元素。</td></tr><tr><td>remove_if()</td><td>删除容器中满足条件的元素。</td></tr><tr><td>unique()</td><td>删除容器中相邻的重复元素，只保留一个。</td></tr><tr><td>merge()</td><td>合并两个事先已排好序的 forward_list 容器，并且合并之后的 forward_list 容器依然是有序的。</td></tr><tr><td>sort()</td><td>通过更改容器中元素的位置，将它们进行排序。</td></tr><tr><td>reverse()</td><td>反转容器中元素的顺序</td></tr></tbody></table><p>如上，forward_list容器迭代器的移动除了使用++运算符单步移动之外，还能使用advance()函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> it = values.begin();</span><br><span class="line">    advance(it, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span> (it!=values.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，在forward_list容器中是没有提供size（）函数的，想要获取forward_list容器中的存储元素的个数，可以使用头文件&lt; iterator &gt;中的distance（）函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    forward_list&lt;<span class="keyword">int</span>&gt; my_words&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = distance(begin(my_words),end(my_words));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">list的迭代器</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li>list&lt;数据类型&gt; 容器名：创建空list容器</li><li>list&lt;数据类型&gt; 容器名(n, a)：创建包含n个元素，初值为a的容器（a可省略）</li><li>list&lt;数据类型&gt; 容器名(另一个容器名)：拷贝另一个容器创建list</li><li>list&lt;数据类型&gt; 容器名(begin迭代器, end迭代器)：拷贝区间内元素创建list</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</li><li>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</li><li>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</li><li>不能通过下标访问 list 容器中指定位置处的元素</li><li>不支持使用 -=、+=、+、- 运算符</li><li>不支持使用 &lt;、 &gt;、 &lt;=、 &gt;= 比较运算符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>front（）和back（）函数——返回容器中第一个和最后一个元素的引用</li><li>因为存储空间不连续不能使用指针，而只能使用list的迭代器访问</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><p>添加元素：</p><ul><li>push_front()：向 list 容器首个元素前添加新元素</li><li>push_back()：向 list 容器最后一个元素后添加新元素</li><li>emplace_front()：在容器首个元素前直接生成新的元素</li><li>emplace_back()：在容器最后一个元素后直接生成新的元素</li><li>emplace()：在容器的指定位置直接生成新的元素</li><li>insert()：在指定位置插入新元素</li><li>splice()：将其他 list 容器存储的多个元素剪切到当前 list 容器的指定位置处</li></ul><p>删除元素：</p><ul><li><p>pop_front()    删除位于 list 容器头部的一个元素</p></li><li><p>pop_back()    删除位于 list 容器尾部的一个元素</p></li><li><p>erase()    该成员函数既可以删除 list 容器中指定位置处的元素，也可以删除容器中某个区域内的多个元素</p></li><li><p>clear()    删除 list 容器存储的所有元素</p></li><li><p>remove(val)    删除容器中所有等于 val 的元素</p></li><li><p>remove_if()    删除容器中满足条件的元素</p></li><li><p>unique()    删除容器中相邻的重复元素，只保留一份，可以直接无参使用，也可以自定义传入一个二元谓词函数</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空的 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt; values;</span><br><span class="line">    <span class="comment">//向容器中添加元素</span></span><br><span class="line">    values.push_back(<span class="number">3.1</span>);</span><br><span class="line">    values.push_back(<span class="number">2.2</span>);</span><br><span class="line">    values.push_back(<span class="number">2.9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values size：&quot;</span> &lt;&lt; values.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//对容器中的元素进行排序</span></span><br><span class="line">    values.sort();</span><br><span class="line">    <span class="comment">//使用迭代器输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">double</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>values size：3<br>2.2 2.9 3.1</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建 list 容器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; values&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//使用begin()/end()迭代器函数对输出list容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = values.begin(); it != values.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//使用 rbegin()/rend()迭代器函数输出 lsit 容器中的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::reverse_iterator it = values.rbegin(); it != values.rend();++it) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p><a href="http://c.biancheng.net/">http://c.biancheng.net</a><br>ten.gnehcnaib.c//:ptth</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建并初始化 2 个 list 容器</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;, mylist2&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ++mylist1.begin(); <span class="comment">//指向 mylist1 容器中的元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第一种语法格式</span></span><br><span class="line">    mylist1.splice(it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                 <span class="comment">// mylist2:</span></span><br><span class="line">                                 <span class="comment">// it 迭代器仍然指向元素 2，只不过容器变为了 mylist1</span></span><br><span class="line">    <span class="comment">//调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处</span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, it);   <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                                    <span class="comment">// mylist2: 2</span></span><br><span class="line">                                                    <span class="comment">// it 仍然指向元素 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  </span></span><br><span class="line">    mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(), mylist1.end());<span class="comment">//mylist1:</span></span><br><span class="line">                                                                             <span class="comment">//mylist2:1 10 20 30 3 4 2</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist1 包含 &quot;</span> &lt;&lt; mylist1.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2 包含 &quot;</span> &lt;&lt; mylist2.size() &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//输出 mylist2 容器中存储的数据</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mylist2:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = mylist2.begin(); iter != mylist2.end(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>mylist1 包含 0个元素<br>mylist2 包含 7个元素<br>mylist2:1 10 20 30 3 4 2</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL list和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>UE4-溶解特效</title>
    <link href="https://zwiewings.github.io/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/"/>
    <id>https://zwiewings.github.io/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/</id>
    <published>2021-05-20T11:24:16.000Z</published>
    <updated>2021-06-02T00:30:04.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="溶解特效制作"><a href="#溶解特效制作" class="headerlink" title="溶解特效制作"></a>溶解特效制作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文中可以学到4个之前暂时跳过的全新知识点</p><ul><li>材质参数集资产<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/1.png" alt="1"></li><li>材质中的”已遮罩”混合模式<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/2.png" alt="2"></li><li>材质中的if节点以及过场动画中的”材质参数轨道”<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/3.png" alt="3"> </li></ul><p>总之都是干货啦，开始吧~</p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>首先，先准备好溶解特效的蒙版贴图</p><div class="snote download yellow"><a href="https://docs.unrealengine.com/Images/AnimatingObjects/Sequencer/HowTo/TracksMaterialParameter/T_Dissolve.png">点此获取样例蒙版贴图</a></div><p>将贴图导入后，新建一个材质参数集资产并起名为”溶解参数集”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/4.png" alt="4"></p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/5.png" alt="5"></p><p>打开参数集，添加一个标量参数，起名为“Alpha”，意为不透明度，1为正常，0为完全溶解消失。<img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/6.png" alt="6"></p><div class="tip warning"><p></p><p>材质参数集的作用就是可以在游戏运行时改变材质中的一些数值，可以产生材质的动态变化。</p><p></p></div><p>随后打开要被做成溶解特效的材质，以金币材质为例,</p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/7.png" alt="7" style="zoom:50%;"><p>看上去相当复杂，但不用管，只需稍加改造即可。</p><p>首先去细节面板，将混合模式改为“已遮罩”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/8.png" alt="8"></p><table><thead><tr><th align="center">混合模式</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">不透明</td><td align="center">普通不透明的材质</td></tr><tr><td align="center">已遮罩</td><td align="center">相当于材质只覆盖了表面的一层，可以修改局部的不透明度</td></tr><tr><td align="center">半透明</td><td align="center">常用于玻璃水面等材质，可以有折射特效，但只能对整体进行不透明度的修改</td></tr></tbody></table><p>然后将“溶解参数集”拖入，参数名选择Alpha</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/10.png" alt="10"></p><p>将贴图拖入，并建一个if节点，按如下摆放并与“不透明蒙版”相连</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/9.png" alt="9"></p><div class="tip warning"><p></p><p>解释：贴图是一张黑白图，黑白图的RGB为同一个数，而不透明蒙版中输入0为全透明，1为完全不透明，因此可在运行时调整Alpha（从0到1），使贴图蒙版中红色（因是黑白图，所以取哪个都是一样，因为要浮点与浮点才能比较，所以只能取其中一个值，而不能取RGB，因为RGB是向量Vector类型的变量）大于等于那个值的部分显示（蒙版输入1）小于那个值的部分消失（蒙版输入0）。TexCoord之前有提过，按T加左键，用于缩放贴图的密度，UV数字越大密度越高，案例中将U和V都设置成了4。</p><p></p></div><p>if节点的作用：</p><table><thead><tr><th align="center">输入</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">输入一个浮点值</td></tr><tr><td align="center">B</td><td align="center">输入一个浮点值</td></tr><tr><td align="center">A&gt;B</td><td align="center">A&gt;B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr><tr><td align="center">A==B</td><td align="center">A=B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr><tr><td align="center">A&lt;B</td><td align="center">A&lt;B时输出的内容（不一定只能是浮点，可为任意类型）</td></tr></tbody></table><p>到此就建立完毕了，所有套用了这个材质或者所有以这个材质为父类建立的材质实例的物体都会应用溶解的效果</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="过场动画中的使用"><a href="#过场动画中的使用" class="headerlink" title="过场动画中的使用"></a>过场动画中的使用</h3><p>建立一个过场动画，添加一条材质参数集轨道，选择之前建立的“溶解参数集”</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/11.png" alt="11"></p><p>随后添加一个Alpha轨道</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/12.png" alt="12"></p><p>添加一些关键帧（如图分别为0，1，0）</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/13.png" alt="13"></p><p>拖动时间轴可以看到物体溶解然后复原</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/14.png" alt="14"></p><h3 id="蓝图中的使用"><a href="#蓝图中的使用" class="headerlink" title="蓝图中的使用"></a>蓝图中的使用</h3><p>在蓝图中调用这个节点“设置标量参数值”，Collection输入创建的参数集，Parameter Name输入要改变的参数，Parameter Value输入值</p><p><img src="/2021/05/20/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-%E6%BA%B6%E8%A7%A3%E7%89%B9%E6%95%88/15.png" alt="15"></p>]]></content>
    
    
    <summary type="html">通过溶解特效的制作学习有关材质参数集资产以及其他相关知识点</summary>
    
    
    
    <category term="课外拓展" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/UE4/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-7</title>
    <link href="https://zwiewings.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/"/>
    <id>https://zwiewings.github.io/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/</id>
    <published>2021-05-19T12:06:19.000Z</published>
    <updated>2021-06-09T12:47:46.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图（多对多关系）"><a href="#图（多对多关系）" class="headerlink" title="图（多对多关系）"></a>图（多对多关系）</h1><h2 id="定义及名词解释"><a href="#定义及名词解释" class="headerlink" title="定义及名词解释"></a>定义及名词解释</h2><ul><li><strong>图：</strong>顶点的有穷非空集合和边的集合，常用G表示一个图，V表示顶点集合，E是边的集合，其中图至少有一个顶点，且顶点数量为有限个，边的集合可以为空</li><li><strong>有向图和无向图：</strong>图按有无方向可以分为无向图和有向图，无向图称顶点和边，有向图中称顶点和弧，箭头指向的一方为弧头</li><li><strong>稀疏图和稠密图：</strong>图按边和弧的多少分稀疏图和稠密图</li><li><strong>完全图和简单图：</strong>任意两个顶点间都存在边叫完全图，无重复边或顶点到自身的边叫简单图</li><li><strong>度、出度、入度：</strong>图中顶点有邻接点、依附的概念，无向图顶点边数叫度，有向图顶点分出度和入度</li><li><strong>网：</strong>当图的边或弧带有权值，则称其为网</li><li><strong>环/回路和简单路径：</strong>图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始点则称为环，当中不重复的叫简单路径</li><li><strong>连通图：</strong>若任意两顶点都是连通的，则图就是连通图，有向图称为强连通图</li><li><strong>连通分量：</strong>图中有子图，若子图达到极大连通则就是连通分量，有向图中称为强连通分量</li><li><strong>生成森林和有向树：</strong>无向图中连通且n个顶点n-1条边称为生成树，有向图中一顶点入度为0其余顶点入度为1的叫有向树，一个有向图由若干棵有向树构成生成森林</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>可表示为一个二维数组，如图所示</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/1.jpg" alt="1"></p><ol><li><p>当图为无向图时，默认为双向，即整个矩阵沿对角线对称</p></li><li><p>当图为有向图时，由a指向b的边将在矩阵中以array【a】【b】=1的方式表示</p></li><li><p>当图不带权值时，1表示两点连通，0表示不连通</p></li><li><p>当图带权值时，连通时矩阵中的值为两点间的权值，点和它自己标为0，不连通的两点标为无穷</p></li></ol><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>以一维数组存储顶点值，并各自作为头结点，连接其邻接元素的链表，如图所示</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/2.jpg" alt="2"></p><p>其中链表结点的顺序是不固定的，不一定要按顺序排列，而链表部分中，结点的adjvex区域存储的是头结点元素的邻接元素的下标，而不是具体元素的值</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/3.jpg" alt="3"></p><p>十字链表是有向图的链式存储，结合了有向图的邻接表和逆邻接表</p><p>一维数组存储了顶点的值，并作为后续链表的头结点，出弧指针域指向邻接元素（如上图的v0的出弧指针域指向存有弧尾0，弧头1的结点），而入弧指针域指向有弧指向头结点的元素（如上图中的v0的入弧指针域指向存有弧尾2，弧头0的结点）</p><p>在非头结点的结点内部，存有弧头和弧尾元素的下标，以及指向弧头相同的其他结点和弧尾相同的其他结点的指针</p><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/4.gif" alt="4"></p><p>邻接多重表是针对无向图和无向网的，可看作是邻接表和十字链表的结合</p><p>以一维数组存储了顶点的值，并作为后续链表的头结点，非头结点的结点中包括用于标记是否被操作过的标志域(mark)，存储图中边两端的顶点下标的数据域（ivex和jvex，顺序不分），以及指向同一个ivex和同一个jvex的其他结点的指针域（ilink和jlink，顺序不分），除此之外，有时还多设一个用于存储边的权值的数据域</p><p>由于邻接多重表的空间利用率过低，最好还是使用邻接表和邻接矩阵</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历类似于树的先序遍历，大致思路以下图为例</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/5.png" alt="5"></p><ol><li>任意取一个未被遍历过的顶点（如v1），标记为已访问</li><li>遍历v1的邻接点（如v2），并标记为已访问，逐步向下，遍历v2的邻接点，即v4，然后访问v8，再访问v5，都标记为已访问</li><li>当遍历v5的邻接点时，v2和v8都已经被标记为已访问，故而回退到v8，同理回退到v4，v2，最后到v1</li><li>在v1处找到未访问的顶点v3，故而停止回退，继续遍历v3的邻接点v6，然后v7</li><li>遍历v7的邻接点都已经被访问，于是回退到v6，v3，最后回到v1</li><li>判断是否所有顶点都被访问，如果还有未被访问的，继续按照以上方法访问，否则结束遍历</li></ol><p><strong>深度优先遍历总的来说是个不断回溯的过程</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//标记为true</span></span><br><span class="line">    visitVex( G,  v); <span class="comment">//访问第v 个顶点</span></span><br><span class="line">    <span class="comment">//从该顶点的第一个边开始，一直到最后一个边，对处于边另一端的顶点调用DFS函数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> w = FirstAdjVex(G,v); w&gt;=<span class="number">0</span>; w = NextAdjVex(G,v,w))&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位false，证明未被访问，调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="comment">//如果该顶点的标记位为false，则调用深度优先搜索函数</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            DFS( G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    DFSTraverse(G);<span class="comment">//深度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历类似于树的层次遍历，即从某一个顶点开始，遍历其所有邻接点，然后再顺序遍历这些邻接点的所有邻接点，直到所有邻接的顶点被访问后，判断图中是否还有未被访问的结点，若有则重复以上过程</p><p>广度优先遍历的实现借助了队列的结构，实现代码如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERtEX_NUM 20                   <span class="comment">//顶点的最大个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VRType int                          <span class="comment">//表示顶点之间的关系的变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InfoType char                       <span class="comment">//存储弧或者边额外信息的指针变量类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VertexType int                      <span class="comment">//图中顶点的数据类型</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span><span class="literal">false</span>,<span class="literal">true</span>&#125;<span class="keyword">bool</span>;               <span class="comment">//定义bool型常量</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERtEX_NUM];               <span class="comment">//设置全局数组，记录标记顶点是否被访问过</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    VertexType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VRType adj;                             <span class="comment">//对于无权图，用 1 或 0 表示是否相邻；对于带权图，直接为权值。</span></span><br><span class="line">    InfoType * info;                        <span class="comment">//弧或边额外含有的信息指针</span></span><br><span class="line">&#125;ArcCell,AdjMatrix[MAX_VERtEX_NUM][MAX_VERtEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType vexs[MAX_VERtEX_NUM];        <span class="comment">//存储图中顶点数据</span></span><br><span class="line">    AdjMatrix arcs;                         <span class="comment">//二维数组，记录顶点之间的关系</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;                      <span class="comment">//记录图的顶点数和弧（边）数</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="comment">//根据顶点本身数据，判断出顶点在二维数组中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(MGraph * G,VertexType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历一维数组，找到变量v</span></span><br><span class="line">    <span class="keyword">for</span> (; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;vexs[i]==v) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果找不到，输出提示语句，返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (i&gt;G-&gt;vexnum) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no such vertex.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateDN</span><span class="params">(MGraph *G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;(G-&gt;vexnum),&amp;(G-&gt;arcnum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;(G-&gt;vexs[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;G-&gt;vexnum; j++) &#123;</span><br><span class="line">            G-&gt;arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">            G-&gt;arcs[i][j].info=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G-&gt;arcnum; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;v1,&amp;v2);</span><br><span class="line">        <span class="keyword">int</span> n=LocateVex(G, v1);</span><br><span class="line">        <span class="keyword">int</span> m=LocateVex(G, v2);</span><br><span class="line">        <span class="keyword">if</span> (m==<span class="number">-1</span> ||n==<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no this vertex\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        G-&gt;arcs[n][m].adj=<span class="number">1</span>;</span><br><span class="line">        G-&gt;arcs[m][n].adj=<span class="number">1</span>;<span class="comment">//无向图的二阶矩阵沿主对角线对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FirstAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找与数组下标为v的顶点之间有边的顶点，返回它在数组中的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( G.arcs[v][i].adj )&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NextAdjVex</span><span class="params">(MGraph G,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从前一个访问位置w的下一个位置开始，查找之间有边的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = w+<span class="number">1</span>; i&lt;G.vexnum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arcs[v][i].adj)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//操作顶点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visitVex</span><span class="params">(MGraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,G.vexs[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue ** Q)</span></span>&#123;</span><br><span class="line">    (*Q)=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    (*Q)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//顶点元素v进队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Queue **Q,VertexType v)</span></span>&#123;</span><br><span class="line">    Queue * element=(Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    element-&gt;data=v;</span><br><span class="line">    Queue * temp=(*Q);</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next=element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队头元素出队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue **Q,<span class="keyword">int</span> *u)</span></span>&#123;</span><br><span class="line">    (*u)=(*Q)-&gt;next-&gt;data;</span><br><span class="line">    (*Q)-&gt;next=(*Q)-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(Queue *Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(MGraph G)</span></span>&#123;<span class="comment">//</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="comment">//将用做标记的visit数组初始化为false</span></span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; ++v)&#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于每个标记为false的顶点调用深度优先搜索函数</span></span><br><span class="line">    Queue * Q;</span><br><span class="line">    InitQueue(&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>( v = <span class="number">0</span>; v &lt; G.vexnum; v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            visited[v]=<span class="literal">true</span>;</span><br><span class="line">            visitVex(G, v);</span><br><span class="line">            EnQueue(&amp;Q, G.vexs[v]);</span><br><span class="line">            <span class="keyword">while</span> (!QueueEmpty(Q)) &#123;</span><br><span class="line">                <span class="keyword">int</span> u;</span><br><span class="line">                DeQueue(&amp;Q, &amp;u);</span><br><span class="line">                u=LocateVex(&amp;G, u);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w=FirstAdjVex(G, u); w&gt;=<span class="number">0</span>; w=NextAdjVex(G, u, w)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                        visited[w]=<span class="literal">true</span>;</span><br><span class="line">                        visitVex(G, w);</span><br><span class="line">                        EnQueue(&amp;Q, G.vexs[w]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MGraph G;<span class="comment">//建立一个图的变量</span></span><br><span class="line">    CreateDN(&amp;G);<span class="comment">//初始化图</span></span><br><span class="line">    BFSTraverse(G);<span class="comment">//广度优先搜索图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h3><p>普里姆算法（Prim算法）或称DJP算法，可在加权连通图里搜索最小生成树。由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.png" alt="6"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/6.jpg" alt="6"></p><h3 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h3><p>克鲁斯卡尔算法从边的角度求网的最小生成树，和普里姆算法恰恰相反，更适合于求边稀疏的网的最小生成树</p><p>对于任意一个连通网的最小生成树来说，在要求总的权值最小的情况下，最直接的想法就是将连通网中的所有边按照权值大小进行升序排序，从小到大依次选择</p><p>由于最小生成树本身是一棵生成树，所以需要时刻满足以下两点：</p><ul><li>生成树中任意顶点之间有且仅有一条通路，也就是说，生成树中不能存在回路</li><li>对于具有 n 个顶点的连通网，其生成树中只能有 n-1 条边，这 n-1 条边连通着 n 个顶点</li></ul><p><strong>连接 n 个顶点在不产生回路的情况下，只需要 n-1 条边</strong></p><p>所以克鲁斯卡尔算法的具体思路是：将所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。</p><div class="tip warning"><p></p><p>判断是否会产生回路的方法为：在初始状态下给每个顶点赋予不同的标记，对于遍历过程的每条边，其都有两个顶点，判断这两个顶点的标记是否一致，如果一致，说明它们本身就处在一棵树中，如果继续连接就会产生回路；如果不一致，说明它们之间还没有任何关系，可以连接。</p><p></p></div><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/7.png" alt="7"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/8.png" alt="8"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/9.png" alt="9"></p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/10.png" alt="10"></p><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h3><p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><p><strong>操作步骤</strong></p><ol><li>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]</li><li>从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k</li><li>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离</li><li>重复步骤(2)和(3)，直到遍历完所有顶点</li></ol><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/11.jpg" alt="11"></p><h3 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h3><p>Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，与Dijkstra算法类似。该算法是一种在具有正或负边缘权重（但没有负环）的加权图中找到最短路径的算法，即支持负权值但不支持负权环。</p><p>相较而言，迪杰斯特拉计算的是单源最短路径，而弗洛伊德计算的是多源最短路径，其时间复杂度为O(n³)。虽然它不返回路径本身的细节，但是可以通过对算法的简单修改来重建路径，我们利用这个思想，通过递归的方式访问每条路径经过的中间节点，对最终的路径进行输出。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/12.jpg" alt="12"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>对一个<strong>有向无环图</strong>进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前。<br>在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列，由AOV网构造拓扑序列的过程叫做拓扑排序。<strong>AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。</strong></p><p>由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止：</p><ol><li>选择一个入度为0的顶点并输出</li><li>从网中删除此顶点及所有出边</li></ol><p>循环结束后，若输出的顶点数小于网中的顶点数，则有回路，否则输出的顶点序列就是一种拓扑序列。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/13.jpg" alt="13"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>在AOE网中，从始点到终点具有最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径，通过优化关键路径能够实现有效的程序优化，<strong>同拓扑排序一样，关键路径也不是唯一的</strong>。</p><p>由于AOE网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。</p><p><img src="/2021/05/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/14.jpg" alt="14"></p><p>如图，由v1到v9即一条关键路径，其关键路径长度为29，当其他路线中边的权值相加相等时，图中也可能出现多条关键路径</p>]]></content>
    
    
    <summary type="html">关于图的概念及其四种算法同拓扑排序和关键路径</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-6:序列式容器STL deque</title>
    <link href="https://zwiewings.github.io/2021/05/19/c++%E5%AD%A6%E4%B9%A0-9/"/>
    <id>https://zwiewings.github.io/2021/05/19/c++%E5%AD%A6%E4%B9%A0-9/</id>
    <published>2021-05-19T08:08:50.000Z</published>
    <updated>2021-05-31T12:18:24.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>deque容器即双端队列容器，擅长在序列头部和尾部添加或删除元素，不擅长在序列中间添加或删除元素，且deque容器可以根据需要修改自身容量大小，但deque容器存储时，并不能保证所有元素都存储到连续的内存空间中</p><p>当需要向序列两端频繁添加或删除元素时，应该首选deque容器，同样需要引用同名头文件&lt; deque &gt;</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;<span class="comment">//创建一个空deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//创建具有10个元素的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">2</span>)</span></span>;<span class="comment">//创建具有10个元素，且初值为2的deque容器</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d4</span><span class="params">(d2)</span></span>;<span class="comment">//以d2为模板拷贝构造一个deque容器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(a,a+<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//拷贝构造一个装有其他类型容器中指定区域的元素的deque容器</span></span><br></pre></td></tr></table></figure><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的迭代器</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的迭代器</td></tr><tr><td>rend()</td><td>返回指向第一个元素所在位置前一个位置的迭代器</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素</td></tr><tr><td>size()</td><td>返回实际元素个数</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，我们很少会用到这个函数</td></tr><tr><td>resize()</td><td>改变实际元素的个数</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>assign()</td><td>用新元素替换原有内容</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素</td></tr><tr><td>push_front()</td><td>在序列的头部添加一个元素</td></tr><tr><td>pop_back()</td><td>移除容器尾部的元素</td></tr><tr><td>pop_front()</td><td>移除容器头部的元素</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素</td></tr><tr><td>erase()</td><td>移除一个元素或一段元素</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素</td></tr><tr><td>emplace_front()</td><td>在容器头部生成一个元素。和 push_front() 的区别是，该函数直接在容器头部构造元素，省去了复制移动元素的过程</td></tr><tr><td>emplace_back()</td><td>在容器尾部生成一个元素。和 push_back() 的区别是，该函数直接在容器尾部构造元素，省去了复制移动元素的过程</td></tr></tbody></table><div class="tip warning"><p></p><p>和vector容器相比，额外增加了在容器头部添加和删除元素的成员函数，并删除了capacity()、reserve()和data()成员函数</p><p></p></div><h2 id="deque容器迭代器"><a href="#deque容器迭代器" class="headerlink" title="deque容器迭代器"></a>deque容器迭代器</h2><p>deque容器的迭代器类型是随机访问迭代器，相关成员函数有begin/end、rbegin/rend、cbegin/cend、crbegin/crend，具体可参见array和vector篇</p><div class="note danger flat"><p>迭代器的功能是遍历容器，在遍历的同时可以访问甚至修改容器中元素，但迭代器不能用来初始化空的deque容器（这一点和vector是一样的），故而如下代码错误：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    *first = <span class="number">1</span>;<span class="comment">//该处错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>对于空的deque容器，可以通过push_back()、push_front()、resize()成员函数实现添加元素</p></div><p>此外，向deque容器添加元素时，deque容器会申请更多的内存空间，其包含的所有元素可能会被复制或移动到新的内存地址，导致之前创建的迭代器失效（这点和vector容器也是一样的）</p><h2 id="访问deque容器"><a href="#访问deque容器" class="headerlink" title="访问deque容器"></a>访问deque容器</h2><ol><li>容器名[n]——可能越界【通用】</li><li>at（）函数访问——性能较前者会有所损耗，但较安全【通用】</li><li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li></ol><div class="tip warning"><p></p><p>注：deque容器没有提供data（）函数，同时deque容器存储时不保证存储在连续空间中，故而应该尽可能避免用指针去访问deque容器中指定位置处的元素</p><p></p></div><h2 id="添删元素"><a href="#添删元素" class="headerlink" title="添删元素"></a>添删元素</h2><p>deque提供增删元素的成员函数如下：</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>push_back()</td><td>在容器现有元素的尾部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的尾部</td></tr><tr><td>pop_back()</td><td>移除容器尾部的一个元素</td></tr><tr><td>push_front()</td><td>在容器现有元素的头部添加一个元素，和 emplace_back() 不同，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的头部</td></tr><tr><td>pop_front()</td><td>移除容器尾部的一个元素</td></tr><tr><td>emplace_back()</td><td>C++11 新添加的成员函数，其功能是在容器尾部生成一个元素。和 push_back() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td></tr><tr><td>emplace_front()</td><td>C++ 11 新添加的成员函数，其功能是在容器头部生成一个元素。和 push_front() 不同，该函数直接在容器头部构造元素，省去了复制或移动元素的过程</td></tr><tr><td>insert()</td><td>在指定的位置直接生成一个元素。和 emplace() 不同的是，该函数添加新元素的过程是，先构造元素，然后再将该元素移动或复制到容器的指定位置</td></tr><tr><td>emplace()</td><td>C++ 11 新添加的成员函数，其功能是 insert() 相同，即在指定的位置直接生成一个元素。和 insert() 不同的是，emplace() 直接在容器指定位置构造元素，省去了复制或移动元素的过程</td></tr><tr><td>erase()</td><td>移除一个元素或某一区域内的多个元素</td></tr><tr><td>clear()</td><td>删除容器中所有的元素</td></tr></tbody></table><p><strong>在实际应用中，常用emplace()、emplace_front()和emplace_back()分别替代函数insert()、push_front()和push_back()</strong></p><p>其中insert()可以有四种语法格式：insert（pos，elem）、insert（pos，n，elem）、insert（pos，first，last）以及insert（pos initlist），具体使用参见vector容器篇的说明</p><p><strong>emplace系列函数参数说明：</strong></p><ul><li>emplace(pos,args)函数：pos为指定位置，元素将插入到该位置之前，args对应元素数据类型的构造函数参数</li><li>emplace_first(args)函数：将元素插入到容器头部，args对应元素数据类型的构造函数参数</li><li>emplace_back(args)函数：将元素插入到容器尾部，args对应元素数据类型的构造函数参数</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="deque"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#deque-1">定义方式</button></li><li class="tab"><button type="button" data-href="#deque-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#deque-3">访问元素</button></li><li class="tab"><button type="button" data-href="#deque-4">添删元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="deque-1"><ul><li>deque&lt;数据类型&gt; 数组名(数据个数，初始值)；【参数可省】</li><li>deque&lt;数据类型&gt; 数组名(另一个deque容器)；</li><li>deque&lt;数据类型&gt; 数组名(首地址，尾地址)；</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-3"><ul><li>容器名[n]——可能越界</li><li>at（）函数访问——性能较前者会有所损耗，但较安全</li><li>front（）和back（）——返回deque容器中第一个和最后一个元素的引用</li><li>deque容器没有data（）函数，且存储空间不连续，不建议用指针</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="deque-4"><ul><li>增添元素：insert()、push_front()、push_back</li><li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li><li>删除元素：erase()【删除一部分】、clear()【清空容器】</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个空deque容量</span></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line">    <span class="comment">//向d容器中的尾部依次添加 1，2,3</span></span><br><span class="line">    d.push_back(<span class="number">1</span>); <span class="comment">//&#123;1&#125;</span></span><br><span class="line">    d.push_back(<span class="number">2</span>); <span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">    d.push_back(<span class="number">3</span>); <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//向d容器的头部添加 0 </span></span><br><span class="line">    d.push_front(<span class="number">0</span>); <span class="comment">//&#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//调用 size() 成员函数输出该容器存储的字符个数。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, d.size());</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = d.begin(); i &lt; d.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>元素个数为：4<br>0 1 2 3</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = d.cbegin();</span><br><span class="line">    <span class="keyword">auto</span> end = d.cend();</span><br><span class="line">    <span class="comment">//常量迭代器不能用来修改容器中的元素值</span></span><br><span class="line">    <span class="comment">//*(first + 1) = 6;//尝试修改容器中元素 2 的值</span></span><br><span class="line">    <span class="comment">//*(end - 1) = 10;//尝试修改容器中元素 5 的值</span></span><br><span class="line">    <span class="comment">//常量迭代器可以用来遍历容器、访问容器中的元素</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;end)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>1 2 3 4 5</p><p></p></div><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改首元素</span></span><br><span class="line">    d.front() = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的首元素为：&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//修改尾元素</span></span><br><span class="line">    d.back() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;deque 新的尾元素为：&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>deque 首元素为：1<br>deque 尾元素为：5<br>deque 新的首元素为：10<br>deque 新的尾元素为：20</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL deque和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-5:序列式容器STL vector</title>
    <link href="https://zwiewings.github.io/2021/05/16/c++%E5%AD%A6%E4%B9%A0-8/"/>
    <id>https://zwiewings.github.io/2021/05/16/c++%E5%AD%A6%E4%B9%A0-8/</id>
    <published>2021-05-16T14:06:41.000Z</published>
    <updated>2021-05-31T12:18:15.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vector容器"><a href="#Vector容器" class="headerlink" title="Vector容器"></a>Vector容器</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>vector是stl中最常用的容器之一，和array非常相似，但vector实现的是可以插入删除的动态数组，且会自动调整所占用的内存空间，而array只是静态的，容量固定的数组</p><p>vector被称为向量容器，在尾部插入和删除元素效率很高，而下头部或中部插入删除的话效率稍低，定义时需要引用头文件&lt; vector &gt;，如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; values;</span><br></pre></td></tr></table></figure><p>以上生成了一个空的vector容器，因为没有元素，所以也并没有分配空间，当添加第一个元素时，vector会自动分配内存</p><p>同样也可以在创建的同时指定初始值以及元素个数，比如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure><p>如上，创建了一个有5个元素的vector容器</p><p>或者是直接指定元素个数，所有默认初始值都为0,也可以自行赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(<span class="number">20</span>,<span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如上创建了一个含20个double类型的数据的vector容器，并且设定的初始值都为1.0</p><p>另外，圆括号中的两个参数都可以用变量代替，而且存储元素类型相同的vector容器也可以用于创建新的vector容器（复制的方式）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">double</span> value =<span class="number">1.0</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">values</span><span class="params">(num, value)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value1(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value2(value1);</span><br></pre></td></tr></table></figure><p>在此基础上，如果不想复制其他容器中所有的内容，可以用指针或迭代器来指定初始值的范围：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values(<span class="built_in">array</span>, <span class="built_in">array</span>+<span class="number">2</span>);<span class="comment">//values 将保存&#123;1,2&#125;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;value2(<span class="built_in">std</span>::begin(value1),<span class="built_in">std</span>::begin(value1)+<span class="number">3</span>);<span class="comment">//新创建的value2包含&#123;1,2,3&#125;这3个元素</span></span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>由于vector的类模板也位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略（上述已经省略）</p><p></p></div><br><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; vector &gt;中也封装并提供了可供使用的成员函数：</p><table><thead><tr><th>函数成员</th><th>函数功能</th></tr></thead><tbody><tr><td>size()</td><td>返回实际元素个数</td></tr><tr><td>max_size()</td><td>返回元素个数的最大值。这通常是一个很大的值，一般是 2^32-1，所以我们很少会用到这个函数</td></tr><tr><td>resize()</td><td>改变实际元素的个数</td></tr><tr><td>capacity()</td><td>返回当前容量</td></tr><tr><td>empty()</td><td>判断容器中是否有元素，若无元素，则返回 true；反之，返回 false</td></tr><tr><td>reserve()</td><td>增加容器的容量</td></tr><tr><td>shrink _to_fit()</td><td>将内存减少到等于当前元素实际所使用的大小</td></tr><tr><td>operator[ ]</td><td>重载了 [ ] 运算符，可以向访问数组中元素那样，通过下标即可访问甚至修改 vector 容器中的元素</td></tr><tr><td>at()</td><td>使用经过边界检查的索引访问元素</td></tr><tr><td>front()</td><td>返回第一个元素的引用</td></tr><tr><td>back()</td><td>返回最后一个元素的引用</td></tr><tr><td>data()</td><td>返回指向容器中第一个元素的指针</td></tr><tr><td>assign()</td><td>用新元素替换原有内容</td></tr><tr><td>push_back()</td><td>在序列的尾部添加一个元素</td></tr><tr><td>pop_back()</td><td>移出序列尾部的元素</td></tr><tr><td>insert()</td><td>在指定的位置插入一个或多个元素</td></tr><tr><td>erase()</td><td>移出一个元素或一段元素</td></tr><tr><td>clear()</td><td>移出所有的元素，容器大小变为 0</td></tr><tr><td>swap()</td><td>交换两个容器的所有元素</td></tr><tr><td>emplace()</td><td>在指定的位置直接生成一个元素</td></tr><tr><td>emplace_back()</td><td>在序列尾部生成一个元素</td></tr></tbody></table><h2 id="vector容器迭代器"><a href="#vector容器迭代器" class="headerlink" title="vector容器迭代器"></a>vector容器迭代器</h2><p>vector容器的迭代器也是随机访问迭代器，并且vector模板类提供的操作迭代器的成员函数也和array一样</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中首元素的正向迭代器</td></tr><tr><td>end()</td><td>返回指向容器”尾元素+1“的正向迭代器，此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向尾元素的反向迭代器</td></tr><tr><td>rend()</td><td>返回指向“首元素-1”的反向迭代器，通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td></tr><tr><td>cend()</td><td>和 end() 功能相同，返回的迭代器类型为常量正向迭代器，不能用于修改元素</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，返回的迭代器类型为常量反向迭代器，不能用于修改元素</td></tr></tbody></table><p>此外，c++11新增的begin（）和end（）全局函数也同样适用，和表中的两个同名成员函数作用相同</p><h3 id="vector迭代器的特点"><a href="#vector迭代器的特点" class="headerlink" title="vector迭代器的特点"></a>vector迭代器的特点</h3><p>vector容器可以随存储元素的增加，自行申请更多的存储空间，故而创建一个空的vector容器并不会影响该容器后续的使用</p><p>但<strong>在初始化空的vector时，不能使用迭代器</strong>（没有存储数据的容器是没有分配存储空间的，也就没有指向这个空间的指针），因为对于空的vector容器来说，begin（）和end（）成员函数返回的迭代器是相同的，可以看做指针指向同一个位置</p><div class="note danger flat"><p>故而，因为创建的vector容器values为空，没有分配存储空间，使用迭代器初始化不成功，如下代码将没有输出</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first = values.begin(); first &lt; values.end(); ++first, val++) &#123;</span><br><span class="line">        *first = val;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;<span class="comment">//初始化的同时输出值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>对于空的vector容器来说，可以通过调用push_back()或者借助resize()成员函数实现初始化容器的目的</p></div><p><strong>此外，vector容器在申请更多内存时，容器中的所有元素可能会被复制或移动到新的内存地址，会导致之前创建的迭代器失效</strong></p><div class="note danger flat"><p>如下，values 容器在增加容量之后，元素的存储地址发生了改变，此时再使用先前创建的迭代器，显然是错误的</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    values.reserve(<span class="number">20</span>);<span class="comment">//增加 values 的容量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将在输出以下结果后崩溃：</p><div class="snote paperclip light"><p>values 容器首个元素的地址：0096DFE8</p><p>values 容器首个元素的地址：00965560</p><p></p></div><div class="note success flat"><p>为了保险起见，每当 vector 容器的容量发生变化时，我们都要对之前创建的迭代器重新初始化一遍，修改的部分代码如下：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values 容器首个元素的地址：&quot;</span> &lt;&lt; values.data() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">first = values.begin();</span><br><span class="line">end = values.end();</span><br><span class="line"><span class="keyword">while</span> (first != end) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *first ;</span><br><span class="line">    ++first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><div class="snote paperclip light"><p>values 容器首个元素的地址：0164DBE8</p><p>values 容器首个元素的地址：01645560</p><p>123</p><p></p></div><h2 id="访问vector容器"><a href="#访问vector容器" class="headerlink" title="访问vector容器"></a>访问vector容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>vector容器同样可以使用容器名[i]【因为有[]运算符重载，但该重载为了提高效率，同样没有设置边界检查操作】和at（）成员函数的方式获取容器中的元素的值，亦或是data（）成员函数【用于返回指向首个元素的指针】</p><p>除此之外，vector容器还提供两个成员函数，front（）可以返回第一个元素的引用，back（）返回最后一个元素的引用</p><h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>vector依旧有提供size（）成员函数作为循环结束的条件帮助完成容器遍历</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//从下标 0 一直遍历到 size()-1 处</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>注：size（）成员函数返回的是实际存储元素的个数，而capacity（）成员函数返回的是vector容器的总容积，两者有所差别</p><p></p></div><p>或者使用for(auto &amp;c:s)完成基于范围的循环，配合begin（）成员函数和end（）成员函数成对使用也可以完成用vector迭代器对vector容器的遍历：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> first=values.begin(); first&lt;values.end(); ++first) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加容器中的元素"><a href="#增加容器中的元素" class="headerlink" title="增加容器中的元素"></a>增加容器中的元素</h2><h3 id="从容器尾部添加"><a href="#从容器尾部添加" class="headerlink" title="从容器尾部添加"></a>从容器尾部添加</h3><p>能够用于给容器添加元素的函数，在vector容器提供的成员函数中有两个，分别是push_back()和emplace_back()函数</p><p>push_back()和emplace_back()函数都是在vector容器尾部添加一个元素，用法如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values&#123;&#125;;</span><br><span class="line">    values.push_back(<span class="number">1</span>);</span><br><span class="line">    values.emplace_back(<span class="number">2</span>);<span class="comment">//上下两行代码实现的效果相同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; values[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，push_back()和emplace_back()函数的使用方法完全一样，看上去就像是直接替代而已</p><div class="tip warning"><p></p><p>两者的区别在于底层实现的机制不同，push_back()会先随便创建一个元素m，然后将元素的值拷贝或移动到容器的元素n中，会多一个将元素m复制给n，然后析构m的过程，而emplace_back()则是直接在容器尾部创建元素n，故而后者的效率比前者高，但考虑到兼顾c++11标准以前的版本，前者也依然保留使用</p><p></p></div><h3 id="从容器中间插入"><a href="#从容器中间插入" class="headerlink" title="从容器中间插入"></a>从容器中间插入</h3><p>在vector容器中的指定位置插入元素可以调用成员函数insert()和emplace()</p><p>insert()有四种语法格式：</p><table><thead><tr><th>语法格式</th><th>用法说明</th></tr></thead><tbody><tr><td>insert（pos，elem）</td><td>在迭代器pos指定的位置之前插入一个新元素elem，返回表示新元素插入位置的迭代器</td></tr><tr><td>insert（pos，n，elem）</td><td>在迭代器pos指定的位置之前插入n个元素elem，并返回表示第一个新元素插入位置的迭代器</td></tr><tr><td>insert（pos，first，last）</td><td>在迭代器pos指定的位置之前，插入其他容器（不限于vector中位于[first，last）区域的所有元素，并返回第一个新元素插入位置的迭代器</td></tr><tr><td>insert（pos，initlist）</td><td>在迭代器pos指定的位置之前，插入初始化列表中的所有元素，并返回表示第一个新插入元素位置的迭代器</td></tr></tbody></table><p>相较insert（），emplace（）是c++11标准新增加的成员函数，用于在vector中指定位置之前插入<strong>一个</strong>新的元素，函数声明如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator pos,args……)</span></span>;</span><br></pre></td></tr></table></figure><p>pos为指定插入位置的迭代器，args对应新插入元素构造函数的多个参数，返回值为新插入元素位置的迭代器</p><p>同push_back()和emplace_back()函数的关系一样，insert()和emplace()函数插入单个元素时效果是一样的，但emplace()是直接在指定位置构造元素，而不需要移动，所以效率比insert()高，但无法兼顾c++11标准前的编译器</p><h2 id="删除容器中的元素"><a href="#删除容器中的元素" class="headerlink" title="删除容器中的元素"></a>删除容器中的元素</h2><p>对于访问、添加、插入元素来说，都只能借助vector模板类提供的成员函数，但删除vector容器元素还可以借助一些全局函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>pop_back()</td><td>删除 vector 容器中<strong>最后一个元素</strong>，该容器的size减1，capacity不变</td></tr><tr><td>erase(pos)</td><td>删除 vector 容器中 pos 迭代器指定位置处的元素，并返回指向被删除元素下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td></tr><tr><td>swap(begin)、pop_back()</td><td>先调用 swap()函数【需要引入头文件algorithm或者utility】交换要删除的目标元素和容器最后一个元素的位置，然后使用 pop_back() 删除该目标元素，<strong>容器中元素顺序会被打乱</strong></td></tr><tr><td>erase(begin,end)</td><td><strong>删除</strong> vector 容器中位于<strong>迭代器 [begin,end)指定区域内的所有元素</strong>，并返回指向被删除的下一个位置元素的迭代器【<strong>会将删除位置后续的元素陆续前移</strong>】，该容器的size减1，capacity不变</td></tr><tr><td>remove()</td><td><strong>删除容器中所有和指定元素值相等</strong>的元素【需要引用头文件algorithm】，并返回指向最后一个元素下一个位置的迭代器，由于该容器的size和capacity均不变，所以遍历需要借助remove()返回的迭代器，否则可能溢出</td></tr><tr><td>clear()</td><td><strong>删除 vector 容器中所有的元素</strong>，使其变成空的 vector 容器。该容器的size减为0，capacity不变</td></tr></tbody></table><p>remove()函数删除掉容器中多个指定元素后，容器大小和容量都没有改变，其剩余位置还保留了之前存储的元素，这些无用的元素可以用erase()删除，故此，remove()用于删除容器中指定元素时，常和 erase() 成员函数搭配使用,如下:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = <span class="built_in">std</span>::remove(demo.begin(), demo.end(), <span class="number">3</span>);<span class="comment">//交换要删除元素和最后一个元素的位置</span></span><br><span class="line">    demo.erase(iter, demo.end());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size is :&quot;</span> &lt;&lt; demo.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;capacity is :&quot;</span> &lt;&lt; demo.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.size();i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//输出剩余的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>size is :3<br>capacity is :6<br>1 4 5</p><p></p></div><h2 id="容器扩容问题"><a href="#容器扩容问题" class="headerlink" title="容器扩容问题"></a>容器扩容问题</h2><p>vector容器本身是动态存储的，而多数stl版本中vector容器的自动扩容后容量都会提高到原来的两倍，然后将存储的所有元素按序复制到新的存储空间中，并析构以前存储的元素，释放旧的存储空间，由此可知，整个过程是十分耗时的</p><p>故而，虽然vector容器在增添新元素且容量不足时会自动扩容，但考虑到程序效率，还是应该在创建后用reverse()函数设定元素容量为足够大，尽可能避免在原有存储空间已满的情况下还添加新元素，以免vector容器进行不必要的扩容</p><h2 id="vector-lt-bool-gt"><a href="#vector-lt-bool-gt" class="headerlink" title="vector&lt; bool &gt;"></a>vector&lt; bool &gt;</h2><p>vector&lt; bool &gt;并不是存储bool类型的vector容器，和普通vector&lt; T &gt;模板的底层实现是不一样的，被特殊处理过，存储单位是bit而不是常用的byte</p><p>由于其特殊性，vector&lt; bool &gt;不能支持一些容器该有的基本操作，一般来说尽可能避免使用vector&lt; bool &gt;，取而代之的是，<strong>可以使用deque&lt; bool &gt;来取代，两者功能基本相同</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="vector"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#vector-1">定义方式</button></li><li class="tab"><button type="button" data-href="#vector-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#vector-3">迭代器特点</button></li><li class="tab"><button type="button" data-href="#vector-4">访问元素</button></li><li class="tab"><button type="button" data-href="#vector-5">添删元素</button></li><li class="tab"><button type="button" data-href="#vector-6">其他注意</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="vector-1"><ul><li>vector&lt;数据类型&gt; 容器名{每个元素的值}；</li><li>vector&lt;数据类型&gt; 容器名(数据个数，初始值)；【参数可省】</li><li>vector&lt;数据类型&gt; 容器名(另一个vector容器)；</li><li>vector&lt;数据类型&gt; 容器名(首地址，尾地址)；</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-3"><ul><li>初始化空的vector时，不可以使用迭代器</li><li>在申请更多内存时，容器中元素存储地址可能被更新，造成之前创建的迭代器失效</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-4"><p>对于单个元素：</p><ul><li>用容器名[i]的方式——直接访问，性能最高</li><li>使用at()函数——可避免越界</li><li>使用front()和back()函数——返回第一个/最后一个元素的引用</li><li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li></ul><p>对于多个元素：</p><ul><li>使用size（）函数作为条件循环获取</li><li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-5"><ul><li>增添元素：insert()、push_front()、push_back</li><li>对应的emplace系列：emplace()、emplace_front()、emplace_back()</li><li>删除元素：</li><li><ul><li>pop_back()【删除最后一个元素】</li><li>erase()【删除一部分，后续前移】</li><li>clear()【清空容器】</li><li>remove()【删除和指定值相等的元素】</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="vector-6"><ul><li>vector容器虽然能够自动扩容，但耗时较多，应该用reverse（）函数修改容量而避免不必要的自动扩容</li><li>vector&lt; bool &gt;不是存储bool类型的vector容器，不支持基本操作，可以使用deque&lt; bool &gt;替代</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;value;<span class="comment">//初始化一个空vector容量</span></span><br><span class="line">    value.push_back(<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    value.push_back(<span class="string">&#x27;L&#x27;</span>);<span class="comment">//向value容器中的尾部依次添加 S、T、L 字符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素个数为：%d\n&quot;</span>, value.size());<span class="comment">//调用 size() 成员函数容器中的元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = value.begin(); i &lt; value.end(); i++) <span class="comment">//使用迭代器遍历容器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    value.insert(value.begin(), <span class="string">&#x27;C&#x27;</span>);<span class="comment">//向容器开头插入字符</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;首个元素为：&quot;</span> &lt;&lt; value.at(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>元素个数为：3</p><p>S T L</p><p>首个元素为：C</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> first = values.begin();</span><br><span class="line">    <span class="keyword">auto</span> end = values.end();</span><br><span class="line">    <span class="keyword">while</span> (first != end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p>1 2 3 4 5</p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL vector和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-4:序列式容器STL array</title>
    <link href="https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/"/>
    <id>https://zwiewings.github.io/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/</id>
    <published>2021-05-14T10:55:15.000Z</published>
    <updated>2021-05-31T12:18:07.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="array-lt-T-N-gt-（数组容器）"><a href="#array-lt-T-N-gt-（数组容器）" class="headerlink" title="array&lt;T,N&gt;（数组容器）"></a>array&lt;T,N&gt;（数组容器）</h1><h2 id="简要说明及其定义"><a href="#简要说明及其定义" class="headerlink" title="简要说明及其定义"></a>简要说明及其定义</h2><p>在c++的普通数组上新增了一些成员函数和全局函数的容器，使用时需要调用对应的&lt; array &gt;头文件，示意如下图：</p><p><img src="/2021/05/14/c++%E5%AD%A6%E4%B9%A0-7/1.png" alt="1"></p><p>在array&lt;T,N&gt;类模板中，T用于指明数据类型，N表示数据个数，一旦建立则长度固定不变，即不能增加和删除，只能改变某个元素的值，故N也必须是常量，不可以用变量表示</p><p>如下语句为创建一个具有5个char类型元素的array容器，其名为value，{}负责初始化（没有初始化可省略），未被初始化的值将默认设为0</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">char</span>,5&gt; values&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>由于array的类模板位于命名空间std，所以当默认空间为std时，前面表示作用域的std::可以省略</p><p></p></div><br><h2 id="容器提供的成员函数"><a href="#容器提供的成员函数" class="headerlink" title="容器提供的成员函数"></a>容器提供的成员函数</h2><p>头文件&lt; array &gt;中不仅封装了array容器的定义，也提供了可供使用的成员函数，调用成员函数的时候可以直接通过类的方式调用，即：array容器的名称.成员函数（）</p><p>【此处有关迭代器的成员函数被后置到下一个小标题，可通过目录跳转查看】</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>size()</td><td>返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>max_size()</td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。</td></tr><tr><td>empty()</td><td>判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。</td></tr><tr><td>at(n)</td><td>返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。</td></tr><tr><td>front()</td><td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td></tr><tr><td>back()</td><td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td></tr><tr><td>data()</td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td></tr><tr><td>fill(val)</td><td>将 val 这个值赋值给容器中的每个元素。</td></tr><tr><td>array1.swap(array2)</td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td></tr></tbody></table><p>此外，get（）全局函数也被array头文件重载，该重载函数的功能是访问容器中指定元素并返回该元素的引用<br><br></p><h2 id="array容器迭代器"><a href="#array容器迭代器" class="headerlink" title="array容器迭代器"></a>array容器迭代器</h2><p>array容器配备的迭代器是功能最为强大的随机访问迭代器</p><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。</td></tr><tr><td>end()</td><td>返回指向容器最后一个元素之后一个位置的正向迭代器；如果是 const 类型容器，在该函数返回的是常量正向迭代器。此函数通常和 begin() 搭配使用。</td></tr><tr><td>rbegin()</td><td>返回指向最后一个元素的反向迭代器；如果是 const 类型容器，在该函数返回的是常量反向迭代器。</td></tr><tr><td>rend()</td><td>返回指向第一个元素之前一个位置的反向迭代器。如果是 const 类型容器，在该函数返回的是常量反向迭代器。此函数通常和 rbegin() 搭配使用。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能类似，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的迭代器类型为常量正向迭代器，不能用于修改元素。</td></tr><tr><td>crbegin()</td><td>和 rbegin() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr><tr><td>crend()</td><td>和 rend() 功能相同，只不过其返回的迭代器类型为常量反向迭代器，不能用于修改元素。</td></tr></tbody></table><div class="tip warning"><p></p><p>注：代码中的auto关键字可以使编译器自动判定变量的类型，并完成该类型变量的定义，以上函数在实际使用时，都可以用auto代替其返回值类型，编译器可以自行判断出该迭代器的类型</p><p></p></div><h3 id="begin（）-end（）和cbegin（）-cend（）"><a href="#begin（）-end（）和cbegin（）-cend（）" class="headerlink" title="begin（）/end（）和cbegin（）/cend（）"></a>begin（）/end（）和cbegin（）/cend（）</h3><p>begin()和end()返回正向迭代器对象，分别指向“首元素”和“尾元素+1”的位置，在实际使用中，可以利用其完成初始化容器和遍历容器中元素</p><p>由于c++11的全局中begin（）和end（）函数也能够从容器中获取迭代器，且当操作对象是array时，能够与封装的函数通用，故而以下两者是等价的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = values.begin();<span class="comment">//用封装的函数begin（）定义</span></span><br><span class="line"><span class="keyword">auto</span> first = <span class="built_in">std</span>::begin(values);<span class="comment">//用全局函数begin（）定义</span></span><br></pre></td></tr></table></figure><p>cbegin（）/cend（）返回的是const类型的正向迭代器，可以用于遍历容器中元素，可以访问元素，但无法修改所存储的元素，这一点和c++中被const关键字控制的数据和函数都无法进行元素修改</p><h3 id="rbegin（）-rend（）和crbegin（）-crend（）"><a href="#rbegin（）-rend（）和crbegin（）-crend（）" class="headerlink" title="rbegin（）/rend（）和crbegin（）/crend（）"></a>rbegin（）/rend（）和crbegin（）/crend（）</h3><p>rbegin（）/rend（）可以分别返回指向最后一个元素和指向第一个元素前一个位置的随机访问迭代器，又称反向迭代器，用于逆序的方式处理元素。</p><div class="tip warning"><p></p><p>注：在使用反向迭代器进行++和–运算的时候，++指的是迭代器向左移动一位，–指的是迭代器向右移动一位，即和正向时相比，两个运算符的功能也互换了</p><p></p></div><p>而crbegin（）和crend（）和上述的唯一差别也在于返回的迭代器为const类型，不能用于修改容器中的元素，除此之外，使用上和上述完全相同</p><h2 id="访问array容器"><a href="#访问array容器" class="headerlink" title="访问array容器"></a>访问array容器</h2><h3 id="单个元素"><a href="#单个元素" class="headerlink" title="单个元素"></a>单个元素</h3><p>首先，可以通过**容器名[]**的方式直接访问和使用容器中的元素，和普通数组访问元素的方式相同，例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values[<span class="number">4</span>] = values[<span class="number">3</span>] + <span class="number">2</span>*values[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>此行代码中，第 5 个元素的值被赋值为右边表达式的值。需要注意的是，使用如上这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。</p><p>为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数，例如 :</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">values.at (<span class="number">4</span>) = values.at(<span class="number">3</span>) + <span class="number">2</span>*values.at(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这行代码和前一行语句相比，当发生越界时，程序会抛出out_of_range异常，所以除非确定没有越界，否则at（）比直接引用会更加安全</p><p>当然，如果每次访问元素都去检查是否越界的话，无疑会产生很多性能开销，当不可能越界时，还是避免为好</p><p>array 容器还提供了 get&lt; n &gt; 模板函数，它是一个辅助函数，能够获取到容器的第 n 个元素，但是其中n只能是一个常量表达式，不可以是循环变量</p><p>array的成员函数中还有着data（）函数，该函数返回一个指向元素的指针，可以使用【*（a+i）】的方式访问容器中各个元素的值</p><h3 id="多个元素"><a href="#多个元素" class="headerlink" title="多个元素"></a>多个元素</h3><p>可以利用size（）函数【返回值为size_t】作为循环条件访问：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span> ; i &lt; values.size() ; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    total += values[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，对于任何可以使用迭代器的容器都可以使用基于范围的循环：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp;&amp; value : values)</span><br><span class="line">    total += value;</span><br></pre></td></tr></table></figure><div class="tip warning"><p></p><p>注：for(auto &amp;c:s)是在c11标准下可以执行的特殊格式的for循环语句，区别在于引用类型可以改变原来的值，可以对容器中的内容进行赋值，即可通过对c赋值来做到容器s的填充，在不加“&amp;”引用符号时，可以利用c遍历并获得s容器中的每个值，但c无法改变s容器中的元素</p><p></p></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div class="tabs" id="array"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#array-1">定义方式</button></li><li class="tab"><button type="button" data-href="#array-2">迭代器函数</button></li><li class="tab"><button type="button" data-href="#array-3">访问元素</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="array-1"><p>array&lt;数据类型，数据个数（常数）&gt; 数组名{可省略的初始化列表}；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-2"><ul><li><p>begin（）/end（）：返回“开头/结尾+1”处的元素的正向迭代器</p></li><li><p>前加r：返回“开头-1/结尾”的反向迭代器——rbegin（）/rend（）</p></li><li><p>前加c：返回const类型的元素迭代器——cbegin()/cend(),crbegin()/crend()</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="array-3"><p>对于单个元素：</p><ul><li>用容器名[i]的方式——直接访问，性能最高</li><li>使用at()函数——可避免越界</li><li>使用get&lt; n &gt;对固定位置的元素访问——n只能使用常量</li><li>使用data()函数获得指向第一个元素的指针——用*（a+i）读取第i个元素</li></ul><p>对于多个元素：</p><ul><li>使用size（）函数作为条件循环获取</li><li>使用for（auto &amp;c:s）这一特殊格式的for循环完成遍历赋值，只读时不加“&amp;”引用符</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;//需要引入 array 头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; values&#123;&#125;;<span class="comment">//初始化 values 容器为 &#123;0,1,2,3&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        values.at(i) = i;<span class="comment">//使用 get() 重载函数输出指定位置元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; get&lt;<span class="number">3</span>&gt;(values) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//如果容器不为空，则输出容器中所有的元素</span></span><br><span class="line">    <span class="keyword">if</span> (!values.empty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val = values.begin(); val &lt; values.end(); val++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; *val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>3<br>0 1 2 3</p><p></p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values1;</span><br><span class="line">    <span class="built_in">array</span>&lt;<span class="keyword">int</span>, 5&gt; values2;</span><br><span class="line">    <span class="comment">//初始化 values1 为 &#123;0,1,2,3,4&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; values1.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        values1.at(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[0] is : &quot;</span> &lt;&lt; values1[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[1] is : &quot;</span> &lt;&lt; values1.at(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;values1[2] is : &quot;</span> &lt;&lt; get&lt;<span class="number">2</span>&gt;(values1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//初始化 values2 为&#123;10，11，12，13，14&#125;</span></span><br><span class="line">    <span class="keyword">int</span> initvalue = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; value : values2)</span><br><span class="line">    &#123;</span><br><span class="line">        value = initvalue;</span><br><span class="line">        initvalue++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;  <span class="string">&quot;Values1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values1.begin(); i &lt; values1.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;Values2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = values2.begin(); i &lt; values2.end(); i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><div class="snote paperclip light"><p></p><p>values1[0] is : 0<br>values1[1] is : 1<br>values1[2] is : 2<br>Values1 is : 0 1 2 3 4<br>Values2 is : 10 11 12 13 14</p><p></p></div><br><br><div class="tip warning"><p></p><p>题外话：由于STL标准库不是只有array容器，当迭代器指向容器中一个特定元素时，迭代器不会保留任何关于容器本身的信息，所以我们无法从迭代器中判断，迭代器到底指向array容器还是vector容器</p><p>（即：只知道一个数据的类型和存储它的地址，无法判断这一整组数据是静态数组还是动态数组）</p><p></p></div>]]></content>
    
    
    <summary type="html">关于序列式容器中STL array和其用法</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>c++拓展-3：STL库基础</title>
    <link href="https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/"/>
    <id>https://zwiewings.github.io/2021/05/13/c++%E5%AD%A6%E4%B9%A0-6/</id>
    <published>2021-05-13T11:24:16.000Z</published>
    <updated>2021-05-31T12:18:00.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL库基本组成"><a href="#STL库基本组成" class="headerlink" title="STL库基本组成"></a>STL库基本组成</h1><table><thead><tr><th>STL组成</th><th>含义</th></tr></thead><tbody><tr><td>容器</td><td>封装数据结构的模板类，如vector向量容器、list列表等</td></tr><tr><td>算法</td><td>许多被设计成模板的数据结构算法在命名空间中定义，大部分包含在algorithm头文件中，少部分位于numeric头文件</td></tr><tr><td>迭代器</td><td>在C++STL中，对容器中数据的读和写，是通过迭代器完成的</td></tr><tr><td>函数对象</td><td>一个将运算符重载为成员函数的类叫函数对象类，这个类的对象就是函数对象</td></tr><tr><td>适配器</td><td>可以使一个类的接口（模板的参数适配成用户指定的形式，让本来不能在一起工作的两个类工作在一起</td></tr><tr><td>内存分配器</td><td>为容器类模板提供自定义的内存申请和释放功能</td></tr></tbody></table><p>C++标准中，STL头文件被组织为13个：</p><ul><li>iterator：定义了一些迭代器模板</li><li>functional：定义一些函数对象类型和支持函数对象的功能</li><li>vector：类似数组，需要所有元素为统一类型，定义vector容器和vector对象的操作</li><li>deque：封装双端队列，定义deque容器和deque对象操作</li><li>list：封装列表，定义list容器和list对象操作</li><li>queue：封装队列（只有一端可操作，有点栈的感觉，但先进先出），定义queue容器和queue对象操作</li><li>stack：封装堆栈，定义stack容器和stack对象操作</li><li>set：封装二叉树（红黑树），定义set对象和set对象操作</li><li>map：封装加权二叉树（红黑树），定义map对象和map对象操作</li><li>algorithm：定义多种算法，例如升降序排序、查找之类的</li><li>numeric：定义了基础性的数值算法</li><li>memory</li><li>utility</li></ul><br><h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><p>STL容器就是封装了数据结构的模板类的集合，提有三类标准容器：序列容器、排序容器和哈希容器，后两类有时也统称关联容器。</p><table><thead><tr><th>容器种类</th><th>功能</th></tr></thead><tbody><tr><td>序列容器</td><td>主要包括vector向量容器、list列表容器以及deque双端队列容器。元素在容器中的位置同元素值无关，插入元素时指定在什么位置，元素就位于什么位置。</td></tr><tr><td>排序容器</td><td>包括set集合容器、multiset多重集合容器、map映射容器、multimap多重映射容器。元素默认从小到大排列，插入元素时同样插入到合适的位置，所以在查找时具有非常好的性能。</td></tr><tr><td>哈希容器</td><td>包括4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。容器中的元素是未排序的，位置由哈希函数决定。【c++11的编译器下才能使用，VS支持，gcc/g++编译器是不支持的】</td></tr></tbody></table><h3 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h3><p>以线性排列来存储数据，且不进行排序的容器，有如下几种：</p><ul><li>array&lt;T,N&gt;（数组容器）：表示可以存储 N 个 T 类型的元素，是 C++ 本身提供的一种容器。此类容器一旦建立，其长度就是固定不变的，这意味着不能增加或删除元素，只能改变某个元素的值；</li><li>vector&lt; T &gt;（向量容器）：用来存放 T 类型的元素，是一个长度可变的序列容器，即在存储空间不足时，会自动申请更多的内存。使用此容器，在尾部增加或删除元素的效率最高（时间复杂度为 O(1) 常数阶），在其它位置插入或删除元素效率较差（时间复杂度为 O(n) 线性阶，其中 n 为容器中元素的个数）；</li><li>deque&lt; T &gt;（双端队列容器）：和 vector 非常相似，区别在于使用该容器不仅尾部插入和删除元素高效，在头部插入或删除元素也同样高效，时间复杂度都是 O(1) 常数阶，但是在容器中某一位置处插入或删除元素，时间复杂度为 O(n) 线性阶；</li><li>list&lt; T &gt;（链表容器）：是一个长度可变的、由 T 类型元素组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素（时间复杂度都为常数阶 O(1)），但访问容器中任意元素的速度要比前三种容器慢，这是因为 list&lt; T &gt; 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。</li><li>forward_list&lt; T &gt;（正向链表容器）：和 list 容器非常类似，只不过它以单链表的形式组织元素，它内部的元素只能从第一个元素开始访问，是一类比链表容器快、更节省内存的容器。</li></ul><div class="tip warning"><p>注：虽然stack< T >和queue< T >本质上也是序列容器，但都是在deque的基础上改造的，更习惯称为容器适配器</p><p></p></div><h3 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h3><p>关联式容器，包括 map、multimap、set 以及 multiset 这 4 种容器，在存储元素时会为每个元素在配备一个键，整体以键值对的方式存储到容器中。相比序列式容器，关联式容器可以通过键值直接找到对应的元素，而无需遍历整个容器。另外，关联式容器在存储元素，默认会根据各元素键值的大小做升序排序。</p><p>相比其它类型容器，关联式容器查找、访问、插入和删除指定元素的效率更高。</p><br><h2 id="STL迭代器"><a href="#STL迭代器" class="headerlink" title="STL迭代器"></a>STL迭代器</h2><p>迭代器和c++的指针非常相似，可以是任何需要的类型，通过迭代器可以指向容器中的某个元素，也可以执行读写操作。</p><p>迭代器的功能强弱决定了容器是否支持STL的某种算法。</p><p>常用迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器。</p><p>【其中输入/输出迭代器不是把数组和容器当做操作对象，而是将输入/输出流作为对象，较为特殊。】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-2">双向迭代器</button></li><li class="tab"><button type="button" data-href="#test1-3">随机访问迭代器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>已知p是一个前向迭代器，则p支持++p，p++，*p操作，可以被复制或赋值，可以用==和！=运算符进行比较，且两个正向迭代器可以相互赋值</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>具有正向迭代器的所有功能，同时具有–p或p–的操作（即一次向后移动一个位置）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>具有双向迭代器的全部功能，可以用&lt;、&gt;、&lt;=、&gt;=运算符比较，且p2-p1有意义，为p2指向元素和p1指向元素的序号差</p><p>当i为整型变量或常量时：</p><ul><li>p+=i：往后移动i个元素</li><li>p-=i：往前移动i个元素</li><li>p+i：返回p后面第i个元素的迭代器</li><li>p-i：返回p前面第i个元素的迭代器</li><li>p[i]：返回p后面第i个元素的引用</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><table><thead><tr><th>容器</th><th>对应迭代器类型</th></tr></thead><tbody><tr><td>array</td><td>随机访问迭代器</td></tr><tr><td>vector</td><td>随机访问迭代器</td></tr><tr><td>deque</td><td>随机访问迭代器</td></tr><tr><td>list</td><td>双向迭代器</td></tr><tr><td>set/multiset</td><td>双向迭代器</td></tr><tr><td>map/multimap</td><td>双向迭代器</td></tr><tr><td>forward_list</td><td>前向迭代器</td></tr><tr><td>unordered_map/unordered_multimap</td><td>前向迭代器</td></tr><tr><td>unordered_set/unordered_multiset</td><td>前向迭代器</td></tr><tr><td>stack</td><td>不支持迭代器</td></tr><tr><td>queue</td><td>不支持迭代器</td></tr></tbody></table><div class="tip warning"><p>注：容器适配器stack和queue没有迭代器，其本身具有一些成员函数，用于对元素进行访问</p><p></p></div><br><h1 id="迭代器定义方式"><a href="#迭代器定义方式" class="headerlink" title="迭代器定义方式"></a>迭代器定义方式</h1><table><thead><tr><th>定义方式</th><th>格式</th></tr></thead><tbody><tr><td>正向迭代器</td><td>::iterator 迭代器名;</td></tr><tr><td>常量正向迭代器</td><td>::const_iterator 迭代器名;</td></tr><tr><td>反向迭代器（反向迭代器适配器）</td><td>::reverse_iterator 迭代器名;</td></tr><tr><td>常量反向迭代器</td><td>::const_reverse_iterator 迭代器名;</td></tr></tbody></table><div class="tip warning"><p></p><p>注意事项：</p><ul><li>读取迭代器指向的元素使用和指针一样的方法：*迭代器名</li><li>反向迭代器和正向迭代器：正向迭代器使用p++时，迭代器指向容器中后一个元素，而反向迭代器使用p++时，迭代器指向前一个元素</li><li>常量迭代器和非常量迭代器：常量迭代器同c++中const声明是几乎一样的，所以只有通过非常量迭代器才能修改其指向的元素</li><li>如容器array、deque、vector同时支持4种，但并不是每个容器都适用以上4种定义迭代器的方式，如forward_list只支持正向迭代器而不支持反向迭代器</li></ul><p></p></div><p>以下为范例1：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;//需要引入vector头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;<span class="comment">//v被初始化为有5个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第1次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)<span class="comment">//可以通过v.size()的方式得到元素个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以像普通数组一样使用vector容器</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第2次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line"><span class="keyword">for</span> (i = v.begin(); i ！= v.end(); i++)<span class="comment">//能用v.begin()和v.end()的方式获得首末元素的地址</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//可以用*迭代器名的方式获取元素值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;第3次遍历v&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">i = v.begin();</span><br><span class="line"><span class="keyword">while</span> (i &lt; v.end())<span class="comment">//实现间隔一个元素输出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">i += <span class="number">2</span>;<span class="comment">//随机访问迭代器支持“+=整型”的操作</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上运行结果为：</p><div class="snote paperclip light"><p></p><p>第1次遍历v<br>1 2 3 4 5 6<br>第2次遍历v<br>1 2 3 4 5 6<br>第3次遍历v<br>1 3 5</p><p></p></div><div class="tip warning"><p></p><p>注：VisualStudio在调试时不会检查迭代器越界问题，但运行时系统会弹窗报错”cannot seek vector iterator after end”</p><p></p></div><br><p>以下为范例2：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 v list容器</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//创建一个常量正向迭代器，同样，list也支持其他三种定义迭代器的方式。</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator i;</span><br></pre></td></tr></table></figure><div class="note success flat"><p>以下代码合法：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i != v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用”&lt;”比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = v.begin(); i &lt; v.end(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *i;</span><br></pre></td></tr></table></figure><div class="note danger flat"><p>以下代码不合法，因为list是双向迭代器，不支持用下标随机访问比较：</p></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.size(); ++i)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[i];</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于c++实际应用中的STL库组成及迭代器详细</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="C++" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/"/>
    
    <category term="拓展" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/C/%E6%8B%93%E5%B1%95/"/>
    
    
    <category term="C++" scheme="https://zwiewings.github.io/tags/C/"/>
    
    <category term="STL库" scheme="https://zwiewings.github.io/tags/STL%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-4</title>
    <link href="https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/"/>
    <id>https://zwiewings.github.io/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/</id>
    <published>2021-05-13T07:10:39.000Z</published>
    <updated>2021-05-31T12:16:24.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>css中的盒模型相当于礼物的外包装盒，封装周围的HTML元素，包括外边距（margin），边框（border），内边距（padding）和实际内容（content），常用的div元素就是一种区块容器标记，可以将网页分隔为不同的部分，以实现网页的规划和布局。</p><p>纵深结构来说，盒模型自下而上为：外边距、背景颜色、背景图像、内边距、内容、边框</p><p><img src="/2021/05/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-4/1.PNG" alt="1"></p><div class="tip important font5 fas fa-bell"><p>css代码中的宽和高（width和height）指的是如下部分：</p><p>盒子的总宽度=width+左右内边框之和+左右边框宽度之和+左右外边距之和</p><p>盒子的总高度=height+上下内边距之和+上下边框宽度之和+上下外边框之和</p></div><br><h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><p>边框主要包括边框宽度、边框样式、边框颜色、此外还有border的综合属性，在CSS3中添加了圆角边距，图片边距属性。</p><ul><li><p>边框宽度（border-width）：用于设置元素边框的宽度值</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-width</span>：上边距宽度<span class="selector-attr">[右边距宽度 下边距宽度 左边距宽度]</span>;</span><br><span class="line"></span><br><span class="line">其中，宽度由数字和单位组成，不可为负数，常以像素（<span class="selector-tag">px</span>）为单位，且设定1个值时全部应用，设定2~3个值时，省略的部分将使用对边的样式</span><br></pre></td></tr></table></figure></li><li><p>边框样式（border-style）：用于设置样式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-style</span>：上边框样式<span class="selector-attr">[右边框样式 下边框样式 左边框样式]</span>;</span><br><span class="line"></span><br><span class="line">其中，设置时必须按上右下左的顺时针顺序，当设置1个值时为4边，2个值为上下/左右，3个值为上/左右/下，也可以通过形如<span class="selector-tag">border-left-style</span>的方式分别设置</span><br></pre></td></tr></table></figure><p>样式取值共9种，如下：</p><table><thead><tr><th>属性</th><th>含义</th><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>none</td><td>不显示边框（默认）</td><td>groove</td><td>边框带有立体感的沟槽</td></tr><tr><td>dotted</td><td>点线</td><td>ridge</td><td>边框成脊形</td></tr><tr><td>dashed</td><td>虚线</td><td>inset</td><td>使整个方框凹陷</td></tr><tr><td>solid</td><td>实线</td><td>outset</td><td>使整个方框凸起</td></tr><tr><td>double</td><td>双实线</td><td></td><td></td></tr></tbody></table></li><li><p>边框颜色（border-color）：用于定义边框的颜色</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-color</span>:上边框颜色<span class="selector-attr">[右边框颜色 下边框颜色 左边框颜色]</span>;</span><br><span class="line"></span><br><span class="line">其中，颜色值符合定义法，有十六进制<span class="selector-id">#RRGGBB</span>和<span class="selector-tag">RGB</span>代码、<span class="selector-tag">rgb</span>(<span class="selector-tag">r</span>,<span class="selector-tag">g</span>,<span class="selector-tag">b</span>)三种，仅定义几个值的样式应用方式同上两种，可以通过形如<span class="selector-tag">border-left-color</span>的方式分别定义，（上使用<span class="selector-tag">top</span>，下使用<span class="selector-tag">bottom</span>）</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>边框综合属性（border）</p><p>border为复合属性，前三者的简写方式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">border&lt;边框宽度&gt;|&lt;边框样式&gt;|&lt;颜色&gt;;</span><br><span class="line"></span><br><span class="line">在复合属性中，边框<span class="selector-tag">border</span>同时设置4条边，如只需要1条边框应用该样式，需要通过形如<span class="selector-tag">border-left</span>的方式分别设置</span><br></pre></td></tr></table></figure></li></ul><h2 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h2><h3 id="内边距（padding）"><a href="#内边距（padding）" class="headerlink" title="内边距（padding）"></a>内边距（padding）</h3><p>主要用于调整内容在盒子中的值，指内容content和边框border的距离，也被称作内填充。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>:上内边距值<span class="selector-attr">[右内边距值 下内边距值 左内边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>边距值为数字和单位组成，不可为负值，常用像素（px）为单位，也可以是百分比，随父元素width变化而变化，和height无关</li><li>padding遵循复制原则，也可以通过形如padding-left的方式设置样式</li></ul><h3 id="外边距（margin）"><a href="#外边距（margin）" class="headerlink" title="外边距（margin）"></a>外边距（margin）</h3><p>margin指元素边框和相邻元素之间的距离（盒子和盒子的距离）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>:上外边距值<span class="selector-attr">[右外边距值 下外边距值 左外边距值]</span>;</span><br></pre></td></tr></table></figure><ul><li>margin为复合属性，同padding用法类似，但可以使用负值，使相邻元素重叠，若盒元素使用了宽度属性，设margin为auto时，可以实现盒元素居中</li><li>margin也遵循复制原则，可通过形如margin-left的方式设置样式</li></ul>]]></content>
    
    
    <summary type="html">关于CSS盒模型的运用</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="网页设计" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="css" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/css/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-6</title>
    <link href="https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/"/>
    <id>https://zwiewings.github.io/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</id>
    <published>2021-04-27T12:46:05.000Z</published>
    <updated>2021-05-31T12:19:22.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul><li>树：一个有限集，可以为空，非空时有且只有一个根结点，其余结点可以分为多个不相交的有限集（子树）</li><li>结点的度：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶子结点：度为0的结点</li><li>父结点：有子树的结点是其子树的根节点的父结点</li><li>子结点/孩子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点</li><li>兄弟结点：具有同一个父结点的各结点彼此是兄弟结点</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk。ni是ni+1的父结点。路径所包含边的个数为路径的长度</li><li>祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li><li>子孙结点：某一结点的子树中的所有结点是这个结点的子孙</li><li>结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>二叉树：一个有穷的结点集合。这个集合可以为空；若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。</p><p><strong>二叉树的五种基本形态：</strong></p><p>斜二叉树：只有左子节点或只有右子节点的二叉树，度为1，只有左子节点或右子节点</p><p>满二叉树/ 完美二叉树：除最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树</p><p>完全二叉树：有n个结点的二叉树，对树中结点从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中的位置相同（能和满二叉树完全重叠，编号相同）</p><p><strong>按从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：（顺序存储）</strong></p><ul><li>根结点的序号为1</li><li>非根结点（序号i&gt;1）的父结点的序号是：i / 2</li><li>结点（序号为i）的左孩子结点的序号是：2 * i，若2*i &gt; n，则没有左孩子</li><li>结点（序号为i）的右孩子结点的序号是：2 * i + 1，若2*i+1 &gt; n，则没有右孩子</li></ul><p><strong>普遍规律：</strong></p><p>一个二叉树第i层的最大结点数为：2i-1，i≥1</p><p>深度为k的二叉树有最大结点总数为：2k-1，k≥1</p><p>对任何非空二叉树T，叶结点个数为n0，度为1的结点个数为n1，度为2的结点个数为n2，则二叉树的总边数：N=2*n2+n1，总结点数：N′=n0+n1+n2，总叶子结点数：n0=n2+1</p><p><strong>二叉树的三种遍历：</strong></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/1.png" alt="1"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/2.png" alt="2"></p><p><img src="/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/3.png" alt="3"></p><h3 id="二叉树操作"><a href="#二叉树操作" class="headerlink" title="二叉树操作"></a>二叉树操作</h3><h4 id="创建-初始化"><a href="#创建-初始化" class="headerlink" title="创建/初始化"></a>创建/初始化</h4><p>由于树的顺序表结构分配的空间通常只适用于完全二叉树，会造成普通二叉树的空间浪费，所以二叉树一般使用链式结构存储</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span>&#123;</span></span><br><span class="line">Elemtype data;<span class="comment">//二叉树的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">left</span>;</span><span class="comment">//二叉树的左指针，指向左子树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTnode</span> *<span class="title">Right</span>;</span><span class="comment">//二叉树的右指针，指向右子树</span></span><br><span class="line">&#125;*BTree;</span><br></pre></td></tr></table></figure><p>由于二叉树用递归算法较快，涉及到的先序、中序、后序三种输入方式时，只需要调整根节点的输入顺序即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">Create</span><span class="params">(BTree &amp;T)</span><span class="comment">//传入要操作的结点T</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elemtype a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="literal">NULL</span>;<span class="comment">//当输入为“#”时，判断二叉树创建完毕，结束递归</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        T=<span class="keyword">new</span> BTnode;<span class="comment">//创建一个新的二叉树结点</span></span><br><span class="line">        T-&gt;data=a;<span class="comment">//设置数据域为输入值</span></span><br><span class="line">        Create(T-&gt;left);<span class="comment">//递归创建T的左子树</span></span><br><span class="line">        Create(T-&gt;right);  <span class="comment">//递归创建T的右子树</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>在创建的时候，相当于也就遍历了一次二叉树，故而除却赋值之外的结构都十分相似,而且由于二叉树已经建立，可以通过二叉树的结点指针是否为空判断遍历是否结束</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下位置遍历的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//如果T为空，则结束遍历</span></span><br><span class="line">&#123;</span><br><span class="line">Traverse(T-&gt;left);<span class="comment">//递归遍历T的左子树</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">//输出T结点的数据</span></span><br><span class="line">Traverse(T-&gt;right);<span class="comment">//递归遍历T的右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算深度"><a href="#计算深度" class="headerlink" title="计算深度"></a>计算深度</h4><p>二叉树深度为左右子树中深度较大者加1，故而需要递归求取左右子树的深度，再比较后加1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(BTree T)</span><span class="comment">//传入需要往下求取深度的根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(T=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//当递归到叶子结点时，结束递归</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m=depth(T-&gt;left);<span class="comment">//将左子树的深度存入m</span></span><br><span class="line">        n=depth(T-&gt;right);<span class="comment">//将右子树的深度存入n</span></span><br><span class="line">        <span class="keyword">if</span>(m&gt;n) <span class="keyword">return</span> (m+<span class="number">1</span>);<span class="comment">//如果左子树深度大于右子树则返回m+1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (n+<span class="number">1</span>);<span class="comment">//反之，返回n+1</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>线索二叉树将二叉树中空置的左右指针域利用起来，存储沿某种顺序遍历二叉树后继结点的地址，比二叉树多设置左右标志，当标志为1（true）时，表示有对应的子节点（左标志为1，左指针域存储左孩子的地址），否则对应指针域则存储某种顺序遍历二叉树时的下一个结点的地址</p><p><strong>其中，左指针域为线索时，指向前驱，右指针域为线索时指向后继</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DBTnode</span> *<span class="title">left</span>,*<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> ltag,rtag;</span><br><span class="line">&#125;*DBTree;</span><br></pre></td></tr></table></figure><h4 id="二叉树中序线索化"><a href="#二叉树中序线索化" class="headerlink" title="二叉树中序线索化"></a>二叉树中序线索化</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBTnode *p;<span class="comment">//p为全局变量，是指向线索二叉树结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dchild</span><span class="params">(DBTree T)</span><span class="comment">//以T为根的子树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)<span class="comment">//当T不为空时</span></span><br><span class="line">&#123;</span><br><span class="line">Dchild(T-&gt;left);<span class="comment">//将左子树递归线索化</span></span><br><span class="line"><span class="keyword">if</span>(!T-&gt;left)<span class="comment">//如果左指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">T-&gt;ltag=<span class="literal">false</span>;<span class="comment">//则左标志为false，表示左指针域为线索指针域</span></span><br><span class="line">T-&gt;left=p;<span class="comment">//左指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> T-&gt;ltag=<span class="literal">true</span>;<span class="comment">//否则左标志为true，表示左指针域指向左孩子</span></span><br><span class="line"><span class="keyword">if</span>(!p-&gt;right)<span class="comment">//如果p的右指针域为空</span></span><br><span class="line">&#123;</span><br><span class="line">p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//则右标志为false，表示右指针域为线索指针域</span></span><br><span class="line">p-&gt;right=p1;<span class="comment">//右指针域作为线索指针域，指向其前驱p</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> p-&gt;rtag=<span class="literal">true</span>;<span class="comment">//否则右标志为true，表示右指针域指向右孩子</span></span><br><span class="line">p=T;<span class="comment">//p指向子树的根节点处</span></span><br><span class="line">Dchild(p-&gt;right);<span class="comment">//将右子树递归线索化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DOchild</span><span class="params">(DBTree &amp;T,DBTree D)</span><span class="comment">//带头结点的二叉树中序线索化的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T=<span class="keyword">new</span> DBTnode;<span class="comment">//创建头结点</span></span><br><span class="line">    T-&gt;Ltag=<span class="literal">true</span>;<span class="comment">//若树非空，则头结点的左孩子为树根，左标志为true</span></span><br><span class="line">    T-&gt;rtag=<span class="literal">false</span>;<span class="comment">//头结点没有右孩子，右标志为false</span></span><br><span class="line">    T-&gt;right=T;<span class="comment">//初始化时，头结点的右指针域指向自己</span></span><br><span class="line">    <span class="keyword">if</span>(!T) T-&gt;left=T;<span class="comment">//若树空，则头结点的左指针也指向自己</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">    T-&gt;left=D;<span class="comment">//否则，头结点的左指针域指向原二叉树的根节点D</span></span><br><span class="line">        p=T;<span class="comment">//p指向原二叉树根节点D的前驱</span></span><br><span class="line">        Dchild(D);<span class="comment">//递归线索化二叉树D</span></span><br><span class="line">        p-&gt;right=T;<span class="comment">//递归线索化后，p指向中序遍历的最后一个结点，右指针域指向头结点</span></span><br><span class="line">        p-&gt;rtag=<span class="literal">false</span>;<span class="comment">//p指向结点的右标志为false，表示没有右孩子</span></span><br><span class="line">        T-&gt;right=p;<span class="comment">//将头结点的右指针域指向p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历中序线索二叉树-非递归"><a href="#遍历中序线索二叉树-非递归" class="headerlink" title="遍历中序线索二叉树(非递归)"></a>遍历中序线索二叉树(非递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OTraverse</span><span class="params">(DBTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p=T-&gt;left;<span class="comment">//p指向头结点的左孩子，即二叉树的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)<span class="comment">//当树空或遍历结束时，将有p==T，结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="literal">true</span>) <span class="comment">//当左标志为false时，即直到没有左孩子时结束循环</span></span><br><span class="line">            p=p-&gt;left;<span class="comment">//p沿左子树向下遍历</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//输出左子树为空的结点的值</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag==<span class="literal">false</span>&amp;&amp;p-&gt;right!=T)<span class="comment">//当右标志为true，即有右孩子且p的后继不是头结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;right;<span class="comment">//p沿右子树向下遍历</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data;<span class="comment">//沿右子树访问后继结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;right;<span class="comment">//转向p的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于树与二叉树的概念说明，以及二叉树的创建/初始化、遍历、深度计算等代码实现</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5</title>
    <link href="https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/"/>
    <id>https://zwiewings.github.io/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</id>
    <published>2021-04-26T11:52:16.000Z</published>
    <updated>2021-05-31T12:19:12.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串类型"><a href="#串类型" class="headerlink" title="串类型"></a>串类型</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>串的存储结构可以使用顺序和链式结构，顺序结构中又分为定长和堆式存储结构，但由于链式不如顺序结构灵活，操作简单，故而此处只写入顺序结构</p><h3 id="顺序-定长存储"><a href="#顺序-定长存储" class="headerlink" title="顺序-定长存储"></a>顺序-定长存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> ch[maxsize+<span class="number">1</span>];<span class="comment">//定义字符数组，串的最大长度为maxsize，多申请防止溢出的存储空间</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;Sstring;</span><br></pre></td></tr></table></figure><h3 id="顺序-堆式存储"><a href="#顺序-堆式存储" class="headerlink" title="顺序-堆式存储"></a>顺序-堆式存储</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;<span class="comment">//如果是非空串，则按串长分配存储区，否则ch指向NULL;</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>串的模式匹配用于在主串中寻找子串，如果匹配成功，则确定相匹配的子串中第一个字符在主串s中出现的位置</p><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_BF</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i=i-j+<span class="number">1</span>;<span class="comment">//否则，i回到开始匹配的位置（执行for语句的i++后移到下一个位置</span></span><br><span class="line">            j=<span class="number">0</span>;<span class="comment">//j被重置为0（然后执行for语句的j++后变为j=1）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(Sstring s,Sstring t,<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=pos,j=<span class="number">1</span>;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)</span><br><span class="line">        <span class="comment">//初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||s.ch[i]==t.ch[i])<span class="comment">//当主串s中i位置的字符和子串t中j位置的字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//继续下一次循环，即只执行for语句的i++，j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];<span class="comment">//KMP相比BF算法节省时间的原因</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;t.length) <span class="keyword">return</span> i-t.length;</span><br><span class="line">    <span class="comment">//当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//否则返回0，表示没有匹配成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(Sstring t,<span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function">    <span class="comment">//求子串t的next函数值并且存进数组next</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,i=<span class="number">1</span>,next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义i，j，以及next数组的第一个值</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;t.length;)<span class="comment">//i不超过子串t长度时循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||t.ch[i]==t.ch[j])<span class="comment">//如果j为0或是前后两个字符相同时</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(t.ch[i]!=t.ch[j])<span class="comment">//如果前后两个字符不相同</span></span><br><span class="line">                next[i]=j;<span class="comment">//令下次比较从j开始</span></span><br><span class="line">            <span class="keyword">else</span> next[i]=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j=next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组的顺序存储"><a href="#二维数组的顺序存储" class="headerlink" title="二维数组的顺序存储"></a>二维数组的顺序存储</h2><p>已知一维数组中a【i】的存储位置在a+i处，二维数组因主序不同分为两种存储结构（常用行序）</p><p>设每个数据元素占L个存储单元，则二维数组A[0…m-1,0…n-1]（下标从0开始，共有m行n列）中任一元素a【i】【j】的存储位置如下：</p><p><strong>行为主序的存储结构</strong>：</p><p>$$<br>LOC(i , j) = LOC(0 , 0) + (n * i + j) L<br>$$<br><strong>列为主序的存储结构：</strong><br>$$<br>LOC(i , j) = LOC(0 , 0) + (m * j + i) L<br>$$<br>其中，LOC(i,j)是a【i】【j】的存储位置</p><p>LOC（0，0）是a【0】【0】的存储位置，即二维数组A的起始存储位置、也称为基地址或基址</p><p><strong>故而总结可知：</strong><br>$$<br>LOC(i , j) = 基址 + (副序长度 * 主序标号 + 另一标号) * 数据所占存储单元<br>$$</p><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>特点：在n*n的矩阵a中，1&lt;= i，j &lt;= n<br>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。</p><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/1.png" alt="1"></p><p>上下三角中的元素均为：n(n+1) / 2<br>可以以行序为主序将元素存放在一个一维数组a[n(n+1) / 2]中，a[k]的位置可如下公式确定<br>$$<br>k=主序序号（主序序号-1）/2+副序序号-1，主序&gt;=副序<br>$$<br>注：上式的k从0开始计算</p><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/2.png" alt="2"></p><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-1.png" alt="3-1"></p><h3 id><a href="#" class="headerlink" title></a><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-2.png" alt="3-2"></h3><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/4.png" alt="4"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>一般记作LS（a1，a2，……，an），其中LS为广义表的名称，n为广义表的长度，其中的元素可以是单个数据（原子）也可以是广义表（子表），一般小写为原子，大写为子表</p><p><strong>广义表示例：</strong></p><ul><li>A=（）——空表，长度为0</li><li>B=（e）——只有一个原子，为e，长度为1</li><li>C=（a，（b，c，d））——有一个原子a和一个子表（b，c，d），共两个元素，长度为2</li><li>D=（A，B，C）——有三个子表，即三个元素，长度为3</li><li>E=（a，E）——一个递归的表，长度为2</li></ul><p>注：广义表A=（（））和广义表B=（）是不相同的，A为有一个空子表，长度为1的广义表，而B是一个空表，长度为0</p>]]></content>
    
    
    <summary type="html">关于串的存储结构、模式匹配算法与数组的特殊存储以及广义表的说明</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://zwiewings.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-3</title>
    <link href="https://zwiewings.github.io/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/"/>
    <id>https://zwiewings.github.io/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/</id>
    <published>2021-04-22T07:00:56.000Z</published>
    <updated>2021-05-31T12:16:16.893Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="css格式定义"><a href="#css格式定义" class="headerlink" title="css格式定义"></a>css格式定义</h3><p>css样式设置由选择器和声明部分组成，示例如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器类型&#123;</span><br><span class="line">属性1:值1;</span><br><span class="line">属性2:值2;</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，作为分隔每个属性的标志，最末尾的属性后的分号可以省略，但规范上是不省略的</p><h3 id="css样式调用"><a href="#css样式调用" class="headerlink" title="css样式调用"></a>css样式调用</h3><p>分为：行内样式表，内部样式表，链入外部样式表</p><p>以下为链入外部样式表的两种方法：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">方法1：<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;相对地址&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheeet&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">方法2：<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@import</span> url(<span class="string">&quot;相对地址&quot;</span>);</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：也可以在当前网页内以css的方式写入本网页的样式（如行内样式表和内部样式表），但是该样式仅作用于该网页，而且夹杂于内容中，故不推荐使用</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器：p、hn等标签"><a href="#标签选择器：p、hn等标签" class="headerlink" title="标签选择器：p、hn等标签"></a>标签选择器：p、hn等标签</h3><p>代表该标签的共性，用css修改时，将会作用于当前网页所有该标签</p><p>调用方式：直接使用定义的标签</p><p>选择器类型：指定的标签名字</p><h3 id="类选择器：以-开头"><a href="#类选择器：以-开头" class="headerlink" title="类选择器：以.开头"></a>类选择器：以.开头</h3><p>把相同类型的元素分类定义成不同的样式，用css修改时，将改变这一类的所有元素样式</p><p>调用方式：class=”类选择器的名字”（多个效果可用空格隔开）</p><p>选择器类型：.类选择器名</p><p><strong>注意：</strong></p><ul><li>不要试图用一个类名，把某个标签的所有样式写完，一个标签应该多携带几个类</li><li>每个类要尽可能的小，以达到公共性</li></ul><h3 id="id选择器：以-开头"><a href="#id选择器：以-开头" class="headerlink" title="id选择器：以#开头"></a>id选择器：以#开头</h3><p>代表某一元素的个性，用css修改时，只改变当前元素的样式</p><p>调用方式：id=”id选择器的名字”</p><p>选择器类型：#id选择器的名字</p><p>注：id选择器在文档中只能使用一次，而类选择器可以使用多次</p><h3 id="通配符选择器：“-”"><a href="#通配符选择器：“-”" class="headerlink" title="通配符选择器：“*”"></a>通配符选择器：“*”</h3><p>作用于所有的标签样式，用css修改时会改变所有使用该css的网页样式</p><p>使用方式：不需要调用，在css文件链接时直接附加</p><h3 id="群组选择器-并集选择器：“-”"><a href="#群组选择器-并集选择器：“-”" class="headerlink" title="群组选择器/并集选择器：“,”"></a>群组选择器/并集选择器：“,”</h3><p>表达“或”的含义，部分样式相同或完全相同时使用</p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名1,标签名2,……&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="标签指定式选择器-交集选择器"><a href="#标签指定式选择器-交集选择器" class="headerlink" title="标签指定式选择器/交集选择器"></a>标签指定式选择器/交集选择器</h3><p>表达“和”的含义，同时使用标签选择器和类选择器或者同时使用标签选择器和id选择器</p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签名.类名&#123;属性表&#125;</span><br><span class="line">标签名#id&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="包含选择器-后代选择器"><a href="#包含选择器-后代选择器" class="headerlink" title="包含选择器/后代选择器"></a>包含选择器/后代选择器</h3><p>选择元素或元素组的后代，也称后代选择器，把外层标签写在前面，内层标签写在后面，中间用空格分隔</p><p>使用方式：（两个选择器中间必须有空格）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选择器1 选择器2&#123;属性表&#125;</span><br></pre></td></tr></table></figure><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>为拥有指定属性的html元素设置样式，不局限于class和id属性，下表以attribute代替属性选择器名</p><table><thead><tr><th align="center">选择器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[attribute]</td><td align="center">选取带有指定属性的元素</td></tr><tr><td align="center">[attribute=value]</td><td align="center">选取带有指定属性且取值为value的元素</td></tr><tr><td align="center">[attribute~=value]</td><td align="center">选取属性值中包含指定词汇的元素</td></tr><tr><td align="center">[attribute|=value]</td><td align="center">选取带有指定值开头的属性值的元素，值必须是整个单词</td></tr><tr><td align="center">[attribute^=value]</td><td align="center">匹配属性值以指定值开头的每个元素</td></tr><tr><td align="center">[attribute$=value]</td><td align="center">匹配属性值以指定值结尾的每个元素</td></tr><tr><td align="center">[attribute]*=value]</td><td align="center">匹配属性值中包含指定值的每个元素</td></tr></tbody></table><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标签名[属性选择器名]&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">选择器为<span class="selector-attr">[attribute]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here]</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">选择器为<span class="selector-attr">[attribute=value]</span>类型时：</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[here=red]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><p>主要包括子元素选择器，相邻兄弟选择器，普通兄弟选择器</p><table><thead><tr><th align="center">属性名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">子元素选择器（E&gt;F）</td><td align="center">选择所有作为E元素的<strong>直接子元素</strong>F，对更深一层的元素不起作用</td></tr><tr><td align="center">兄弟相邻选择器（E+F)</td><td align="center">选择<strong>紧跟</strong>在E元素<strong>后面</strong>的F元素，选择相邻的第一个兄弟元素</td></tr><tr><td align="center">普通兄弟选择器（E~F）</td><td align="center">选择E元素之后的<strong>所有</strong>兄弟元素F，作用于多个元素</td></tr></tbody></table><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">子元素选择器：</span><br><span class="line">标签名&gt;子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签内，直接子元素的<span class="selector-tag">a</span>标签都为红色</span><br><span class="line"></span><br><span class="line">兄弟相邻选择器：</span><br><span class="line">标签名+子元素标签名&#123;属性表&#125;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签同级的紧挨的下一个<span class="selector-tag">a</span>标签为红色</span><br><span class="line"></span><br><span class="line">普通兄弟选择器：</span><br><span class="line">标签名~子元素标签名&#123;属性表&#125;</span><br><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line">实现效果为<span class="selector-tag">div</span>标签后的所有同级的<span class="selector-tag">a</span>标签都是红色</span><br></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="超链接伪类选择器"><a href="#超链接伪类选择器" class="headerlink" title="超链接伪类选择器"></a>超链接伪类选择器</h4><table><thead><tr><th align="center">伪类名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">a:link</td><td align="center">未访问时的超链接状态</td></tr><tr><td align="center">a:visited</td><td align="center">访问后的超链接的状态（也可用于普通非链接元素:visited）</td></tr><tr><td align="center">a:hover</td><td align="center">鼠标经过、悬停时超链接的状态</td></tr><tr><td align="center">a:active</td><td align="center">鼠标单击不动时超链接的状态（也可用于普通非链接元素:active）</td></tr></tbody></table><p><strong><em>注：</em></strong></p><ul><li><strong><em>样式必须符合link、visited、hover、active顺序</em></strong></li><li><strong><em>在css定义中，a:hover必须被置于a:link和a:visited后才有效</em></strong></li><li><strong><em>a:active必须被置于a:hover之后才有效</em></strong></li></ul><p>使用方法：（以a:link和h1为例）</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">a:link&#123;属性表&#125;       &lt;!--超链接伪类选择器--&gt;</span><br><span class="line">h1:hover&#123;属性表&#125;  &lt;!--普通非链接元素伪类选择器--&gt;</span><br></pre></td></tr></table></figure><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:root</td><td align="center">将样式绑定到页面的根元素中（即指位于文档树中最顶层结构的html标签）</td></tr><tr><td align="center">:not</td><td align="center">用于选择除某个元素之外的所有元素</td></tr><tr><td align="center">:empty</td><td align="center">指定当元素内容为空白时使用的样式</td></tr><tr><td align="center">:target</td><td align="center">对页面中某个target元素指定样式，只在用户点击链接并跳转到target元素后生效</td></tr></tbody></table><p>其中，:target使用时，前面不需要添加标签名，在锚点跳转后应用于跳转到的位置</p><h4 id="子元素伪类选择器"><a href="#子元素伪类选择器" class="headerlink" title="子元素伪类选择器"></a>子元素伪类选择器</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>:first-child</td><td>对父元素中的第一个子元素指定样式</td></tr><tr><td>:last-child</td><td>对父元素中的最后一个子元素指定样式</td></tr><tr><td>:only-child</td><td>当某个父元素中只有一个子元素时使用的样式</td></tr><tr><td>:nth-child(n)</td><td>对指定序号的子元素设置样式（正数），表示第几个子元素</td></tr><tr><td>:nth-last-child(n)</td><td>对指定序号的子元素设置样式（正数），表示倒数第几个子元素</td></tr><tr><td>:nth-child(even)</td><td>所有正数第偶数个子元素，等同于:nth-child(2n)</td></tr><tr><td>:nth-child(odd)</td><td>所有正数第奇数个子元素，等同于:nth-child(2n+1)</td></tr><tr><td>:nth-last-child(even)</td><td>所有倒数第偶数个子元素</td></tr><tr><td>:nth-last-child(odd)</td><td>所有倒数第奇数个子元素</td></tr><tr><td>:nth-of-type(n)</td><td>用于匹配属于父元素的特定类型的第n个子元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>用于匹配属于父元素的特定类型的倒数第n个子元素</td></tr></tbody></table><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是针对css中已经定义的伪元素使用的选择器，css中主要使用的伪元素为“:before”伪元素选择器和”:after”伪元素选择器</p><h4 id="before伪元素选择器"><a href="#before伪元素选择器" class="headerlink" title=":before伪元素选择器"></a>:before伪元素选择器</h4><p>用于在被选元素的内容前面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>element表示元素，“{}”中的content属性用来指定要插入的具体内容，既可以为文本也可以为图片</p><h4 id="after伪元素选择器"><a href="#after伪元素选择器" class="headerlink" title=":after伪元素选择器"></a>:after伪元素选择器</h4><p>用于在被选元素内容的后面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:文字/<span class="built_in">url</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>如果子元素定义的样式没有和父元素冲突，那么将继承父元素的样式，可以再加以修改，并不会影响父元素</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，strong标签为em标签的父元素，em标签为strong标签的子元素</p><p><strong><em>注：</em></strong></p><ul><li><strong><em>实际开发中，通常对使用较多的字体、文本属性使用继承，在body中统一设置字体、字号、颜色、行距等</em></strong></li><li><strong><em>文本属性（如color、font-类等）具有继承性，但对于元素的布局属性、盒模型属性（如背景属性、边框属性、外边距属性、内边距属性、定位属性、布局属性、元素宽高属性等）都不能继承</em></strong></li></ul><h2 id="优先级说明"><a href="#优先级说明" class="headerlink" title="优先级说明"></a>优先级说明</h2><h3 id="基本优先级"><a href="#基本优先级" class="headerlink" title="基本优先级"></a>基本优先级</h3><ul><li>各种选择器不冲突时将全部应用</li><li>某些选择器冲突时，冲突部分将会以行内样式&gt;id选择器&gt;class选择器&gt;标签选择器的顺序优先应用</li><li>优先级相同时，在冲突部分，后定义的选择器内容将覆盖前面的选择器</li></ul><h3 id="优先级修改"><a href="#优先级修改" class="headerlink" title="优先级修改"></a>优先级修改</h3><p>在使用时，可以用!important关键字将某个选择器的优先级提到最高，但一般还是建议统筹设计</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:blue <span class="meta">!important</span>;</span><br><span class="line"><span class="attribute">font-style</span>:italic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，p标签中的颜色被设定成了最高优先级，如果p标签的字体颜色样式与其他选择器冲突，则优先运用p标签中定义的“blue”</p><h3 id="权值计算"><a href="#权值计算" class="headerlink" title="权值计算"></a>权值计算</h3><p>如果用具体的权值描述样式的优先级，优先级从低到高如下排列：</p><ol><li>继承样式——0分</li><li>标签选择器——1分</li><li>伪元素或对象选择器——1分</li><li>类选择器——10分</li><li>属性选择器——10分</li><li>id选择器——100分</li><li>行内样式——1000分</li><li>！important——无穷大</li></ol>]]></content>
    
    
    <summary type="html">关于h5网页与css联合使用时，css文件的基础书写说明</summary>
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="网页设计" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="css" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/css/"/>
    
    
    <category term="网页设计" scheme="https://zwiewings.github.io/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>UE4-6</title>
    <link href="https://zwiewings.github.io/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/"/>
    <id>https://zwiewings.github.io/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/</id>
    <published>2021-04-17T14:12:16.000Z</published>
    <updated>2021-06-02T00:29:56.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚步声与相机晃动"><a href="#脚步声与相机晃动" class="headerlink" title="脚步声与相机晃动"></a>脚步声与相机晃动</h1><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>实现角色在默认地板、木质地板和金属地板上的不同脚步声以及行走时的相机晃动</p><h2 id="函数写入位置"><a href="#函数写入位置" class="headerlink" title="函数写入位置"></a>函数写入位置</h2><p>全局函数库、玩家角色蓝图</p><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h3><p>创建相机晃动（下图为参考数值），需要勾上单一实例，保证每次使用只晃动一次</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/1.png" alt="1"></p><h3 id="脚步声"><a href="#脚步声" class="headerlink" title="脚步声"></a>脚步声</h3><ol><li><p>导入材质、脚步声</p></li><li><p>创建物理材质，表面类型需要在项目设置中先添加再修改，以下为项目设置界面</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/3.png" alt="3"></p></li><li><p>以其中一个音频为基础创建cue，并添加随机节点，实现多个同类音频随机播放（毕竟脚步声不可能每一步都是同一个声音），如图示例</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/2.png" alt="2"></p></li></ol>]]></content>
    
    
    <summary type="html">游戏场景细节制作及更多功能实现（未完）</summary>
    
    
    
    <category term="课外拓展" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/UE4/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>UE4-5</title>
    <link href="https://zwiewings.github.io/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/"/>
    <id>https://zwiewings.github.io/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/</id>
    <published>2021-04-16T13:07:44.000Z</published>
    <updated>2021-06-02T00:29:48.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚幻文件夹结构"><a href="#虚幻文件夹结构" class="headerlink" title="虚幻文件夹结构"></a>虚幻文件夹结构</h1><h2 id="本地工程文件夹"><a href="#本地工程文件夹" class="headerlink" title="本地工程文件夹"></a>本地工程文件夹</h2><p>惯例为【Config】、【Content】、【DerivedDataCache】、【Intermediate】、【Saved】、【Script】六个文件夹，和一个后缀名为.uproject的文件（该文件为工程本体，在引擎中打开工程使用该文件）</p><h3 id="【Config】"><a href="#【Config】" class="headerlink" title="【Config】"></a>【Config】</h3><h3 id="【Content】"><a href="#【Content】" class="headerlink" title="【Content】"></a>【Content】</h3><h3 id="【DerivedDataCache】"><a href="#【DerivedDataCache】" class="headerlink" title="【DerivedDataCache】"></a>【DerivedDataCache】</h3><h3 id="【Intermediate】"><a href="#【Intermediate】" class="headerlink" title="【Intermediate】"></a>【Intermediate】</h3><h3 id="【Saved】"><a href="#【Saved】" class="headerlink" title="【Saved】"></a>【Saved】</h3><h3 id="【Script】"><a href="#【Script】" class="headerlink" title="【Script】"></a>【Script】</h3><h2 id="导入素材文件夹"><a href="#导入素材文件夹" class="headerlink" title="导入素材文件夹"></a>导入素材文件夹</h2><p>惯例为【Animations】、【Materials】、【Meshes】、【Map（Scenes）】、【Textures】五个文件夹，有时也有会将【Materials】、【Textures】、【Meshes】放在一个【character】文件夹下的构成</p><h3 id="【Animations】"><a href="#【Animations】" class="headerlink" title="【Animations】"></a>【Animations】</h3><p>【Animations】为该素材包内包括的动画序列，根据固定的骨骼执行，执行动画的网格体可以替换预览并实际替换使用</p><h3 id="【Materials】"><a href="#【Materials】" class="headerlink" title="【Materials】"></a>【Materials】</h3><p>【Materials】为该素材包内所用到的所有材质，一般通过【材质】蓝图修改或直接使用</p><h3 id="【Meshes】"><a href="#【Meshes】" class="headerlink" title="【Meshes】"></a>【Meshes】</h3><p>【Meshes】为该素材包内用到的所有骨架模型（骨骼网格体）、物理模型（物理资产）、骨骼，骨架模型是没有碰撞体积的，而物理模型能够表现受力（例如场景中运行时会受重力，和玩家角色重叠时会发生移动）</p><h3 id="【Map（scenes）】"><a href="#【Map（scenes）】" class="headerlink" title="【Map（scenes）】"></a>【Map（scenes）】</h3><p>【Map（Scenes）】为该素材包的场景地图，一般会有一个Overview场景，用于预览所有模型，动画，地形等该素材包的素材</p><h3 id="【Textures】"><a href="#【Textures】" class="headerlink" title="【Textures】"></a>【Textures】</h3><p>【Textures】为该素材包的所有贴图，包括材质贴图，法线贴图，场景贴花等，通常在【材质】蓝图中找到需要更改的属性，再对应的更改贴图以达到更改材质的效果</p><p><br><br></p><h1 id="Android端配置"><a href="#Android端配置" class="headerlink" title="Android端配置"></a>Android端配置</h1><p>Android端使用的虚幻引擎版本为4.22.3,下载时需要勾选以下内容</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/1.png" alt="1"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/2.png" alt="2"></p><p>具体使用时，创建工程需要选中“移动设备/平板电脑”一项</p><h2 id="项目设置修改"><a href="#项目设置修改" class="headerlink" title="项目设置修改"></a>项目设置修改</h2><p>为了顺利打包成apk格式，需要工程的项目设置提前修改，具体修改项如下：</p><br><h3 id="Android项"><a href="#Android项" class="headerlink" title="Android项"></a>Android项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-1.png" alt="3-1"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-2.png" alt="3-2"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-3.png" alt="3-3"></p><p>其中修改project为工程名时，不需要保留括号，必须为英文，且不能有特殊符号</p><br><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-4.png" alt="3-4"></p><p>此处填入手机上app显示的名字，可以为中文</p><br><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-5.png" alt="3-5"></p><p>此处勾选，引擎打包后生成出来为单独的一个apk格式文件</p><br><p>icons项为图标，悬停可以显示图片大小，此处不作说明</p><br><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-6.png" alt="3-6"></p><p>app默认开始时有淡入淡出显示logo的界面，不需要的话，可以取消勾选</p><br><h3 id="Android-SDK项"><a href="#Android-SDK项" class="headerlink" title="Android SDK项"></a>Android SDK项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-7.png" alt="3-7"></p><p>此处是Android应用需要的编译环境配置，路径应为全英文路径，以免报错（本文“附加内容”中提供下载地址）</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-8.png" alt="3-8"></p><br><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-9.png" alt="3-9"></p><h3 id="Rendering项"><a href="#Rendering项" class="headerlink" title="Rendering项"></a>Rendering项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-10.png" alt="3-10"></p><p>以下配置是给一个简单手机应用的配置，所以均为最低画质</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-11.png" alt="3-11"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-12.png" alt="3-12"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-13.png" alt="3-13"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-14.png" alt="3-14"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-15.png" alt="3-15"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-16.png" alt="3-16"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/3-17.png" alt="3-17"></p><h3 id="Packaging项"><a href="#Packaging项" class="headerlink" title="Packaging项"></a>Packaging项</h3><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-1.png" alt="4-1"></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-2.png" alt="4-2"></p><p>其中，以下路径为打包项目的输出位置：</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-4.png" alt="4-4"></p><p><br><br></p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-3.png" alt="4-3"></p><br><p>以下修改需要展开隐藏项</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-5.png" alt="4-5"></p><h2 id="编译打包"><a href="#编译打包" class="headerlink" title="编译打包"></a>编译打包</h2><p>完成以上配置后，即可运行完成编译，进行打包</p><p>注：在尝试打包之前记得先保存默认地图，如果文件夹空置的话会报错（报错信息有“gradle\rungradle.bat :app:assembleDebug”字样）</p><p><img src="/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/4-6.png" alt="4-6"></p><h1 id="附带内容"><a href="#附带内容" class="headerlink" title="附带内容"></a>附带内容</h1><p>此处提供相关文件下载，度盘提取码：wing</p><div class="btns rounded grid5">            <a href="https://pan.baidu.com/s/1D90KkjFeJfrMZAsXmpNxcw" title="Android SDK"><i class="fa fa-download"></i>Android SDK</a>          </div>]]></content>
    
    
    <summary type="html">虚幻引擎本地工程文件夹、素材文件夹结构和Android端虚幻引擎配置（未完）</summary>
    
    
    
    <category term="课外拓展" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/UE4/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>Java基础-1</title>
    <link href="https://zwiewings.github.io/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/"/>
    <id>https://zwiewings.github.io/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-04-16T11:55:41.000Z</published>
    <updated>2021-07-24T12:03:10.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础说明"><a href="#基础说明" class="headerlink" title="基础说明"></a>基础说明</h1><p>Java是面向对象的语言，它与c++不同的是，其程序的基本单位就是类（class），并且Java可通过Java虚拟机（JVM）实现跨平台，即在多个操作系统上运行</p><p>在安装java环境时，需要安装两部分内容，即JDK和JRE：</p><p>JRE——java程序的运行环境，包括JVM和运行时所需要的的核心类库，只要安装JRE就能够运行Java程序</p><p>JDK——java程序的开发工具包，包含JRE和开发人员使用的工具，其中开发工具指编译工具（javac.exe）和运行工具（java.exe）</p><h2 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h2><p>切换盘符——盘符：</p><p>查看当前目录下所有文件——dir</p><p>进入指定文件夹——cd 文件夹名</p><p>多级进入——cd 文件夹与当前位置的相对路径</p><p>返回上级目录——cd ..</p><p>多级回退（直接回到根目录）——cd \</p><p>清空命令记录——cls</p><p>退出cmd——exit</p><p>使用过的命令间切换——上下箭头</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在未进行环境配置时，需要进入javac或java的路径下，才能够使用javac.exe和java.exe，为了方便使用，需要配置环境变量</p><p>1.下载并安装JDK，建议开发工具和JRE安装放置同一文件夹下</p><p>2.计算机-右键菜单-左侧高级系统设置-环境变量中，在下方系统变量内创建</p><p>JAVA_HOME——填写JDK文件夹内部绝对路径（如：D:/Java/Jdk）</p><p>CLASSPATH——填写下列内容（注：不能忘记开头的点和每个目录和目录下文件名后的分号）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</span><br></pre></td></tr></table></figure><p>找到系统变量的Path——新建以下内容（这里末尾没有分号）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure><p>以上Java环境变量配置完成，重新打开cmd（在配置完成之前打开的cmd窗口可能仍旧报错），并在cmd中输入java和javac出现对应命令使用方法说明则配置成功</p><h2 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的文件名必须为HelloWorld，与类名相同</p><p>在cmd中进入目标文件所在位置，并输入javac HelloWorld.java，即可编译得到同目录下后缀名为.class的同名文件，再输入java HelloWorld（这里没有后缀名），即可运行该程序</p><p>对以上Hello World的入口说明（即方法/函数创建）：</p><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p><h2 id="标识符定义与修饰符"><a href="#标识符定义与修饰符" class="headerlink" title="标识符定义与修饰符"></a>标识符定义与修饰符</h2><h3 id="标识符定义"><a href="#标识符定义" class="headerlink" title="标识符定义"></a>标识符定义</h3><p>【包含类名、变量名以及方法名】</p><ul><li>应以字母，$，或下划线开头，字符组合也只能在前三种的基础上添加数字</li><li>关键字不能用作标识符，且标识符区分大小写</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table><thead><tr><th align="left">类别</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left">class</td><td align="left">类</td></tr><tr><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">super</td><td align="left">父类，超类</td></tr><tr><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">null</td><td align="left">空</td></tr></tbody></table><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/2.png" alt="2"></p><p>java的基本数据类型中新增了byte，short，long三种整数形式，分别占用1个字节，2个字节，8个字节，c++中的bool类型写作boolean，仍然只有true和false两个值，默认的整数为int类型，浮点数为double类型</p><p>在使用long类型时，为了防止整数过大，后面要加L，如：100000000L</p><p>在使用false类型时，为了防止类型不兼容，后面要加F，如3.14F</p><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li>大小写敏感：Java和c#一样区分大小写，使用时必须确保大小写完全一致</li><li>类名：类名首字母应该大写，由多个单词组成时，每个单词首字母大写</li><li>方法名：方法名以小写字母开头，由多个单词组成时，后面的每个单词首字母大写</li><li>源文件名：源文件名必须和类名相同，文件名后缀为.java</li><li>主方法入口:（类似c#中的main函数）程序由<strong>public static void main(String[] args)</strong> 开始执行</li></ul><h2 id="字符和字符串的“-”操作"><a href="#字符和字符串的“-”操作" class="headerlink" title="字符和字符串的“+”操作"></a>字符和字符串的“+”操作</h2><p><strong>字符的“+”操作是字符对应的编码进行加减</strong></p><p><strong>字符串的“+”操作是前后两者的拼接，如果有连续“+”操作，从左到右依次进行“+”操作</strong></p><p>例如：</p><p>“字符串”+10——输出得到——字符串10</p><p>“字符串”+10+20——输出得到——字符串1020</p><p>10+20+“字符串”——输出得到——30字符串</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="基本逻辑运算符"><a href="#基本逻辑运算符" class="headerlink" title="基本逻辑运算符"></a>基本逻辑运算符</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>&amp;</td><td>前后同时满足为true，否则为false</td></tr><tr><td>|</td><td>前后同时不满足为false，否则为true</td></tr><tr><td>^</td><td>前后关系式的值不相等时为true，相等时为false</td></tr><tr><td>!</td><td>结果和关系式正好相反</td></tr></tbody></table><h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与&amp;相同，但有短路效果，即前者为false时整个表达式为false，且不执行后者</td></tr><tr><td>||</td><td>与|相同，但有短路效果，即前者为true时整个表达式为true，且不执行后者</td></tr></tbody></table><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>关系表达式？表达式1：表达式2</p><ol><li>计算关系表达式的值</li><li>如果为true，则表达式1的值为该语句的值</li><li>如果为false，则表达式2的值为该语句的值</li></ol><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ol><li>导入scanner包：import java.util.Scanner；</li><li>创建对象：Scanner 变量名1=new Scanner（System.in）；</li><li>接受数据：int 变量名2=变量名1.nextInt（）；</li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><table><thead><tr><th>Java</th><th>c++</th><th>含义</th></tr></thead><tbody><tr><td>System.out.println(“x = “ +x);</td><td>cout&lt;&lt;”x = “&lt;&lt;x&lt;&lt;endl;</td><td>输出变量x的值并换行</td></tr><tr><td>System.out.print(“x = “ +x);</td><td>cout&lt;&lt;”x = “&lt;&lt;x;</td><td>输出变量x的值，不换行</td></tr><tr><td>System.out.printf(“x = %d”,x);</td><td>printf(“x = %d”,x);</td><td>以格式化文本和参数列表输出，不换行</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础说明&quot;&gt;&lt;a href=&quot;#基础说明&quot; class=&quot;headerlink&quot; title=&quot;基础说明&quot;&gt;&lt;/a&gt;基础说明&lt;/h1&gt;&lt;p&gt;Java是面向对象的语言，它与c++不同的是，其程序的基本单位就是类（class），并且Java可通过Java虚拟机（JVM</summary>
      
    
    
    
    <category term="专业课程" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/"/>
    
    <category term="基础" scheme="https://zwiewings.github.io/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/Java/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://zwiewings.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>UE4-4</title>
    <link href="https://zwiewings.github.io/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/"/>
    <id>https://zwiewings.github.io/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/</id>
    <published>2021-04-15T13:07:44.000Z</published>
    <updated>2021-06-30T06:04:15.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI（未完待续）"><a href="#AI（未完待续）" class="headerlink" title="AI（未完待续）"></a>AI（未完待续）</h1><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><h3 id="AI控制器"><a href="#AI控制器" class="headerlink" title="AI控制器"></a>AI控制器</h3><p>用于控制非玩家角色行动，UE4中的AI具有感知系统，即视听等感知组件</p><h3 id="黑板"><a href="#黑板" class="headerlink" title="黑板"></a>黑板</h3><p>在对应黑板上录入的变量都会作为行为树的全局变量，其中的变量称作键，通过细节面板可以命名及指定键的类型</p><h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h3><p>决定AI行为走向和思维模式的流程树，创建后有默认根节点，决定AI思维关系的主要是以下节点（来自官方文档）</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/25.png" alt="25"></p><p>可以理解为，选择器会从它的子树中选择能够执行的子树执行，直到子树执行结束，则回到选择器重新选择；序列则从左到右依次执行每个子树，直到遇到执行失败的节点则停止；简单平行的两个连接将并行处理，依据设置可以决定在主任务完成后结束或是等待支线任务完成才结束。</p><p>在节点上右击可添加对节点的装饰器，即需要满足装饰器的条件，才能够执行该节点</p><p>对于装饰器中的“观察者中止”一项，官方文档的说明如下：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/33.png" alt="33"></p><p>此项针对的是装饰器修饰的节点A是否优先执行，若装饰器满足条件，选择self项时，即使A自身和A的子树在执行，两者也会中止执行，优先执行A节点；选择lower priority时，只有节点A右边的所有节点会中止执行，优先执行A节点及子树；选择both时，则同时中止A的子树和A右面的所有节点，优先执行A节点</p><h2 id="寻路导航创建"><a href="#寻路导航创建" class="headerlink" title="寻路导航创建"></a>寻路导航创建</h2><p>所有AI寻路功能都需要创建寻路导航，可在主面板左上角的“放置actor”面板中找到“导航网格体边界体积”，放入场景中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/1.png" alt="1"></p><p>调整体积大小，将需要建构导航的场景放入该体积</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/2.png" alt="2"></p><p>点击构造后生成类似如图的绿色地面区域，这片区域为AI导航有效的区域</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/3.png" alt="3"></p><h2 id="实例：实现敌对NPC追踪角色移动"><a href="#实例：实现敌对NPC追踪角色移动" class="headerlink" title="实例：实现敌对NPC追踪角色移动"></a>实例：实现敌对NPC追踪角色移动</h2><p>思路：使用AI控制器沿创建好的导航移动敌对NPC，目标为玩家控制的角色，并循环操作</p><p>关卡蓝图：实现进入该关卡时，所有敌方npc无条件执行“移动”节点，即无条件自动追逐玩家</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/8.png" alt="8"></p><p>敌对NPC角色蓝图：实现敌对NPC追逐玩家的效果，即动态追踪玩家并移动到玩家当前的位置</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/4.png" alt="4"></p><h2 id="实例：实现敌对NPC的巡逻"><a href="#实例：实现敌对NPC的巡逻" class="headerlink" title="实例：实现敌对NPC的巡逻"></a>实例：实现敌对NPC的巡逻</h2><p><strong>思路：</strong>通过行为树和黑板，使AI控制器控制敌对NPC完成”巡逻——发现敌人则追逐——丢失目标则继续巡逻“</p><p>【以下为UE5试用版界面，可能与UE4有些许不同】</p><p><strong>创造文件及名称：</strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/17.png" alt="17"></p><p><strong>巡逻AI控制器：</strong></p><p>要使AI控制器具有视野范围就必须先具有感知组件</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/35.png" alt="35"></p><p>感知组件的细节配置如下</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/36.png" alt="36"></p><p>控制器事件蓝图内容如下</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/18.png" alt="18"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/19.png" alt="19"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/20.png" alt="20"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/21.png" alt="21"></p><p><strong>EnemyCharacter:</strong></p><p>敌方NPC的角色蓝图，不需要写入额外的内容，一般只需要将移动组件的最大行走速度设置为比玩家角色稍慢即可，便于玩家角色能够甩开NPC的追逐</p><p><strong>EnemyBoard：</strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/23.png" alt="23"></p><p>其中只有TargetActor的键类型基类需要设为actor，其他两个键使用默认设置</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/24.png" alt="24"></p><p><strong>EnemyBehaviorTree：</strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/31.png" alt="31"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/26.png" alt="26"></p><p>其中，改变行走速度（ChangeSpeed）和改变巡逻点（ChangeFollowPoint）两者为自行编写的任务蓝图，创建空白蓝图方法如下：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/27.png" alt="27"></p><p>节点“发现敌人”的装饰器设置如下：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/32.png" alt="32"></p><p><strong>ChangeSpeed</strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/28.png" alt="28"></p><p><strong>ChangeFollowPoint</strong></p><p>该蓝图中用到的新建变量如下</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/30.png" alt="30"></p><p>蓝图具体内容如下</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/29.png" alt="29"></p><h2 id="实例：实现敌对NPC失去目标后尝试寻找玩家"><a href="#实例：实现敌对NPC失去目标后尝试寻找玩家" class="headerlink" title="实例：实现敌对NPC失去目标后尝试寻找玩家"></a>实例：实现敌对NPC失去目标后尝试寻找玩家</h2><p><strong>思路：</strong>在实现巡逻的基础上通过为敌对NPC增加EQS（环境查询系统），实现玩家在离开敌对NPC感知范围后，NPC仍然会试图搜寻玩家位置</p><p><strong>新创建的文件：</strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/37.png" alt="37"></p><p><strong>前置工作：</strong>在使用EQS之前，首先需要在项目设置中启用EQS</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/38.png" alt="38"></p><h2 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h2><div class="tip warning"><p></p><p>在运行场景时，可使用键盘上的引号键【‘】呼出AI面板，在AI面板下按小键盘的4键，可查看AI的感知范围</p><p></p></div><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/34.png" alt="34"></p><h1 id="动画序列与蓝图"><a href="#动画序列与蓝图" class="headerlink" title="动画序列与蓝图"></a>动画序列与蓝图</h1><h2 id="过场动画制作"><a href="#过场动画制作" class="headerlink" title="过场动画制作"></a>过场动画制作</h2><p>创建一个过场动画的关卡序列，命名并打开操作界面</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/9.png" alt="9"></p><p>新建一个相机剪切轨道，并且绑定用于拍摄过场动画的电影摄像机actor（或是直接在场景中选中指定相机，通过actor到sequencer直接添加），将相机移动到起始位置，添加变换轨道（或其他轨道）并在起始位置添加关键帧</p><p>制作动画时，其他actor也可添加移动轨道，详细在下一个子目录“动画轨道”中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/10.png" alt="10"></p><p>多次移动相机到指定位置，并在轨道上添加相应的关键帧（场景中能够看到相机移动的轨迹呈现），最后调整动画结束的准线，结束修改并保存</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/12.png" alt="12"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/11.png" alt="11"></p><p>当拍摄多个动画后，可将需要拼接的动画放入一个新的关卡序列中，上下移动调整轨道，左右移动调整播放顺序，并将结束准线对齐</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/13.png" alt="13"></p><p>多段动画中间可建立渐变轨道的关键帧，实现切换的淡入淡出</p><h2 id="动画轨道"><a href="#动画轨道" class="headerlink" title="动画轨道"></a>动画轨道</h2><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/14.png" alt="14"></p><p>Actor到Sequencer：创建一个控制actor的轨道，在场景中选中的actor会优先显示在顶端**<em>（创建actor后一般自带一个控制actor移动的transfrom轨道，也可以自己添加变换轨道）**</em></p><p>添加文件夹：可为多个轨道分类，放置于不同的文件夹下（好像没什么用的样子）</p><p>音频轨道：可在动画播放同时添加音频资产的播放</p><p>事件轨道：分为触发器和中继器（后者不常用），触发器轨道中添加了关键帧后，右键新建末端可新建图表事件，当时间轴移动到指定位置执行该事件</p><p>相机剪切轨道：用于添加相机轨道，使用actor到sequencer添加时也会自动创建</p><p>镜头轨道：用于拼接多个镜头的轨道，也可以实现多个动画序列之间的拼接</p><p>时间膨胀轨道：用于设置播放倍率的关键帧，实现部分慢镜头和快进</p><p>渐变轨道：添加动画的黑幕（1为全黑，0为透明），多个关键帧可实现淡入淡出</p><p><strong><em>【注：如果在单独一个元件下添加轨道，则所有轨道都作为其子元件，该元件的组件也可以实现调用为子元件，同时，在单一元件下还能够创建可视性轨道，调整特定时间下的actor是否可见。</em></strong></p><p><strong><em>特别地，对于相机actor来说，需要先获取CameraComponent子元件才能够更改具体具体属性（如：曝光补偿等）】</em></strong></p><h2 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h2><p>【需要创建蓝图类-MatineeCameraShake文件】</p><h4 id="振荡设置"><a href="#振荡设置" class="headerlink" title="振荡设置"></a>振荡设置</h4><p>振荡时长：振荡的总时长</p><p>振荡混入时间：振荡开始的时间</p><p>振荡混出时间：振荡结束的时间</p><p>旋转振荡：实现镜头的各方位旋转振荡（如决定上下振荡或者左右振荡，或者两者混合等）</p><p>位置振荡：实现镜头的移动性振荡（如决定相机位置前后振荡等）</p><p>FOV振荡：实现镜头的缩放性振荡（相机位置不变，只是镜头缩放）</p><h4 id="具体蓝图使用"><a href="#具体蓝图使用" class="headerlink" title="具体蓝图使用"></a>具体蓝图使用</h4><ol><li><p>在需要使用的蓝图流程中加入以下结点</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/15.png" alt="15"></p></li></ol><ol start="2"><li><p>在动画序列中相机组件下添加相机晃动子元件，可以拖拽缩放抖动条</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/16.png" alt="16"></p></li></ol><h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p>打开某个骨骼/网格体/动画序列/物理模型时，可在右上角看到动画蓝图标识</p><p><strong><em>【注：此处以第三人称游戏模板的小白人为例】</em></strong></p><p>打开默认的动画图表【AnimGraph】，找到默认状态机，双击打开</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/5.png" alt="5"></p><p>状态机内部蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-1.png" alt="6-1"></p><p>Entry为一个输入/起始点，Idle/Run节点为走或跑时，JumpStart、Loop、End分别为跳跃的开始，腾空，落地过程，四个节点分别播放不同的动画，双箭头为四个节点互相切换的条件（右键添加状态可添加节点，通过节点引线引出的新节点与原节点之间自带转换条件）</p><p>Idle/Run节点内部：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-2.png" alt="6-2"></p><p>此处混合空间播放器节点下方为一段动画，具有三个白色关键帧（第一个与绿色关键帧重合），由绿色关键帧的位置（speed的大小）决定播放的动画，而在动画播放时，绿色关键帧如果未到达下一个白色关键帧，将循环播放上一个白色关键帧的动画</p><p>JumpStart、Loop、End节点内部：</p><p><strong><em>【注：因为结构相同故而使用JumpStart作为范例】</em></strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-3.png" alt="6-3"></p><p>由Idle/Run节点到JumpStart与从JumpLoop到JumpEnd节点的切换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-5.png" alt="6-5"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-6.png" alt="6-6"></p><p>前者：判断角色是否在空中，如果是，转换到下一个节点（即JumpStart节点）</p><p>后者：判断角色是否不在空中，如果是，转换到下一个节点（即JumpEnd节点）</p><p>由JumpStart到JumpLoop与由JumpEnd到Idle/Run节点的转换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-4.png" alt="6-4"></p><p>判断前一个节点（JumpStart或JumpEnd）中动画资产播放的剩余时间是否小于0.1，如果是，则转换到下一个节点（JumpLoop或Idle/Run）</p><p>动画蓝图事件图表：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/7.png" alt="7"></p>]]></content>
    
    
    <summary type="html">AI与动画序列、动画蓝图节点讲解与制作</summary>
    
    
    
    <category term="课外拓展" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/"/>
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/categories/%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/UE4/"/>
    
    
    <category term="虚幻引擎" scheme="https://zwiewings.github.io/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E/"/>
    
    <category term="UE4" scheme="https://zwiewings.github.io/tags/UE4/"/>
    
  </entry>
  
</feed>
