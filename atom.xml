<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zweiwings</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-27T14:13:31.411Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Zweiwings</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-6</title>
    <link href="http://example.com/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/"/>
    <id>http://example.com/2021/04/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</id>
    <published>2021-04-27T12:46:05.000Z</published>
    <updated>2021-04-27T14:13:31.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h1><h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><ul><li>树：一个有限集，可以为空，非空时有且只有一个根结点，其余结点可以分为多个不相交的有限集（子树）</li><li>结点的度：结点的子树个数</li><li>树的度：树的所有结点中最大的度数</li><li>叶子结点：度为0的结点</li><li>父结点：有子树的结点是其子树的根节点的父结点</li><li>子结点/孩子结点：若A结点是B结点的父结点，则称B结点是A结点的子结点</li><li>兄弟结点：具有同一个父结点的各结点彼此是兄弟结点</li><li>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk。ni是ni+1的父结点。路径所包含边的个数为路径的长度</li><li>祖先结点：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li><li>子孙结点：某一结点的子树中的所有结点是这个结点的子孙</li><li>结点的层次：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li><li>树的深度：树中所有结点中的最大层次是这棵树的深度</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树概念"><a href="#二叉树概念" class="headerlink" title="二叉树概念"></a>二叉树概念</h3><p>二叉树：一个有穷的结点集合。这个集合可以为空；若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。二叉树的子树有左右顺序之分。</p><p><strong>二叉树的五种基本形态：</strong></p><p>斜二叉树：只有左子节点或只有右子节点的二叉树，度为1，只有左子节点或右子节点</p><p>满二叉树/ 完美二叉树：除最后一层无任何子结点外，每一层上的所有结点都有两个子结点的二叉树</p><p>完全二叉树：有n个结点的二叉树，对树中结点从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中的位置相同（能和满二叉树完全重叠，编号相同）</p><p><strong>按从上至下、从左到右顺序存储n个结点的完全二叉树的结点父子关系：（顺序存储）</strong></p><ul><li>根结点的序号为1</li><li>非根结点（序号i&gt;1）的父结点的序号是：i / 2</li><li>结点（序号为i）的左孩子结点的序号是：2 * i，若2*i &gt; n，则没有左孩子</li><li>结点（序号为i）的右孩子结点的序号是：2 * i + 1，若2*i+1 &gt; n，则没有右孩子</li></ul><p><strong>普遍规律：</strong></p><p>一个二叉树第i层的最大结点数为：2i-1，i≥1</p><p>深度为k的二叉树有最大结点总数为：2k-1，k≥1</p><p>对任何非空二叉树T，叶结点个数为n0，度为1的结点个数为n1，度为2的结点个数为n2，则二叉树的总边数：N=2*n2+n1，总结点数：N′=n0+n1+n2，总叶子结点数：n0=n2+1</p><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;树和二叉树&quot;&gt;&lt;a href=&quot;#树和二叉树&quot; class=&quot;headerlink&quot; title=&quot;树和二叉树&quot;&gt;&lt;/a&gt;树和二叉树&lt;/h1&gt;&lt;h2 id=&quot;树的概念&quot;&gt;&lt;a href=&quot;#树的概念&quot; class=&quot;headerlink&quot; title=&quot;树的概念&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-5</title>
    <link href="http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/"/>
    <id>http://example.com/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</id>
    <published>2021-04-26T11:52:16.000Z</published>
    <updated>2021-04-27T12:45:35.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="串类型"><a href="#串类型" class="headerlink" title="串类型"></a>串类型</h1><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>串的存储结构可以使用顺序和链式结构，顺序结构中又分为定长和堆式存储结构，但由于链式不如顺序结构灵活，操作简单，故而此处只写入顺序结构</p><h3 id="顺序-定长存储"><a href="#顺序-定长存储" class="headerlink" title="顺序-定长存储"></a>顺序-定长存储</h3><pre><code class="c++">typedef struct&#123;    char ch[maxsize+1];        //定义字符数组，串的最大长度为maxsize，多申请防止溢出的存储空间    int length;                //串的当前长度&#125;Sstring;</code></pre><h3 id="顺序-堆式存储"><a href="#顺序-堆式存储" class="headerlink" title="顺序-堆式存储"></a>顺序-堆式存储</h3><pre><code class="c++">typedef struct&#123;    char *ch;                //如果是非空串，则按串长分配存储区，否则ch指向NULL;    int length;                //串的当前长度&#125;</code></pre><h2 id="模式匹配算法"><a href="#模式匹配算法" class="headerlink" title="模式匹配算法"></a>模式匹配算法</h2><p>串的模式匹配用于在主串中寻找子串，如果匹配成功，则确定相匹配的子串中第一个字符在主串s中出现的位置</p><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h3><pre><code class="c++">int Index_BF(Sstring s,Sstring t,int pos)    //传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找&#123;    int i,j;    for(i=pos,j=1;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)        //初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移    &#123;        if(s.ch[i]==t.ch[i])    //当主串s中i位置的字符和子串t中j位置的字符相同时        &#123;            continue;        //继续下一次循环，即只执行for语句的i++，j++        &#125;        else        &#123;            i=i-j+1;        //否则，i回到开始匹配的位置（执行for语句的i++后移到下一个位置            j=0;            //j被重置为0（然后执行for语句的j++后变为j=1）        &#125;    &#125;    if(j&gt;t.length) return i-t.length;    //当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置    else return 0;    //否则返回0，表示没有匹配成功&#125;</code></pre><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><pre><code class="c++">int Index_KMP(Sstring s,Sstring t,int pos)    //传址需要比较的主串s，子串t，以及从主串序号为pos处开始查找&#123;    int i,j;    for(i=pos,j=1;i&lt;=s.length&amp;&amp;j&lt;=t.length;i++,j++)        //初始化i=pos,j=1，当两个串都没有到串尾时循环，i，j依次后移    &#123;        if(j==0||s.ch[i]==t.ch[i])    //当主串s中i位置的字符和子串t中j位置的字符相同时        &#123;            continue;        //继续下一次循环，即只执行for语句的i++，j++        &#125;        else        &#123;            j=next[j];        //KMP相比BF算法节省时间的原因        &#125;    &#125;    if(j&gt;t.length) return i-t.length;    //当j的位置超出了t的长度，则说明完全匹配，返回首字符开始与主串匹配的位置    else return 0;    //否则返回0，表示没有匹配成功&#125;void get_next(Sstring t,int next[])    //求子串t的next函数值并且存进数组next&#123;    int j,i=1,next[1]=0;    //定义i，j，以及next数组的第一个值    for(j=0;i&lt;t.length;)                //i不超过子串t长度时循环    &#123;        if(j==0||t.ch[i]==t.ch[j])        //如果j为0或是前后两个字符相同时        &#123;            i++;            j++;            if(t.ch[i]!=t.ch[j])        //如果前后两个字符不相同                next[i]=j;                //令下次比较从j开始            else next[i]=next[j];                &#125;        else j=next[j];    &#125;&#125;</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组的顺序存储"><a href="#二维数组的顺序存储" class="headerlink" title="二维数组的顺序存储"></a>二维数组的顺序存储</h2><p>已知一维数组中a【i】的存储位置在a+i处，二维数组因主序不同分为两种存储结构（常用行序）</p><p>设每个数据元素占L个存储单元，则二维数组A[0…m-1,0…n-1]（下标从0开始，共有m行n列）中任一元素a【i】【j】的存储位置如下：</p><p><strong>行为主序的存储结构</strong>：</p><p>$$<br>LOC(i , j) = LOC(0 , 0) + (n * i + j) L<br>$$<br><strong>列为主序的存储结构：</strong><br>$$<br>LOC(i , j) = LOC(0 , 0) + (m * j + i) L<br>$$<br>其中，LOC(i,j)是a【i】【j】的存储位置</p><p>LOC（0，0）是a【0】【0】的存储位置，即二维数组A的起始存储位置、也称为基地址或基址</p><p><strong>故而总结可知：</strong><br>$$<br>LOC(i , j) = 基址 + (副序长度 * 主序标号 + 另一标号) * 数据所占存储单元<br>$$</p><h2 id="特殊矩阵的压缩存储"><a href="#特殊矩阵的压缩存储" class="headerlink" title="特殊矩阵的压缩存储"></a>特殊矩阵的压缩存储</h2><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>特点：在n*n的矩阵a中，1&lt;= i，j &lt;= n<br>存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。</p><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/1.png" alt="1"></p><p>上下三角中的元素均为：n(n+1) / 2<br>可以以行序为主序将元素存放在一个一维数组a[n(n+1) / 2]中，a[k]的位置可如下公式确定<br>$$<br>k=主序序号（主序序号-1）/2+副序序号-1，主序&gt;=副序<br>$$<br>注：上式的k从0开始计算</p><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/2.png" alt="2"></p><h3 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-1.png" alt="3-1"></p><h3 id><a href="#" class="headerlink" title></a><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/3-2.png" alt="3-2"></h3><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><img src="/2021/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/4.png" alt="4"></p><h1 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h1><p>一般记作LS（a1，a2，……，an），其中LS为广义表的名称，n为广义表的长度，其中的元素可以是单个数据（原子）也可以是广义表（子表），一般小写为原子，大写为子表</p><p><strong>广义表示例：</strong></p><ul><li>A=（）——空表，长度为0</li><li>B=（e）——只有一个原子，为e，长度为1</li><li>C=（a，（b，c，d））——有一个原子a和一个子表（b，c，d），共两个元素，长度为2</li><li>D=（A，B，C）——有三个子表，即三个元素，长度为3</li><li>E=（a，E）——一个递归的表，长度为2</li></ul><p>注：广义表A=（（））和广义表B=（）是不相同的，A为有一个空子表，长度为1的广义表，而B是一个空表，长度为0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;串类型&quot;&gt;&lt;a href=&quot;#串类型&quot; class=&quot;headerlink&quot; title=&quot;串类型&quot;&gt;&lt;/a&gt;串类型&lt;/h1&gt;&lt;h2 id=&quot;存储结构&quot;&gt;&lt;a href=&quot;#存储结构&quot; class=&quot;headerlink&quot; title=&quot;存储结构&quot;&gt;&lt;/a&gt;存储结</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-3</title>
    <link href="http://example.com/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/"/>
    <id>http://example.com/2021/04/22/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-3/</id>
    <published>2021-04-22T07:00:56.000Z</published>
    <updated>2021-04-27T14:10:44.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="css格式定义"><a href="#css格式定义" class="headerlink" title="css格式定义"></a>css格式定义</h3><p>css样式设置由选择器和声明部分组成，示例如下</p><pre><code>选择器类型&#123;    属性1:值1;    属性2:值2;    …………&#125;</code></pre><p>一般来说，作为分隔每个属性的标志，最末尾的属性后的分号可以省略，但规范上是不省略的</p><h3 id="css样式调用"><a href="#css样式调用" class="headerlink" title="css样式调用"></a>css样式调用</h3><p>分为：行内样式表，内部样式表，链入外部样式表</p><p>以下为链入外部样式表的两种方法：</p><pre><code class="html">方法1：&lt;link href=&quot;相对地址&quot; type=&quot;text/css&quot; rel=&quot;stylesheeet&quot;&gt;方法2：&lt;style type=&quot;text/css&quot;&gt;        @import url(&quot;相对地址&quot;);      &lt;/style&gt;</code></pre><p>注：也可以在当前网页内以css的方式写入本网页的样式（如行内样式表和内部样式表），但是该样式仅作用于该网页，而且夹杂于内容中，故不推荐使用</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="标签选择器：p、hn等标签"><a href="#标签选择器：p、hn等标签" class="headerlink" title="标签选择器：p、hn等标签"></a>标签选择器：p、hn等标签</h3><p>代表该标签的共性，用css修改时，将会作用于当前网页所有该标签</p><p>调用方式：直接使用定义的标签</p><p>选择器类型：指定的标签名字</p><h3 id="类选择器：以-开头"><a href="#类选择器：以-开头" class="headerlink" title="类选择器：以.开头"></a>类选择器：以.开头</h3><p>把相同类型的元素分类定义成不同的样式，用css修改时，将改变这一类的所有元素样式</p><p>调用方式：class=”类选择器的名字”（多个效果可用空格隔开）</p><p>选择器类型：.类选择器名</p><p><strong>注意：</strong></p><ul><li>不要试图用一个类名，把某个标签的所有样式写完，一个标签应该多携带几个类</li><li>每个类要尽可能的小，以达到公共性</li></ul><h3 id="id选择器：以-开头"><a href="#id选择器：以-开头" class="headerlink" title="id选择器：以#开头"></a>id选择器：以#开头</h3><p>代表某一元素的个性，用css修改时，只改变当前元素的样式</p><p>调用方式：id=”id选择器的名字”</p><p>选择器类型：#id选择器的名字</p><p>注：id选择器在文档中只能使用一次，而类选择器可以使用多次</p><h3 id="通配符选择器：“-”"><a href="#通配符选择器：“-”" class="headerlink" title="通配符选择器：“*”"></a>通配符选择器：“*”</h3><p>作用于所有的标签样式，用css修改时会改变所有使用该css的网页样式</p><p>使用方式：不需要调用，在css文件链接时直接附加</p><h3 id="群组选择器-并集选择器：“-”"><a href="#群组选择器-并集选择器：“-”" class="headerlink" title="群组选择器/并集选择器：“,”"></a>群组选择器/并集选择器：“,”</h3><p>表达“或”的含义，部分样式相同或完全相同时使用</p><p>使用方式：</p><pre><code>标签名1,标签名2,……&#123;属性表&#125;</code></pre><h3 id="标签指定式选择器-交集选择器"><a href="#标签指定式选择器-交集选择器" class="headerlink" title="标签指定式选择器/交集选择器"></a>标签指定式选择器/交集选择器</h3><p>表达“和”的含义，同时使用标签选择器和类选择器或者同时使用标签选择器和id选择器</p><p>使用方式：</p><pre><code>标签名.类名&#123;属性表&#125;标签名#id&#123;属性表&#125;</code></pre><h3 id="包含选择器-后代选择器"><a href="#包含选择器-后代选择器" class="headerlink" title="包含选择器/后代选择器"></a>包含选择器/后代选择器</h3><p>选择元素或元素组的后代，也称后代选择器，把外层标签写在前面，内层标签写在后面，中间用空格分隔</p><p>使用方式：（两个选择器中间必须有空格）</p><pre><code>选择器1 选择器2&#123;属性表&#125;</code></pre><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>为拥有指定属性的html元素设置样式，不局限于class和id属性，下表以attribute代替属性选择器名</p><table><thead><tr><th align="center">选择器</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[attribute]</td><td align="center">选取带有指定属性的元素</td></tr><tr><td align="center">[attribute=value]</td><td align="center">选取带有指定属性且取值为value的元素</td></tr><tr><td align="center">[attribute~=value]</td><td align="center">选取属性值中包含指定词汇的元素</td></tr><tr><td align="center">[attribute|=value]</td><td align="center">选取带有指定值开头的属性值的元素，值必须是整个单词</td></tr><tr><td align="center">[attribute^=value]</td><td align="center">匹配属性值以指定值开头的每个元素</td></tr><tr><td align="center">[attribute$=value]</td><td align="center">匹配属性值以指定值结尾的每个元素</td></tr><tr><td align="center">[attribute]*=value]</td><td align="center">匹配属性值中包含指定值的每个元素</td></tr></tbody></table><p>使用方法：</p><pre><code class="css">标签名[属性选择器名]&#123;属性表&#125;例如：选择器为[attribute]类型时：p[here]&#123;    background-color:red;&#125;选择器为[attribute=value]类型时：p[here=red]&#123;    background-color:red;&#125;</code></pre><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><p>主要包括子元素选择器，相邻兄弟选择器，普通兄弟选择器</p><table><thead><tr><th align="center">属性名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">子元素选择器（E&gt;F）</td><td align="center">选择所有作为E元素的<strong>直接子元素</strong>F，对更深一层的元素不起作用</td></tr><tr><td align="center">兄弟相邻选择器（E+F)</td><td align="center">选择<strong>紧跟</strong>在E元素<strong>后面</strong>的F元素，选择相邻的第一个兄弟元素</td></tr><tr><td align="center">普通兄弟选择器（E~F）</td><td align="center">选择E元素之后的<strong>所有</strong>兄弟元素F，作用于多个元素</td></tr></tbody></table><p>使用方法：</p><pre><code class="css">子元素选择器：标签名&gt;子元素标签名&#123;属性表&#125;如：div&gt;a&#123;    color:red;&#125;实现效果为div标签内，直接子元素的a标签都为红色兄弟相邻选择器：标签名+子元素标签名&#123;属性表&#125;如：div+a&#123;    color:red;&#125;实现效果为div标签同级的紧挨的下一个a标签为红色普通兄弟选择器：标签名~子元素标签名&#123;属性表&#125;div~a&#123;    color:red;&#125;实现效果为div标签后的所有同级的a标签都是红色</code></pre><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><h4 id="超链接伪类选择器"><a href="#超链接伪类选择器" class="headerlink" title="超链接伪类选择器"></a>超链接伪类选择器</h4><table><thead><tr><th align="center">伪类名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">a:link</td><td align="center">未访问时的超链接状态</td></tr><tr><td align="center">a:visited</td><td align="center">访问后的超链接的状态（也可用于普通非链接元素:visited）</td></tr><tr><td align="center">a:hover</td><td align="center">鼠标经过、悬停时超链接的状态</td></tr><tr><td align="center">a:active</td><td align="center">鼠标单击不动时超链接的状态（也可用于普通非链接元素:active）</td></tr></tbody></table><p><strong><em>注：</em></strong></p><ul><li><strong><em>样式必须符合link、visited、hover、active顺序</em></strong></li><li><strong><em>在css定义中，a:hover必须被置于a:link和a:visited后才有效</em></strong></li><li><strong><em>a:active必须被置于a:hover之后才有效</em></strong></li></ul><p>使用方法：（以a:link和h1为例）</p><pre><code class="css">a:link&#123;属性表&#125;       &lt;!--超链接伪类选择器--&gt;h1:hover&#123;属性表&#125;      &lt;!--普通非链接元素伪类选择器--&gt;</code></pre><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">:root</td><td align="center">将样式绑定到页面的根元素中（即指位于文档树中最顶层结构的html标签）</td></tr><tr><td align="center">:not</td><td align="center">用于选择除某个元素之外的所有元素</td></tr><tr><td align="center">:empty</td><td align="center">指定当元素内容为空白时使用的样式</td></tr><tr><td align="center">:target</td><td align="center">对页面中某个target元素指定样式，只在用户点击链接并跳转到target元素后生效</td></tr></tbody></table><p>其中，:target使用时，前面不需要添加标签名，在锚点跳转后应用于跳转到的位置</p><h4 id="子元素伪类选择器"><a href="#子元素伪类选择器" class="headerlink" title="子元素伪类选择器"></a>子元素伪类选择器</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>:first-child</td><td>对父元素中的第一个子元素指定样式</td></tr><tr><td>:last-child</td><td>对父元素中的最后一个子元素指定样式</td></tr><tr><td>:only-child</td><td>当某个父元素中只有一个子元素时使用的样式</td></tr><tr><td>:nth-child(n)</td><td>对指定序号的子元素设置样式（正数），表示第几个子元素</td></tr><tr><td>:nth-last-child(n)</td><td>对指定序号的子元素设置样式（正数），表示倒数第几个子元素</td></tr><tr><td>:nth-child(even)</td><td>所有正数第偶数个子元素，等同于:nth-child(2n)</td></tr><tr><td>:nth-child(odd)</td><td>所有正数第奇数个子元素，等同于:nth-child(2n+1)</td></tr><tr><td>:nth-last-child(even)</td><td>所有倒数第偶数个子元素</td></tr><tr><td>:nth-last-child(odd)</td><td>所有倒数第奇数个子元素</td></tr><tr><td>:nth-of-type(n)</td><td>用于匹配属于父元素的特定类型的第n个子元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>用于匹配属于父元素的特定类型的倒数第n个子元素</td></tr></tbody></table><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>伪元素选择器是针对css中已经定义的伪元素使用的选择器，css中主要使用的伪元素为“:before”伪元素选择器和”:after”伪元素选择器</p><h4 id="before伪元素选择器"><a href="#before伪元素选择器" class="headerlink" title=":before伪元素选择器"></a>:before伪元素选择器</h4><p>用于在被选元素的内容前面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><pre><code class="css">element:before&#123;    content:文字/url();&#125;</code></pre><p>element表示元素，“{}”中的content属性用来指定要插入的具体内容，既可以为文本也可以为图片</p><h4 id="after伪元素选择器"><a href="#after伪元素选择器" class="headerlink" title=":after伪元素选择器"></a>:after伪元素选择器</h4><p>用于在被选元素内容的后面插入内容，必须配合“content”属性来指定要插入的具体内容</p><p>使用方法：</p><pre><code class="css">element:after&#123;    content:文字/url();&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CSS操作&quot;&gt;&lt;a href=&quot;#CSS操作&quot; class=&quot;headerlink&quot; title=&quot;CSS操作&quot;&gt;&lt;/a&gt;CSS操作&lt;/h1&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-6</title>
    <link href="http://example.com/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/"/>
    <id>http://example.com/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/</id>
    <published>2021-04-17T14:12:16.000Z</published>
    <updated>2021-04-27T15:02:33.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="脚步声与相机晃动"><a href="#脚步声与相机晃动" class="headerlink" title="脚步声与相机晃动"></a>脚步声与相机晃动</h1><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>实现角色在默认地板、木质地板和金属地板上的不同脚步声以及行走时的相机晃动</p><h2 id="函数写入位置"><a href="#函数写入位置" class="headerlink" title="函数写入位置"></a>函数写入位置</h2><p>全局函数库、玩家角色蓝图</p><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><h3 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h3><p>创建相机晃动（下图为参考数值），需要勾上单一实例，保证每次使用只晃动一次</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/1.png" alt="1"></p><h3 id="脚步声"><a href="#脚步声" class="headerlink" title="脚步声"></a>脚步声</h3><ol><li><p>导入材质、脚步声</p></li><li><p>创建物理材质，表面类型需要在项目设置中先添加再修改，以下为项目设置界面</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/3.png" alt="3"></p></li><li><p>以其中一个音频为基础创建cue，并添加随机节点，实现多个同类音频随机播放（毕竟脚步声不可能每一步都是同一个声音），如图示例</p><p><img src="/2021/04/17/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-6/2.png" alt="2"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;脚步声与相机晃动&quot;&gt;&lt;a href=&quot;#脚步声与相机晃动&quot; class=&quot;headerlink&quot; title=&quot;脚步声与相机晃动&quot;&gt;&lt;/a&gt;脚步声与相机晃动&lt;/h1&gt;&lt;h2 id=&quot;实例说明&quot;&gt;&lt;a href=&quot;#实例说明&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-5</title>
    <link href="http://example.com/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/"/>
    <id>http://example.com/2021/04/16/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-5/</id>
    <published>2021-04-16T13:07:44.000Z</published>
    <updated>2021-04-20T12:51:58.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚幻文件夹结构"><a href="#虚幻文件夹结构" class="headerlink" title="虚幻文件夹结构"></a>虚幻文件夹结构</h1><h2 id="本地工程文件夹"><a href="#本地工程文件夹" class="headerlink" title="本地工程文件夹"></a>本地工程文件夹</h2><p>惯例为【Config】、【Content】、【DerivedDataCache】、【Intermediate】、【Saved】、【Script】六个文件夹，和一个后缀名为.uproject的文件（该文件为工程本体，在引擎中打开工程使用该文件）</p><h3 id="【Config】"><a href="#【Config】" class="headerlink" title="【Config】"></a>【Config】</h3><h3 id="【Content】"><a href="#【Content】" class="headerlink" title="【Content】"></a>【Content】</h3><h3 id="【DerivedDataCache】"><a href="#【DerivedDataCache】" class="headerlink" title="【DerivedDataCache】"></a>【DerivedDataCache】</h3><h3 id="【Intermediate】"><a href="#【Intermediate】" class="headerlink" title="【Intermediate】"></a>【Intermediate】</h3><h3 id="【Saved】"><a href="#【Saved】" class="headerlink" title="【Saved】"></a>【Saved】</h3><h3 id="【Script】"><a href="#【Script】" class="headerlink" title="【Script】"></a>【Script】</h3><h2 id="导入素材文件夹"><a href="#导入素材文件夹" class="headerlink" title="导入素材文件夹"></a>导入素材文件夹</h2><p>惯例为【Animations】、【Materials】、【Meshes】、【Map（Scenes）】、【Textures】五个文件夹，有时也有会将【Materials】、【Textures】、【Meshes】放在一个【character】文件夹下的构成</p><h3 id="【Animations】"><a href="#【Animations】" class="headerlink" title="【Animations】"></a>【Animations】</h3><p>【Animations】为该素材包内包括的动画序列，根据固定的骨骼执行，执行动画的网格体可以替换预览并实际替换使用</p><h3 id="【Materials】"><a href="#【Materials】" class="headerlink" title="【Materials】"></a>【Materials】</h3><p>【Materials】为该素材包内所用到的所有材质，一般通过【材质】蓝图修改或直接使用</p><h3 id="【Meshes】"><a href="#【Meshes】" class="headerlink" title="【Meshes】"></a>【Meshes】</h3><p>【Meshes】为该素材包内用到的所有骨架模型（骨骼网格体）、物理模型（物理资产）、骨骼，骨架模型是没有碰撞体积的，而物理模型能够表现受力（例如场景中运行时会受重力，和玩家角色重叠时会发生移动）</p><h3 id="【Map（scenes）】"><a href="#【Map（scenes）】" class="headerlink" title="【Map（scenes）】"></a>【Map（scenes）】</h3><p>【Map（Scenes）】为该素材包的场景地图，一般会有一个Overview场景，用于预览所有模型，动画，地形等该素材包的素材</p><h3 id="【Textures】"><a href="#【Textures】" class="headerlink" title="【Textures】"></a>【Textures】</h3><p>【Textures】为该素材包的所有贴图，包括材质贴图，法线贴图，场景贴花等，通常在【材质】蓝图中找到需要更改的属性，再对应的更改贴图以达到更改材质的效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;虚幻文件夹结构&quot;&gt;&lt;a href=&quot;#虚幻文件夹结构&quot; class=&quot;headerlink&quot; title=&quot;虚幻文件夹结构&quot;&gt;&lt;/a&gt;虚幻文件夹结构&lt;/h1&gt;&lt;h2 id=&quot;本地工程文件夹&quot;&gt;&lt;a href=&quot;#本地工程文件夹&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java学习-1</title>
    <link href="http://example.com/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://example.com/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/</id>
    <published>2021-04-16T11:55:41.000Z</published>
    <updated>2021-04-16T12:50:31.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.下载并安装jdk，jre，建议放置同一文件夹下</p><p>2.计算机-右键菜单-左侧高级系统设置-环境变量中，在下方系统变量内创建</p><p>JAVA_HOME——填写jdk文件夹内部绝对路径（如：D:/Java/Jdk）</p><p>CLASSPATH——填写下列内容（注：不能忘记开头的点和每个目录和目录下文件名后的分号）</p><pre><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></pre><p>找到系统变量的Path——新建以下内容（这里末尾没有分号）</p><pre><code>%JAVA_HOME%\bin</code></pre><p>以上Java环境变量配置完成，在cmd中输入java和javac出现对应命令使用方法说明则配置成功</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li>大小写敏感：Java和c#一样区分大小写，使用时必须确保大小写完全一致</li><li>类名：类名首字母应该大写，由多个单词组成时，每个单词首字母大写</li><li>方法名：方法名以小写字母开头，由多个单词组成时，后面的每个单词首字母大写</li><li>源文件名：源文件名必须和类名相同，文件名后缀为.java</li><li>主方法入口:（类似c#中的main函数）程序由<strong>public static void main(String[] args)</strong> 开始执行</li><li>注释：可使用//和/**/进行单行注释和多行注释</li></ul><h2 id="标识符定义与修饰符"><a href="#标识符定义与修饰符" class="headerlink" title="标识符定义与修饰符"></a>标识符定义与修饰符</h2><h3 id="标识符定义"><a href="#标识符定义" class="headerlink" title="标识符定义"></a>标识符定义</h3><p>【包含类名、变量名以及方法名】</p><ul><li>应以字母，$，或下划线开头，字符组合也只能在前三种的基础上添加数字</li><li>关键字不能用作标识符，且标识符区分大小写</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><table><thead><tr><th align="left">类别</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left">class</td><td align="left">类</td></tr><tr><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">super</td><td align="left">父类，超类</td></tr><tr><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left">null</td><td align="left">空</td></tr></tbody></table><h2 id="HelloWorld程序"><a href="#HelloWorld程序" class="headerlink" title="HelloWorld程序"></a>HelloWorld程序</h2><pre><code class="java">public class HelloWorld &#123;    /* 第一个Java程序     * 它将输出字符串 Hello World     */    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;); // 输出 Hello World    &#125;&#125;</code></pre><p>以上程序的文件名必须为HelloWorld，与类名相同</p><p>在cmd中进入目标文件所在位置，并输入javac HelloWorld.java，即可编译得到同目录下后缀名为.class的同名文件，再输入java HelloWorld（这里没有后缀名），即可运行该程序</p><p>对以上Hello World的入口说明（即方法/函数创建）：</p><p><img src="/2021/04/16/Java%E5%AD%A6%E4%B9%A0-1/1.png" alt="1"></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296">https://www.liaoxuefeng.com/wiki/1252599548343744/1255884132971296</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门教程&quot;&gt;&lt;a href=&quot;#入门教程&quot; class=&quot;headerlink&quot; title=&quot;入门教程&quot;&gt;&lt;/a&gt;入门教程&lt;/h1&gt;&lt;h2 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java学习" scheme="http://example.com/tags/Java%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-4</title>
    <link href="http://example.com/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/"/>
    <id>http://example.com/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/</id>
    <published>2021-04-15T13:07:44.000Z</published>
    <updated>2021-04-25T12:39:16.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI智能"><a href="#AI智能" class="headerlink" title="AI智能"></a>AI智能</h1><h2 id="寻路导航创建"><a href="#寻路导航创建" class="headerlink" title="寻路导航创建"></a>寻路导航创建</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在主面板左上角的“放置actor”面板中找到“导航网格体边界体积”，放入场景中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/1.png" alt="1"></p><p>调整体积大小，将需要建构导航的场景放入该体积</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/2.png" alt="2"></p><p>点击后生成类似如图的绿色地面区域，这片区域为AI导航有效的区域</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/3.png" alt="3"></p><h3 id="实例：实现敌对NPC追踪角色移动"><a href="#实例：实现敌对NPC追踪角色移动" class="headerlink" title="实例：实现敌对NPC追踪角色移动"></a>实例：实现敌对NPC追踪角色移动</h3><p>思路：使用AI控制器沿创建好的导航移动敌对NPC，目标为玩家控制的角色，并循环操作</p><p>关卡蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/8.png" alt="8"></p><p>敌对NPC角色蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/4.png" alt="4"></p><p>（AI未完待续）</p><h1 id="动画序列与蓝图"><a href="#动画序列与蓝图" class="headerlink" title="动画序列与蓝图"></a>动画序列与蓝图</h1><h2 id="过场动画制作"><a href="#过场动画制作" class="headerlink" title="过场动画制作"></a>过场动画制作</h2><p>创建一个过场动画的关卡序列，命名并打开操作界面</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/9.png" alt="9"></p><p>新建一个相机剪切轨道，并且绑定用于拍摄过场动画的电影摄像机actor（或是直接在场景中选中指定相机，通过actor到sequencer直接添加），将相机移动到起始位置，添加变换轨道（或其他轨道）并在起始位置添加关键帧</p><p>制作动画时，其他actor也可添加移动轨道，详细在下一个子目录“动画轨道”中</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/10.png" alt="10"></p><p>多次移动相机到指定位置，并在轨道上添加相应的关键帧（场景中能够看到相机移动的轨迹呈现），最后调整动画结束的准线，结束修改并保存</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/12.png" alt="12"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/11.png" alt="11"></p><p>当拍摄多个动画后，可将需要拼接的动画放入一个新的关卡序列中，上下移动调整轨道，左右移动调整播放顺序，并将结束准线对齐</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/13.png" alt="13"></p><p>多段动画中间可建立渐变轨道的关键帧，实现切换的淡入淡出</p><h2 id="动画轨道"><a href="#动画轨道" class="headerlink" title="动画轨道"></a>动画轨道</h2><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/14.png" alt="14"></p><p>Actor到Sequencer：创建一个控制actor的轨道，在场景中选中的actor会优先显示在顶端**<em>（创建actor后一般自带一个控制actor移动的transfrom轨道，也可以自己添加变换轨道）**</em></p><p>添加文件夹：可为多个轨道分类，放置于不同的文件夹下（好像没什么用的样子）</p><p>音频轨道：可在动画播放同时添加音频资产的播放</p><p>事件轨道：分为触发器和中继器（后者不常用），触发器轨道中添加了关键帧后，右键新建末端可新建图表事件，当时间轴移动到指定位置执行该事件</p><p>相机剪切轨道：用于添加相机轨道，使用actor到sequencer添加时也会自动创建</p><p>镜头轨道：用于拼接多个镜头的轨道，也可以实现多个动画序列之间的拼接</p><p>时间膨胀轨道：用于设置播放倍率的关键帧，实现部分慢镜头和快进</p><p>渐变轨道：添加动画的黑幕（1为全黑，0为透明），多个关键帧可实现淡入淡出</p><p><strong><em>【注：如果在单独一个元件下添加轨道，则所有轨道都作为其子元件，该元件的组件也可以实现调用为子元件，同时，在单一元件下还能够创建可视性轨道，调整特定时间下的actor是否可见。</em></strong></p><p><strong><em>特别地，对于相机actor来说，需要先获取CameraComponent子元件才能够更改具体具体属性（如：曝光补偿等）】</em></strong></p><h2 id="相机晃动"><a href="#相机晃动" class="headerlink" title="相机晃动"></a>相机晃动</h2><p>【需要创建蓝图类-MatineeCameraShake文件】</p><h4 id="振荡设置"><a href="#振荡设置" class="headerlink" title="振荡设置"></a>振荡设置</h4><p>振荡时长：振荡的总时长</p><p>振荡混入时间：振荡开始的时间</p><p>振荡混出时间：振荡结束的时间</p><p>旋转振荡：实现镜头的各方位旋转振荡（如决定上下振荡或者左右振荡，或者两者混合等）</p><p>位置振荡：实现镜头的移动性振荡（如决定相机位置前后振荡等）</p><p>FOV振荡：实现镜头的缩放性振荡（相机位置不变，只是镜头缩放）</p><h4 id="具体蓝图使用"><a href="#具体蓝图使用" class="headerlink" title="具体蓝图使用"></a>具体蓝图使用</h4><ol><li><p>在需要使用的蓝图流程中加入以下结点</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/15.png" alt="15"></p></li></ol><ol start="2"><li><p>在动画序列中相机组件下添加相机晃动子元件，可以拖拽缩放抖动条</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/16.png" alt="16"></p></li></ol><h2 id="动画蓝图"><a href="#动画蓝图" class="headerlink" title="动画蓝图"></a>动画蓝图</h2><p>打开某个骨骼/网格体/动画序列/物理模型时，可在右上角看到动画蓝图标识</p><p><strong><em>【注：此处以第三人称游戏模板的小白人为例】</em></strong></p><p>打开默认的动画图表【AnimGraph】，找到默认状态机，双击打开</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/5.png" alt="5"></p><p>状态机内部蓝图：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-1.png" alt="6-1"></p><p>Entry为一个输入/起始点，Idle/Run节点为走或跑时，JumpStart、Loop、End分别为跳跃的开始，腾空，落地过程，四个节点分别播放不同的动画，双箭头为四个节点互相切换的条件（右键添加状态可添加节点，通过节点引线引出的新节点与原节点之间自带转换条件）</p><p>Idle/Run节点内部：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-2.png" alt="6-2"></p><p>此处混合空间播放器节点下方为一段动画，具有三个白色关键帧（第一个与绿色关键帧重合），由绿色关键帧的位置（speed的大小）决定播放的动画，而在动画播放时，绿色关键帧如果未到达下一个白色关键帧，将循环播放上一个白色关键帧的动画</p><p>JumpStart、Loop、End节点内部：</p><p><strong><em>【注：因为结构相同故而使用JumpStart作为范例】</em></strong></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-3.png" alt="6-3"></p><p>由Idle/Run节点到JumpStart与从JumpLoop到JumpEnd节点的切换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-5.png" alt="6-5"></p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-6.png" alt="6-6"></p><p>前者：判断角色是否在空中，如果是，转换到下一个节点（即JumpStart节点）</p><p>后者：判断角色是否不在空中，如果是，转换到下一个节点（即JumpEnd节点）</p><p>由JumpStart到JumpLoop与由JumpEnd到Idle/Run节点的转换条件：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/6-4.png" alt="6-4"></p><p>判断前一个节点（JumpStart或JumpEnd）中动画资产播放的剩余时间是否小于0.1，如果是，则转换到下一个节点（JumpLoop或Idle/Run）</p><p>动画蓝图事件图表：</p><p><img src="/2021/04/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-4/7.png" alt="7"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI智能&quot;&gt;&lt;a href=&quot;#AI智能&quot; class=&quot;headerlink&quot; title=&quot;AI智能&quot;&gt;&lt;/a&gt;AI智能&lt;/h1&gt;&lt;h2 id=&quot;寻路导航创建&quot;&gt;&lt;a href=&quot;#寻路导航创建&quot; class=&quot;headerlink&quot; title=&quot;寻路导航创</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-4</title>
    <link href="http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/"/>
    <id>http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</id>
    <published>2021-04-14T12:10:46.000Z</published>
    <updated>2021-04-23T12:06:46.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><p>队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code>typedef struct &#123;    Elemtype *base;                //储存空间的基址指针    int front;                    //定义一个头指针    int rear;                    //定义一个尾指针&#125;SQqueue;</code></pre><p><strong>注：此处front和rear指针仅仅设为了int类型，而并非真正的指针类型，所表述的是队头队尾元素所在的位置下标</strong></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code>bool initqueue(SQqueue &amp;sq)&#123;    sq.base=new Elemtype[MAXSIZE];            //为队列分配空间    if(!sq.base) return false;                //没能分配成功，返回失败    sq.front=sq.rear=0;                        //头尾指针置为零，队列为空    return true;&#125;</code></pre><h2 id="求队列长度"><a href="#求队列长度" class="headerlink" title="求队列长度"></a>求队列长度</h2><pre><code>int queuelength(SQqueue &amp;sq)&#123;    return (sq.rear-sq.front+MAXSIZE)%MAXSIZE;&#125;</code></pre><p>注：在没有特殊注明的情况下，所说队列都为循环队列，front指向队头元素，rear指向队尾元素的后一个元素，为区分队空与队满，此处少用一个元素空间，即队列空间大小为m-1个元素时队满，故而当队列满足“rear=front“时队空，当队列满足”(rear+1)%MAXSIZE=front“时队满。</p><h2 id="入队（从队尾插入）"><a href="#入队（从队尾插入）" class="headerlink" title="入队（从队尾插入）"></a>入队（从队尾插入）</h2><pre><code>bool enterqueue(SQqueue &amp;sq,Elemtype e)          //传址需要操作的表，传值入队元素&#123;    if((sq.rear+1)%MAXSIZE==sq.front) return false;    //判断队满时返回失败    sq.base[sq.rear]=e;                     //让队尾元素的后一个元素等于e    sq.rear=(sq.rear+1)%MAXSIZE;         //队尾指针后移    return true；                        //返回成功入队&#125;</code></pre><h2 id="出队（从队头删除）"><a href="#出队（从队头删除）" class="headerlink" title="出队（从队头删除）"></a>出队（从队头删除）</h2><pre><code>bool deletequeue(SQqueue &amp;sq,Elemtype &amp;e)&#123;    if(sq.front==sq.rear) return false;        //若队空，则返回出队失败    e=sq.base[sq.front];                    //用e获得出队的队头元素    sq.front=(sq.front+1)%MAXSIZE;            //队头指针后移    return true;                            //返回成功出队&#125;</code></pre><h2 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h2><pre><code>Elemtype gethead(SQqueue &amp;sq)//仅返回表的队头元素，不修改头指针&#123;    if(sq.front!=sq.rear)             //判断队列非空    return     sq.base[sq.front];        //返回队头元素&#125;</code></pre><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-4-队列操作-20-分"><a href="#R7-4-队列操作-20-分" class="headerlink" title="R7-4 队列操作 (20 分)"></a>R7-4 队列操作 (20 分)</h2><p>请实现一个MyQueue类，实现出队，入队，求队列长度.</p><p>实现入队函数 void push(int x); 实现出队函数 int pop(); 实现求队列长度函数 int size();</p><p>输入格式:<br>每个输入包含1个测试用例。每个测试用例第一行给出一个正整数 n (n &lt;= 10^6) ，接下去n行每行一个数字，表示一种操作： 1 x ： 表示从队尾插入x，0&lt;=x&lt;=2^31-1。 2 ： 表示队首元素出队。 3 ： 表示求队列长度。</p><p>输出格式:<br>对于操作2,若队列为空，则输出 “Invalid”,否则请输出队首元素。 对于操作3，请输出队列长度。 每个输出项最后换行。</p><p>输入样例:</p><pre><code>5321 10032</code></pre><p>输出样例:</p><pre><code>0Invalid1100</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *base;    int front;    int rear;&#125;SQueue;bool init(SQueue &amp;sq)&#123;    sq.base=new int[50];    if(!sq.base) return false;    sq.front=0;    sq.rear=0;    return true;&#125;int length(SQueue &amp;sq)&#123;    return (sq.rear-sq.front+50)%50;&#125;bool enter(SQueue &amp;sq,int a)&#123;    if((sq.rear+1)%50==sq.front) return false;    sq.base[sq.rear]=a;    sq.rear=(sq.rear+1)%50;    return true;&#125;bool out(SQueue &amp;sq,int &amp;a)&#123;    if(sq.front==sq.rear) return false;    a=sq.base[sq.front];    sq.front=(sq.front+1)%50;    return true;&#125;int main()&#123;    SQueue L;    init(L);    int n,i,j,k;    cin&gt;&gt;n;    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;j;        switch(j)        &#123;            case 1:                cin&gt;&gt;k;                enter(L,k);                break;            case 2:                if(out(L,k)) cout&lt;&lt;k&lt;&lt;endl;                else cout&lt;&lt;&quot;Invalid&quot;&lt;&lt;endl;                break;            case 3:                cout&lt;&lt;length(L)&lt;&lt;endl;                break;        &#125;    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;顺序队列&quot;&gt;&lt;a href=&quot;#顺序队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列&quot;&gt;&lt;/a&gt;顺序队列&lt;/h1&gt;&lt;p&gt;队列是先进先出的线性结构，也是只能从队头删除，从队尾插入的线性表，为了使空间利用更加充分，从而避免假溢出，通常采用循环队列&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-3</title>
    <link href="http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/"/>
    <id>http://example.com/2021/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</id>
    <published>2021-04-14T07:37:35.000Z</published>
    <updated>2021-04-23T11:23:20.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><p>【Elemtype为数据类型】</p><p>顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相较普通顺序表简单。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="c++">typedef struct &#123;    Elemtype *base;                    //定义栈底指针    Elemtype *top;                    //定义栈顶指针    int maxsize;                    //定义最大栈的最大容量&#125;SQstack;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="c++">bool initstack(SQstack &amp;sq)            //传址需要初始化的表&#123;    sq.base=new Elemtype[MAXSIZE];    //分配大小为MAXSIZE的空间，并返回首地址给表的栈底指针    if(!sq.base) return false;      //若分配失败则返回    sq.top=sq.base;                    //栈顶指针等于栈底指针，表示空栈    sq.maxsize=MAXSIZE;                //记录栈的最大容量为MAXSIZE    return true;                    //返回创建成功&#125;</code></pre><h2 id="入栈（从栈顶插入）"><a href="#入栈（从栈顶插入）" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><pre><code class="c++">bool Push(SQstack &amp;sq,Elemtype e)        //传址需要操作的栈，传值需要入栈的值&#123;    if(sq.top-sq.base&gt;=sq.maxsize) return false;    //若栈顶指针与栈底指针的差为最大空间（即栈满），返回入栈失败    *sq.top=e;    //栈顶指针总是指在栈顶元素的下一个位置，故而直接赋值    sq.top++;                            //栈顶指针后移    return true;                        //返回入栈成功&#125;</code></pre><h2 id="出栈（从栈顶删除）"><a href="#出栈（从栈顶删除）" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><pre><code class="c++">bool Pop(SQstack &amp;sq,Elemtype &amp;e)            //传址需要操作的表和出栈的元素&#123;    if(sq.top==sq.base) return false;    //若栈顶指针与栈底指针相同（即栈空），则返回失败    sq.top--;    //栈顶指针总是指在栈顶元素的下一个位置，故而栈顶指针后移    e=*sq.top;                                //将出栈的元素传给e    return true;&#125;</code></pre><h2 id="取栈顶（取值）"><a href="#取栈顶（取值）" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><pre><code class="c++">Elemtype gettop(SQstack &amp;sq)//传址需要操作的表，返回栈顶元素，该操作只取栈顶，不修改栈顶指针&#123;    if(sq.top!=sq.base)            //若该栈非空    &#123;    return *(sq.top-1);            //取栈顶指针的前一个位置，即栈顶元素向外传递    &#125;&#125;</code></pre><h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><p>【Elemtype为数据类型】</p><p>在无法估计栈数据量时，通常采用链式栈，而且因为栈的主要操作是插入和删除，所以用链表的头部作栈顶更加方便。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><pre><code class="c++">typedef struct Lnode&#123;    Elemtype data;            //定义链表结点的数据域    struct Lnode *next;        //定义指向下一节点的指针域&#125;*Linkstack;</code></pre><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><pre><code class="c++">bool initstack(Linkstack &amp;ls)&#123;    ls=NULL;    //由于栈不需要对栈顶以外的元素操作，故而不需要设置头结点来使表头操作与表中表尾一致    return true;            //返回初始化成功&#125;</code></pre><h2 id="入栈（从栈顶插入）-1"><a href="#入栈（从栈顶插入）-1" class="headerlink" title="入栈（从栈顶插入）"></a>入栈（从栈顶插入）</h2><pre><code class="c++">bool Push(Linkstack &amp;ls,Elemtype e)        //传址需要操作的表，传值需要插入的元素&#123;    Lnode *p;    p=new Lnode;                //重新分配一个结点空间，首地址赋给p    p-&gt;data=e;                    //新结点的数据域为e    p-&gt;next=ls;                    //新结点的指针域指向头指针ls，即将新结点作头插    ls=p;                        //头指针前移    return true;                //返回入栈成功&#125;</code></pre><h2 id="出栈（从栈顶删除）-1"><a href="#出栈（从栈顶删除）-1" class="headerlink" title="出栈（从栈顶删除）"></a>出栈（从栈顶删除）</h2><pre><code class="c++">bool Pop(Linkstack &amp;ls，Elemtype &amp;e)   //传址需要操作的表和出栈的元素&#123;    if(ls==NULL) return false;        //栈空则返回删除失败    e=ls-&gt;data;                        //e接收出栈元素    Lnode *p=ls;                    //定义一个p指针指向原栈顶元素    ls=ls-&gt;next;                    //让头指针后移    delete p;                        //删除p指向的结点    return true;                    //返回删除完成&#125;</code></pre><h2 id="取栈顶（取值）-1"><a href="#取栈顶（取值）-1" class="headerlink" title="取栈顶（取值）"></a>取栈顶（取值）</h2><pre><code class="c++">Elemtype gettop(Linkstack &amp;ls)    //传址需要操作的表&#123;    if(ls!=NULL)                //栈非空    return ls-&gt;data;            //返回栈顶元素的值，栈顶指针不变&#125;</code></pre><h1 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h1><h2 id="R7-1-堆栈操作合法性-20-分"><a href="#R7-1-堆栈操作合法性-20-分" class="headerlink" title="R7-1 堆栈操作合法性 (20 分)"></a>R7-1 堆栈操作合法性 (20 分)</h2><p>假设以S和X分别表示入栈和出栈操作。如果根据一个仅由S和X构成的序列，对一个空堆栈进行操作，相应操作均可行（如没有出现删除时栈空）且最后状态也是栈空，则称该序列是合法的堆栈操作序列。请编写程序，输入S和X序列，判断该序列是否合法。</p><p>输入格式:<br>输入第一行给出两个正整数N和M，其中N是待测序列的个数，M（≤50）是堆栈的最大容量。随后N行，每行中给出一个仅由S和X构成的序列。序列保证不为空，且长度不超过100。</p><p>输出格式:<br>对每个序列，在一行中输出YES如果该序列是合法的堆栈操作序列，或NO如果不是。</p><p>输入样例：</p><pre><code>4 10SSSXXSXXSXSSSXXSXXSSSSSSSSSSSXSSXXXXXXXXXXXSSSXXSXXX</code></pre><p>输出样例：</p><pre><code class="：">YESNONONO</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct&#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq,int m)&#123;    sq.base=new char[m];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=m;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return false;    sq.top--;    return true;&#125;bool push(SQstack &amp;sq,char e)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=e;    sq.top++;    return true;&#125;int main()&#123;    int n,m,i,j=0;    bool flag=true;    cin&gt;&gt;n&gt;&gt;m;    string str;    SQstack L;    for(i=0;i&lt;n;i++)    &#123;        init(L,m);        cin&gt;&gt;str;        flag=true;        for(j=0;str[j]!=&#39;\0&#39;;j++)        &#123;            if(str[j]==&#39;S&#39;)             &#123;                flag=push(L,str[j]);            &#125;            if(str[j]==&#39;X&#39;)             &#123;                flag=pop(L);            &#125;        &#125;    if(L.base==L.top&amp;&amp;flag==true) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;    return 0;&#125;</code></pre><h2 id="R7-2-回文判断-20-分"><a href="#R7-2-回文判断-20-分" class="headerlink" title="R7-2 回文判断 (20 分)"></a>R7-2 回文判断 (20 分)</h2><p>回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。编写一个程序，使用栈判定给定的字符序列是否为回文。</p><p>输入格式:<br>输入待判断的字符序列，按回车键结束，字符序列长度&lt;20。</p><p>输出格式:<br>若字符序列是回文，输出“YES”；否则，输出“NO”。</p><p>输入样例:</p><pre><code>abdba</code></pre><p>输出样例:</p><pre><code>YES</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct &#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq)&#123;    sq.base=new char[20];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=20;    return true;&#125;bool push(SQstack &amp;sq,char a)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=a;    sq.top++;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return false;    sq.top--;    return true;&#125;bool gettop(SQstack &amp;sq,int &amp;a)&#123;    if(sq.base==sq.top) return false;    a=*(sq.top-1);    return true;&#125;int main()&#123;    SQstack L;    init(L);    string str;    int i,n=0,a;    bool flag=true;    cin&gt;&gt;str;    n=str.size();    if(n%2==0)    &#123;        for(i=0;i&lt;n;i++)        &#123;            if(i&lt;n/2) push(L,str[i]);            else             &#123;                gettop(L,a);                if(str[i]==a) pop(L);                else                 &#123;                    flag=false;                    break;                &#125;            &#125;        &#125;    &#125;    else    &#123;        for(i=0;i&lt;n;i++)        &#123;            if(i==(n-1)/2);            else             &#123;                if(i&lt;(n-1)/2) push(L,str[i]);                else                 &#123;                    gettop(L,a);                    if(str[i]==a) pop(L);                    else                     &#123;                        flag=false;                        break;                    &#125;               &#125;        &#125;    &#125;    &#125;            if(flag==true) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125;</code></pre><h2 id="R7-3-括号匹配-20-分"><a href="#R7-3-括号匹配-20-分" class="headerlink" title="R7-3 括号匹配 (20 分)"></a>R7-3 括号匹配 (20 分)</h2><p>检查一段C语言代码的小括号( )、 中括号 [ ] 和大括号{ } 是否匹配。</p><p>输入格式:<br>在一行中输入一段C语言代码，长度不超过1000个字符（行末以换行符结束）。</p><p>输出格式:<br>第一行输出左括号的数量和右括号的数量，中间以一个空格间隔。<br>若括号是匹配的，在第二行打印YES，否则打印NO。</p><p>输入样例1:</p><pre><code>for(int i=0; i&lt;v; i++)&#123; visited[i] = 0; for(int j=0; j&lt;v; j++) scanf(&quot;%d&quot;,&amp;(g-&gt;Adj[i][j])); &#125;</code></pre><p>输出样例1:</p><pre><code>8 8YES</code></pre><p>输入样例2:</p><pre><code>for(int i=0; i&lt;v; i++) a(i]=0;</code></pre><p>输出样例2:</p><pre><code>2 2NO</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;typedef struct&#123;    char *top;    char *base;    int size;&#125;SQstack;bool init(SQstack &amp;sq)&#123;    sq.base=new char[500];    if(!sq.base) return false;    sq.top=sq.base;    sq.size=500;    return true;&#125;bool push(SQstack &amp;sq,char a)&#123;    if(sq.top-sq.base==sq.size) return false;    *sq.top=a;    sq.top++;    return true;&#125;bool pop(SQstack &amp;sq)&#123;    if(sq.top==sq.base) return true;    sq.top--;    return true;&#125;bool gettop(SQstack &amp;sq,char &amp;a)&#123;    if(sq.top==sq.base) return false;    a=*(sq.top-1);    return true;&#125;int main()&#123;    SQstack L;    init(L);    char a=&#39;1&#39;;    bool flag=true;    int i,left=0,right=0,k=0;    char str[500];    for(i=0;i&lt;500;i++)    &#123;        cin&gt;&gt;str[i];        k++;    &#125;    for(i=0;i&lt;k;i++)    &#123;        if(str[i]==&#39;(&#39;||str[i]==&#39;[&#39;||str[i]==&#39;&#123;&#39;)        &#123;            left++;            push(L,str[i]);        &#125;        else        &#123;        if(str[i]==&#39;)&#39;||str[i]==&#39;]&#39;||str[i]==&#39;&#125;&#39;)        &#123;            right++;            gettop(L,a);            if((str[i]==&#39;)&#39;&amp;&amp;a==&#39;(&#39;)||(str[i]==&#39;]&#39;&amp;&amp;a==&#39;[&#39;)||(str[i]==&#39;&#125;&#39;&amp;&amp;a==&#39;&#123;&#39;))            &#123;                pop(L);            &#125;            else flag=false;        &#125;        &#125;    &#125;    if(L.top!=L.base) flag=false;    if(left==0&amp;&amp;right==0) flag=true;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;    if(flag) cout&lt;&lt;&quot;YES&quot;;    else cout&lt;&lt;&quot;NO&quot;;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;p&gt;顺序栈本身是操作受限制的顺序表，只能在栈顶做插入删除，称入栈出栈，因为操作受限，算法相</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-3</title>
    <link href="http://example.com/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/"/>
    <id>http://example.com/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/</id>
    <published>2021-04-13T12:28:08.000Z</published>
    <updated>2021-04-20T14:43:07.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础功能实现"><a href="#基础功能实现" class="headerlink" title="基础功能实现"></a>基础功能实现</h1><h2 id="人物操作功能"><a href="#人物操作功能" class="headerlink" title="人物操作功能"></a>人物操作功能</h2><h3 id="疾跑"><a href="#疾跑" class="headerlink" title="疾跑"></a>疾跑</h3><p>思路:在按下对应键（暂定shift）时，更改人物行走最大速度</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/1.png" alt="1"></p><h3 id="射击（创建发射物）"><a href="#射击（创建发射物）" class="headerlink" title="射击（创建发射物）"></a>射击（创建发射物）</h3><p>思路：在按下对应键（暂定鼠标左键）时，生成一个发射物</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/2.png" alt="2"></p><h3 id="过肩视角"><a href="#过肩视角" class="headerlink" title="过肩视角"></a>过肩视角</h3><p>思路：在按下对应键时（暂定鼠标右键），让视角缓缓变成过肩视角</p><p>玩家角色蓝图：（时间轴具体操作参考之前的节点介绍）</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/3.png" alt="3"></p><h3 id="★线检★"><a href="#★线检★" class="headerlink" title="★线检★"></a>★线检★</h3><p><strong><em>【注：案例的线检中“线”的长度为1000单位】</em></strong></p><p>思路：在actor正前方的创造一根不可见的线检测前方的物体，输出被检测到的物体，以便实现判断交互</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/4.png" alt="4"></p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p><strong><em>【注：案例中的”医疗包”为触碰即获得并消失，“门”为被线检到（最大距离为线的长度），并且按下F键时，实现“开门”，物体2为人物处于更小的范围或其他范围内，并按下F键时，实现拾取】</em></strong></p><p>思路：</p><ol><li>利用使用线检和类型转换判断物体属于什么类型，或判断开始重叠，然后执行对应的操作</li><li>在按下对应键时（暂定F键），判断可交互性，并判断线检检测到的物体，执行对应的自定义事件</li><li>在要交互的物体蓝图中设置其交互时执行的具体操作，即定义自定义事件</li></ol><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/5.png" alt="5"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/6.png" alt="6"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/9.png" alt="9"></p><p>“医疗包”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/10.png" alt="10"></p><p>“门”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/7.png" alt="7"></p><p>“物品2”类actor蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/8.png" alt="8"></p><h2 id="界面HUD"><a href="#界面HUD" class="headerlink" title="界面HUD"></a>界面HUD</h2><h3 id="显示HUD"><a href="#显示HUD" class="headerlink" title="显示HUD"></a>显示HUD</h3><p>思路：创建HUD控件之后，显示到视口</p><p>玩家角色蓝图：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/11.png" alt="11"></p><h3 id="显示交互按钮及其名称"><a href="#显示交互按钮及其名称" class="headerlink" title="显示交互按钮及其名称"></a>显示交互按钮及其名称</h3><p>指定/创建绑定函数：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/14.png" alt="14"></p><p><strong><em>（注：在文本、百分比、可视性等多个数据都可以使用函数绑定返回值来实现动态显示）</em></strong></p><p>思路：</p><ol><li>判断当前物体类型，按钮子项的文本函数返回不同的文本</li><li>判断当前物体是否为可交互物，可交互显示按钮，不可交互隐藏按钮</li></ol><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/12.png" alt="12"></p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/13.png" alt="13"></p><h3 id="显示角色血条"><a href="#显示角色血条" class="headerlink" title="显示角色血条"></a>显示角色血条</h3><p>思路：HUD中创建一个进度条，进度-百分比使用函数绑定，读取玩家角色的变量HP并返回</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/15.png" alt="15"></p><h3 id="制作标题及设置页面控件"><a href="#制作标题及设置页面控件" class="headerlink" title="制作标题及设置页面控件"></a>制作标题及设置页面控件</h3><p>标题页面控件：</p><ul><li><strong>事件构造时——“显示光标”，并”设置输入模式仅UI“</strong></li><li>开始——点击button时，执行“打开关卡”节点</li><li>退出——点击button时，执行“退出游戏”节点</li><li>设置——点击button时，创建“设置页面控件”，并“添加到视口”，将原来的标题控件“从父项中移除”</li></ul><p>设置页面控件：</p><p><strong><em>注：虚幻本身具有调节各种画质的设置，仅需要调用这套设置即可</em></strong></p><p>组合框设置初始显示值（显示当前抗锯齿与视图距离为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/17.png" alt="17"></p><p>组合框设置（后期处理质量设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/18.png" alt="18"></p><p>滑条操作（分辨率缩放设置为例）：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/19.png" alt="19"></p><p>返回按钮：</p><p><img src="/2021/04/13/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-3/20.png" alt="20"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础功能实现&quot;&gt;&lt;a href=&quot;#基础功能实现&quot; class=&quot;headerlink&quot; title=&quot;基础功能实现&quot;&gt;&lt;/a&gt;基础功能实现&lt;/h1&gt;&lt;h2 id=&quot;人物操作功能&quot;&gt;&lt;a href=&quot;#人物操作功能&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-2</title>
    <link href="http://example.com/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/"/>
    <id>http://example.com/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/</id>
    <published>2021-04-13T05:51:17.000Z</published>
    <updated>2021-04-27T14:11:29.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表单结构"><a href="#表单结构" class="headerlink" title="表单结构"></a>表单结构</h1><p>表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介</p><h2 id="表单的组成"><a href="#表单的组成" class="headerlink" title="表单的组成"></a>表单的组成</h2><ul><li><h3 id="表单标签-form"><a href="#表单标签-form" class="headerlink" title="表单标签-form"></a>表单标签-form</h3><pre><code class="html">&lt;form action=&quot;url&quot; method=&quot;get/post&quot; name=&quot;value&quot;&gt;    填入表单域和表单按钮等&lt;/form&gt;</code></pre><p><strong>action：</strong>表示接受并处理表单数据的服务器程序的url地址</p><p><strong>method：get</strong>为默认，表单数据和URL一起发送，提交的数据显示在浏览器地址栏中，保密性差，有数据量限制；<strong>post</strong>保密性好，并且无数据量限制，表单数据和URL分开发送，保密性好</p><p><strong>name：</strong>指定表单名称，以区分一个页面中的多个表单</p></li></ul><ul><li><h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><p><strong>表单常用控件</strong></p><table><thead><tr><th>属性</th><th>说明</th><th>预览</th></tr></thead><tbody><tr><td>input type=“date”</td><td>日期选择框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/8.png" alt="8"></td></tr><tr><td>input type=“text”</td><td>单行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/1.png" alt="1"></td></tr><tr><td>input type=“password”</td><td>密码输入框（输入的文字用*表示）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/2.png" alt="2"></td></tr><tr><td>input type=“radio”</td><td>单选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/3.png" alt="3"></td></tr><tr><td>input type=”checkbox“</td><td>复选框（同一个name属性起效）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/7.png" alt="7"></td></tr><tr><td>input type=“hidden”</td><td>隐藏域（不显示，供开发使用）</td><td>——————————</td></tr><tr><td>input type=“file”</td><td>文件域（上传文件）</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/4.png" alt="4"></td></tr><tr><td>select</td><td>列表框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/5.png" alt="5"></td></tr><tr><td>textarea</td><td>多行文本输入框</td><td><img src="/2021/04/13/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-2/6.png" alt="6"></td></tr></tbody></table></li></ul><p>  <strong>表单域常用属性</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>控件名称（公共属性，与每个表单域对应）</td></tr><tr><td>type</td><td>控件类型，如radio，text等</td></tr><tr><td>size</td><td>指定控件的宽度</td></tr><tr><td>value</td><td>用于设定输入默认值（公共属性，可用来指定输入区域默认值）</td></tr><tr><td>maxlength</td><td>在单行文本时允许输入的最大字符数</td></tr><tr><td>src</td><td>插入图像的地址</td></tr></tbody></table><ul><li><h3 id="表单按钮"><a href="#表单按钮" class="headerlink" title="表单按钮"></a>表单按钮</h3><p><strong>普通按钮:触发提交表单的动作，配合JavaScript使用</strong></p><pre><code class="html">&lt;input type=&quot;button&quot; name=&quot;name值&quot;/&gt;</code></pre><p><strong>提交按钮：将表单中的信息提交给表单中action指向的文件</strong></p><pre><code class="html">&lt;input type=&quot;submit&quot; name=&quot;button_name&quot; id=&quot;button_id&quot; value=&quot;提交&quot;&gt;</code></pre><p><strong>图片式提交按钮：指可以在按钮位置上放置图片，这幅图片具有提交按钮的功能</strong></p><pre><code class="html">&lt;input type=&quot;image&quot; /&gt;</code></pre><p><strong>重置按钮：指清除已填写的表单内容，恢复为默认内容，重新填写</strong></p><pre><code class="html">&lt;input type=&quot;reset&quot; /&gt;</code></pre></li></ul><h1 id="H5结构性标签"><a href="#H5结构性标签" class="headerlink" title="H5结构性标签"></a>H5结构性标签</h1><h2 id="header"><a href="#header" class="headerlink" title="header"></a>header</h2><p>网页页眉的结构标签，位于网页的最上端，一般header标签至少包含但不局限于一个标题，还可以包括hgroup标签，包括表格内容，网页封面，logo图案，搜索表单和nav等。</p><h2 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h2><p>网页中的导航条，是navigator的缩写，常用无序列表的形式加上css外观配置实现，一般置于header下方。</p><p>nav标签可以应用于传统导航条，侧边栏导航，页内导航，翻页操作等场合</p><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><p>用于对网页中的内容进行分区分块，定义文档中的节。一般情况下，section标签常由标题和内容组成。</p><p><strong>注意：</strong></p><ul><li>section标签表示一段专题性的内容，一般会带有标题，没有标题的区块不要用section定义</li><li>根据实际情况来看，若是article标签，aside标签或是nav标签更符合使用条件，那么不要使用section标签</li><li>当一个容器需要被直接定义样式或通过脚本定义行为时，推荐使用div标签而不是section</li></ul><h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><p>一个特殊的section标签，比section具有更明确的语义，代表一个独立的，完整的相关内容块，可独立于页面其他内容使用</p><p><strong>注意：</strong></p><ul><li>article标签会有标题部分，通常可以包含header，有时也会包含footer</li><li>article可以嵌套，内层的article对外层的article标签有着隶属关系，如博客的文章可以用article显示，一些评论也可以以article的形式嵌入其中</li></ul><h2 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h2><p>aside标签用来装载非正文的内容，被视为页面里单独的一个部分，作为页面或站点全局的附属信息部分，例如广告，友链，侧边栏，导航条等等，可以被article包含在内</p><h2 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h2><p>footer定义section或document的页脚，包含了与页面、文章或是部分内容有关的信息，比如说作者和日期。</p><p>作为页面页脚时，一般包括版权，相关文件和链接</p><p>footer和header标签使用基本一样，可以在一个页面中多次使用，也可以在article或section中添加，相当于该区段的页脚</p><h2 id="框架示例："><a href="#框架示例：" class="headerlink" title="框架示例："></a>框架示例：</h2><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;title&gt;叮叮书店&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;div id=&quot;logo&quot; style=&quot;&quot;&gt;        &lt;header class=&quot;container&quot;&gt;            &lt;div id=&quot;logo&quot;&gt;                &lt;h1&gt;网站logo·叮叮书店(div)&lt;/h1&gt;            &lt;/div&gt;            &lt;div id=&quot;search&quot;&gt;                &lt;form&gt;                    &lt;input type=&quot;search&quot;/&gt;                    &lt;input type=&quot;button&quot; name=&quot;search&quot; value=&quot;搜索&quot;/&gt;                &lt;/form&gt;            &lt;/div&gt;        &lt;/header&gt;        &lt;/div&gt;        &lt;div id=&quot;nav&quot; style=&quot;&quot;&gt;            &lt;nav&gt;                &lt;div&gt;                    &lt;ul&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书籍分类&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;特刊降价&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;                        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                    &lt;/ul&gt;                &lt;/div&gt;                &lt;div id=&quot;cart&quot;&gt;&lt;a href=&quot;#&quot;&gt;购物车&lt;/a&gt;&lt;/div&gt;            &lt;/nav&gt;        &lt;/div&gt;        &lt;div&gt;        &lt;main&gt;        &lt;div id=&quot;adv&quot;&gt;            此处用于添加广告        &lt;/div&gt;        &lt;section id=&quot;recommend&quot;&gt;            &lt;h2&gt;本周推荐&lt;/h2&gt;            &lt;section class=&quot;recommend-book&quot;&gt;                &lt;h3&gt;书1标题&lt;/h3&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;div class=&quot;cover-1&quot;&gt;&lt;img src=&quot;img/prod2.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-1&quot;&gt;&lt;p&gt;&lt;mark&gt;书1&lt;/mark&gt;简介&lt;/p&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;section class=&quot;recommend-book&quot;&gt;                &lt;h3&gt;书2标题&lt;/h3&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;div class=&quot;cover-1&quot;&gt;&lt;img src=&quot;img/prod3.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-1&quot;&gt;&lt;p&gt;书2简介&lt;/p&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;        &lt;/section&gt;        &lt;section id=&quot;new&quot;&gt;            &lt;h2&gt;最近新书&lt;/h2&gt;            &lt;div class=&quot;content&quot;&gt;            &lt;section class=&quot;new-book&quot;&gt;                &lt;h3&gt;书3标题&lt;/h3&gt;            &lt;div class=&quot;effect-1&quot;&gt;                &lt;div class=&quot;cover-2&quot;&gt;&lt;img src=&quot;img/prod4.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-2&quot;&gt;                    &lt;h3&gt;书3标题&lt;/h3&gt;                    &lt;p&gt;书3简介&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;section class=&quot;new-book&quot;&gt;                &lt;h3&gt;书4标题&lt;/h3&gt;            &lt;div class=&quot;effect-1&quot;&gt;                &lt;div class=&quot;cover-2&quot;&gt;&lt;img src=&quot;img/prod1.jpg&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;description-2&quot;&gt;                    &lt;h3&gt;书4标题&lt;/h3&gt;                    &lt;p&gt;书4简介&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;cart-more&quot;&gt;&lt;a href=&quot;#&quot;&gt;加入购物车&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;详细内容&lt;/a&gt;&lt;/div&gt;            &lt;/div&gt;            &lt;/section&gt;            &lt;/div&gt;        &lt;/section&gt;        &lt;section id=&quot;sale&quot;&gt;            &lt;h2&gt;最近促销&lt;/h2&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;section id=&quot;sale-book&quot;&gt;                    &lt;h3&gt;书5标题&lt;/h3&gt;                    &lt;div class=&quot;effort-1&quot;&gt;                        &lt;div class=&quot;pic&quot;&gt;&lt;img src=&quot;img/prod1.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;sale&quot;&gt;&lt;img src=&quot;img/sale.jpg&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/section&gt;                &lt;section id=&quot;sale-book&quot;&gt;                    &lt;h3&gt;书6标题&lt;/h3&gt;                    &lt;div class=&quot;effort-1&quot;&gt;                        &lt;div class=&quot;pic&quot;&gt;&lt;img src=&quot;img/prod3.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;sale&quot;&gt;&lt;img src=&quot;img/sale.jpg&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/section&gt;            &lt;/div&gt;        &lt;/section&gt;        &lt;/main&gt;        &lt;/div&gt;        &lt;div&gt;        &lt;aside&gt;            &lt;div id=&quot;advert&quot;&gt;&lt;img src=&quot;img/ad1.jpg&quot;&gt;&lt;img src=&quot;img/ad2.jpg&quot;&gt;&lt;img src=&quot;img/ad3.jpg&quot;&gt;&lt;/div&gt;            &lt;section id=&quot;best-selling&quot;&gt;                &lt;h2&gt;畅销图书&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书1&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling1.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书1名&lt;/a&gt;&lt;strong&gt;书1现价&lt;/strong&gt;&lt;del&gt;书1原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书2&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling2.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书2名&lt;/a&gt;&lt;strong&gt;书2现价&lt;/strong&gt;&lt;del&gt;书2原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书3&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling3.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书3名&lt;/a&gt;&lt;strong&gt;书3现价&lt;/strong&gt;&lt;del&gt;书3原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书4&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling4.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书4名&lt;/a&gt;&lt;strong&gt;书4现价&lt;/strong&gt;&lt;del&gt;书4原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;书5&lt;/a&gt;                    &lt;div class=&quot;curr&quot;&gt;                        &lt;div class=&quot;c-pic&quot;&gt;&lt;img src=&quot;img/selling5.jpg&quot;&gt;&lt;/div&gt;                        &lt;div class=&quot;c-text&quot;&gt;&lt;a href=&quot;#&quot;&gt;书5名&lt;/a&gt;&lt;strong&gt;书5现价&lt;/strong&gt;&lt;del&gt;书5原价&lt;/del&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;div id=&quot;classify-partner&quot;&gt;            &lt;section id=&quot;classify&quot;&gt;                &lt;h2&gt;图书分类&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;编程语言&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;数据库&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;图形图像&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页制作&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;考试认证&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;section id=&quot;partner&quot;&gt;                &lt;h2&gt;合作伙伴&lt;/h2&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国电子商务研究中心&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;清华大学出版社&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国人民大学出版社&lt;/a&gt;&lt;/li&gt;                    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;中国社会科学出版社&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/section&gt;            &lt;/div&gt;            &lt;section id=&quot;about&quot;&gt;                &lt;h2&gt;关于书店&lt;/h2&gt;                &lt;div class=&quot;picture&quot;&gt;&lt;img src=&quot;img/about.gif&quot;&gt;&lt;/div&gt;                &lt;div class=&quot;content&quot;&gt;                    &lt;p&gt;书店介绍&lt;/p&gt;                &lt;/div&gt;            &lt;/section&gt;        &lt;/aside&gt;        &lt;/div&gt;        &lt;div id=&quot;footer-wrapper&quot;&gt;        &lt;footer class=&quot;container&quot;&gt;            &lt;ul&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务条款&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;隐私策略&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;        &lt;/footer&gt;        &lt;/div&gt;        &lt;div id=&quot;copyright&quot; class=&quot;container&quot;&gt;            &lt;div&gt;copyright内容&lt;img src=&quot;img/vcss.gif&quot;&gt;&lt;/div&gt;            &lt;address&gt;通讯地址：            电话：            &lt;/address&gt;        &lt;/div&gt;    &lt;/div&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表单结构&quot;&gt;&lt;a href=&quot;#表单结构&quot; class=&quot;headerlink&quot; title=&quot;表单结构&quot;&gt;&lt;/a&gt;表单结构&lt;/h1&gt;&lt;p&gt;表单是收集用户的信息和反馈意见，是前端和后端数据的传递媒介&lt;/p&gt;
&lt;h2 id=&quot;表单的组成&quot;&gt;&lt;a href=&quot;#表单的</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-2</title>
    <link href="http://example.com/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/"/>
    <id>http://example.com/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/</id>
    <published>2021-04-09T10:28:08.000Z</published>
    <updated>2021-04-20T14:28:18.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><p>普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可</p><h2 id="材质域（常用）"><a href="#材质域（常用）" class="headerlink" title="材质域（常用）"></a>材质域（常用）</h2><p>材质的类型一般由材质域区分（材质界面左下角中，细节页的材质栏）</p><ul><li><h3 id="表面"><a href="#表面" class="headerlink" title="表面"></a>表面</h3><p>普通的基本材质，如木质、铁质、玻璃等覆盖在表面的东西</p></li><li><h3 id="延迟贴花"><a href="#延迟贴花" class="headerlink" title="延迟贴花"></a>延迟贴花</h3><p>类似等同于喷漆，混合模式只能是半透明，如同投影一样覆盖在物体表面，本质是Actor组件，但可以作为只有一个贴花组件的Actor放入场景</p></li><li><h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>用于UI显示，需要新建媒体播放器，使用媒体纹理生成材质，更改材质域为“用户界面”，在用户UI中添加图像时便可以使用该材质放入外观-笔刷中。</p><p>注：使用生成的材质时，需要在UI图表中添加默认值为该材质源媒体播放器的媒体播放器变量，并且事件构造中通过该变量添加对应播放器的“打开源”，如下图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/8.png" alt="8"></p></li></ul><p>左二接口接入媒体播放器（仅作为媒介），而左三接口则接入具体的视频媒体</p><h2 id="混合模式（常用）"><a href="#混合模式（常用）" class="headerlink" title="混合模式（常用）"></a>混合模式（常用）</h2><ul><li><h3 id="不透明"><a href="#不透明" class="headerlink" title="不透明"></a>不透明</h3><p>整个材质完全不透光，一般作为底层材质</p></li><li><h3 id="半透明"><a href="#半透明" class="headerlink" title="半透明"></a>半透明</h3><p>材质呈现半透明，可以和下层叠加，一般是作为贴花使用</p></li></ul><h2 id="材质节点引脚（常用）"><a href="#材质节点引脚（常用）" class="headerlink" title="材质节点引脚（常用）"></a>材质节点引脚（常用）</h2><ul><li><h3 id="基础颜色"><a href="#基础颜色" class="headerlink" title="基础颜色"></a>基础颜色</h3><p>材质的基本图像，可以是纯色或贴图，是整个材质的主外观</p></li><li><h3 id="Metallic"><a href="#Metallic" class="headerlink" title="Metallic"></a>Metallic</h3><p>一般叫做金属度，针对金属材质，设置金属的质感，反光光泽等</p></li><li><h3 id="高光度"><a href="#高光度" class="headerlink" title="高光度"></a>高光度</h3><p>基本用于非金属表面，一般输入一张比标准贴图亮的贴图，用于扩大光照面和暗面的对比，也可以直接输入一个具体的值，改变整体的反光强度，类似对比度</p></li><li><h3 id="粗糙度"><a href="#粗糙度" class="headerlink" title="粗糙度"></a>粗糙度</h3><p>决定材质的粗糙程度，0为完全光滑的镜面反射，1为完全粗糙的漫反射</p></li><li><h3 id="自发光颜色"><a href="#自发光颜色" class="headerlink" title="自发光颜色"></a>自发光颜色</h3><p>控制材质发光部位，设置自发光颜色或强度</p></li><li><h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><p>法线，输入一张法线贴图，用于记录材质不同位置的凹凸感</p></li><li><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>输入一个很小的数，影响折射率，可以实现透明玻璃之类的折射，<strong>但效果不怎么样</strong></p></li></ul><h2 id="材质快捷键节点"><a href="#材质快捷键节点" class="headerlink" title="材质快捷键节点"></a>材质快捷键节点</h2><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/1.png" alt="1"></p><p>快捷键：1+Left</p><p>具体作用：创建一个常数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/3.png" alt="3"></p><p>快捷键：3+Left</p><p>具体作用：创建一个常量颜色值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/2.png" alt="2"></p><p>快捷键：s+Left</p><p>具体作用：创建一个变量数值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/6.png" alt="6"></p><p>快捷键：V+Left</p><p>具体作用：创建一个颜色变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/5.png" alt="5"></p><p>快捷键：U+Left</p><p>具体作用：创建一个UV缩放节点，用于缩放贴图</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/4.png" alt="4"></p><p>快捷键：A+Left</p><p>具体作用：将两种颜色或贴图叠加在一起</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/7.png" alt="7"></p><p>快捷键：M+Left</p><p>具体作用：将两种颜色或贴图混合在一起，一般用选定颜色乘白色贴图进行染色</p><h2 id="材质实例"><a href="#材质实例" class="headerlink" title="材质实例"></a>材质实例</h2><p>由材质生成的材质实例将材质蓝图中的变量节点显示于右面接口，通过改变接口值来更加直观的实时改变材质的颜色等各种属性，能够实现一个材质创造一堆材质实例的操作</p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>同c的结构体变量类型相同，可以设置一个结构体变量中包含多个普通类型变量，并设置默认值，不能使用自身类型的变量嵌套</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/9.png"></p><p>在蓝图中使用时，通过make节点创建结构体并连接set对应的结构体变量，可初始化的设定其各个变量的值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/11.png" alt="11"></p><p>使用break节点拆分结构体，可以得到其中指定的单个变量</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/10.png" alt="10"></p><h2 id="蓝图函数库"><a href="#蓝图函数库" class="headerlink" title="蓝图函数库"></a>蓝图函数库</h2><p>类似于头文件，但并不只是函数声明，而是完整的函数编辑，对于同一个文件，可以在左侧边栏里添加多个函数，而且所定义的所有函数均为全局函数</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/12.png" alt="12"></p><p>和c与c++的函数不同，虚幻引擎的函数可以有多个输入，多个输出</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/13.png" alt="13"></p><p>反应在引用该函数的蓝图上就是对应变量的接口</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/14.png" alt="14"></p><h2 id="蓝图宏库"><a href="#蓝图宏库" class="headerlink" title="蓝图宏库"></a>蓝图宏库</h2><p>类似于函数库，但创建与普通蓝图相似，用于创建自定义节点，通常选择创建actor或是object</p><p>默认的宏库中只有一个新建宏0和没有接口的输入输出节点，可选择输入输出节点后在右下角细节面板添加</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/15.png" alt="15"></p><p>不同于函数的是，设置宏的输入输出时，额外可以设置的还有执行引脚</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/22.png" alt="22"></p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/20.png" alt="20"></p><p>若在蓝图宏库中写入以上内容，则在其他蓝图中引用宏时能够得到下面节点</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/21.png" alt="21"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举类型会将数据定义成具体的内容，例如bool型中，0定义为了false，1定义为了true，创建面板如下，可通过右侧的“新”添加新的枚举值</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/16.png" alt="16"></p><p>在蓝图中设置枚举变量也和其他变量类型的操作相同</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/17.png" alt="17"></p><p>用switch连上枚举类型的话，可以用于判断枚举类型，切换流程</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/18.png" alt="18"></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>相当于编辑器里的Beginplay（事件开始运行），事件面板中的内容在编辑器中不会运行，只有测试时才会执行，但构造函数里的内容编辑器中也会执行，并且不断更新，只要改动就会产生实时变化。</p><p>简要来说，在蓝图中写入“设置actor位置”无法在场景中看到actor位置变化，但在选项卡中改动x，y，z数值却会直接改变actor位置，后者就属于构造函数中的内容</p><h2 id="媒体播放器"><a href="#媒体播放器" class="headerlink" title="媒体播放器"></a>媒体播放器</h2><p>媒体播放器仅仅是视频文件的播放载体，放入媒体播放器的文件仅仅是预览，具体文件播放的内容需要在蓝图或场景中设置（详细的使用在前面“材质-用户界面”有讲）</p><p><strong>注：UE4支持的视频文件格式应该是.avi，音频文件是.wav，导入时需要注意</strong></p><h2 id="物理材质"><a href="#物理材质" class="headerlink" title="物理材质"></a>物理材质</h2><p>如字面意思，用于体现物体物理状态的材质，主要是设定摩擦力</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/23.png" alt="23"></p><p>物理材质可以在材质面板中赋给某个特定的材质，改变使用这个材质的所有模型的物理材质，也可以在场景中赋予单个模型，后者为物理材质的重载，会针对选定模型覆盖原有的物理材质</p><h2 id="用户界面-1"><a href="#用户界面-1" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="控件蓝图"><a href="#控件蓝图" class="headerlink" title="控件蓝图"></a>控件蓝图</h3><ul><li><h4 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h4><p>默认新建的控件蓝图中会生成一个画布面板，可以通过多个面板与面板的排列或是互相之间的嵌套完成一整套hud或是UI的设置</p></li><li><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一般只使用可编辑文本和文本框，可编辑文本允许玩家/用户编辑，没有背景，而文本框是开发者设定的文字，显示上有背景；</p><p>其中没有备注的均为单行，不能换行，而标注了多行，也仅仅是多行文本框支持换行，并不意味着自动换行</p><p><strong>右侧的细节面板中（以文本框为例）</strong></p><p>【锚点栏】</p><p>1.锚点主要针对屏幕比例不同时，设定UI位置的参考系</p><p>2.大小到内容是使整个控件大小和内容（比如文字长度）相同</p><p>3.Zorder是上下层数，重叠时最上层数值最大</p><p>【内容栏】文本为固定出现的文本，而提示文本则是仅文本框为空才出现的内容</p><p>【外观栏】</p><p>1.支持更换文本框的背景图片，悬停为鼠标悬停，聚焦指鼠标点击</p><p>2.填充指缩进部分，数值越大，缩进越多</p><p>3.字体轮廓设置时可以选择对投影应用轮廓，让阴影部分也具有描边</p><p>4.删除线可导入图片作为删除线</p><p>5.阴影偏移能够设定阴影与文字的位置差，相当于调整投影的光的角度</p><p>【行为栏】</p><p>1.不勾选“已启用”则显示控件，但不能交互（未开放或不能按的按钮）</p><p>2.可视性：针对可见和占据空间及子项能否交互分类，详情鼠标悬停在选项上</p></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>导入字体格式一般为otf，ttf也可行，对同种字体同时导入多个文件时，需要否定引擎导入时的新建（否则会每个文件导入一个字体资产），另外自行新建字体资产，分配字体族系</p><p><img src="/2021/04/09/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-2/24.png" alt="24"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;材质&quot;&gt;&lt;a href=&quot;#材质&quot; class=&quot;headerlink&quot; title=&quot;材质&quot;&gt;&lt;/a&gt;材质&lt;/h1&gt;&lt;p&gt;普通材质的文件下边框为浅绿色，直接资源管理器中右键创建即可&lt;/p&gt;
&lt;h2 id=&quot;材质域（常用）&quot;&gt;&lt;a href=&quot;#材质域（常用）&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>虚幻引擎-1</title>
    <link href="http://example.com/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/"/>
    <id>http://example.com/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/</id>
    <published>2021-04-02T11:43:30.000Z</published>
    <updated>2021-04-20T14:28:02.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快捷键节点："><a href="#快捷键节点：" class="headerlink" title="快捷键节点："></a>快捷键节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/1.png" alt="1"></p><p>节点名：延迟</p><p>呼出方式：（快捷键）D+left</p><p>具体作用：实现程序暂停，延迟一段时间继续执行后续节点</p><p>接口：Duration——延迟时长，单位为秒</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/2.png" alt="2"></p><p>节点名：分支</p><p>呼出方式：（快捷键）B+left</p><p>具体作用：实现程序因布尔值变化而条件分歧</p><p>接口：Condition——决定选择支的布尔值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/3.png" alt="3"></p><p>节点名：序列</p><p>呼出方式：（快捷键）S+left</p><p>具体作用：使多个分支同时进行</p><p>接口：Then——同时进行的分支接口</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/4.png" alt="4"></p><p>节点名：For each loop</p><p>呼出方式：（快捷键）F+left</p><p>具体作用：根据数组元素的个数执行循环</p><p>接口：array——需要遍历的数组</p><p>Loop body——循环体</p><p>Array Element——当前数组元素的值</p><p>Array Index——当前数组元素的下标</p><p>Completed——循环出口</p><h1 id="普通节点："><a href="#普通节点：" class="headerlink" title="普通节点："></a>普通节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/5.png" alt="5"></p><p>节点名：获取类的所有actor</p><p>呼出方式：右键查询（使用节点名或get all actor）</p><p>具体作用：获取场景中所有某类的实例</p><p>接口：Actor Class——需要获取的类</p><p>Out Actors——选中类的所有actor的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/6.png" alt="6"></p><p>节点名：自定义事件（事件名称）</p><p>呼出方式：右键查询（使用节点名或custom event）</p><p>具体作用：定义一个自定义事件</p><p>接口：无</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/11.png" alt="11"></p><p>节点名：（事件名称）</p><p>呼出方式：右键查询（使用节点名查找引用）</p><p>具体作用：引用一个在某蓝图中定义好的自定义事件</p><p>接口：无</p><h1 id="时间轴与变换节点："><a href="#时间轴与变换节点：" class="headerlink" title="时间轴与变换节点："></a>时间轴与变换节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/10.png" alt="10"></p><p>节点名：时间轴</p><p>呼出方式：右键查询（使用节点名或timeline）</p><p>具体作用：创建时间轴（用于播放动画等）</p><p>接口：play——正放</p><p>play from start——从头正放</p><p>stop——暂停</p><p>Reverse——倒放</p><p>Reverse from End——从最后倒放</p><p>Set New Time——跳转到特定时间轴</p><p>New Time——设定跳转到的特定时间轴（需要Set New Time启用）</p><p>Update——在时间轴移动时不断执行</p><p>Finished——时间轴结束后执行（无论正放倒放）</p><p>Direction——为时间轴进行方向，可在update或finished后接入switch判断正放倒放</p><p>*创建时间轴和圆滑曲线化：</p><p>通常使用浮点型轨道（f+），键入轨道名称后会出现相应接口，返回时间轴窗口创建关键帧，在两个不同关键帧间会形成对应时间和值的变化直线（折线），最后修改时间轴总长度等于有效变化直线的时间，若同时将两个或以上的关键帧插值改为“用户”型，可通过调整其切线使整个变化折线变为曲线，更加圆滑的完成值的变化</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/12.png" alt="12"></p><p>节点名：拆分变换</p><p>呼出方式：右键查找（使用节点名或break）</p><p>具体作用：将一个变换过程拆分成L、R、S三者</p><p>接口：In Transform——需要拆分的变换</p><p>Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/13.png" alt="13"></p><p>节点名：创建变换</p><p>呼出方式：右键查找（使用节点名或make）</p><p>具体作用：合并L、R、S三者为一个变换过程</p><p>接口：Location——位置变化量</p><p>Rotation——旋转变化量</p><p>Scale——缩放变化量</p><p>Return value——变换的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/15.png" alt="15"></p><p>节点名：插值</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个值随时间变化中特定比例处的值</p><p>接口：A——变化开始时值的初始量</p><p>B——变化结束时值的终点量</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/16.png" alt="16"></p><p>节点名：插值（向量）</p><p>呼出方式：右键查找（使用节点名或lerp）</p><p>具体作用：取出某个向量随时间变化中特定比例处的值</p><p>接口：A——变化开始时向量的初始值</p><p>B——变化结束时向量的终点值</p><p>Alpha——变化量占A，B差值的比例（只能为0~1）</p><p>Return Value——返回初始值加变化量的结果</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/14.png" alt="14"></p><p>节点名：已限制映射范围</p><p>呼出方式：右键查找（使用节点名或Clamp）</p><p>具体作用：将基准值实现In A~In B的变化，并且按In和Out的A、B比例缩放</p><p>接口：Value——输入的基准值</p><p>In Range A——输入的初始比例</p><p>In Range B——输入的终点比例</p><p>Out Range A——输出的初始比例</p><p>Out Range B——输出的终点比例</p><p>Return Value——返回变化且缩放后的值</p><p>注：上文所提到的普通插值可视作In A=0.0，In B=1.0的该节点</p><h1 id="运算节点："><a href="#运算节点：" class="headerlink" title="运算节点："></a>运算节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/17.png" alt="17"></p><p>节点名：限制（浮点）</p><p>呼出方式：右键查找（使用节点名或clamp）</p><p>具体作用：将数据限制在范围内，范围外的数小于min的输出min，大于max输出max</p><p>接口：Value——输入值</p><p>Min——范围的最小值</p><p>Max——范围的最大值</p><p>Return Value——数据限制后的返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/18.png" alt="18"></p><p>节点名：截断</p><p>呼出方式：右键查找（使用节点名）/将浮点数据直接接入整数接口</p><p>具体作用：将数据向0舍入，截断小数部分</p><p>注：1.6舍入为1，但-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/19.png" alt="19"></p><p>节点名：底部</p><p>呼出方式：右键查找（使用节点名或floor）</p><p>具体作用：将数据向负无穷舍入，下舍到前一个整数</p><p>注：1.6舍入为1，但-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/20.png" alt="20"></p><p>节点名：顶部</p><p>呼出方式：右键查找（使用节点名）</p><p>具体作用：将数据向正无穷/向上舍入到下一个整数</p><p>注：1.6舍入为2，而-1.6舍入为-1</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/21.png" alt="21"></p><p>节点名：舍入</p><p>呼出方式：右键查找（使用节点名或round）</p><p>具体作用：将数据舍入到最近的整数</p><p>注：1.6舍入为2，而-1.6舍入为-2</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/22.png" alt="22"></p><p>节点名：（dot）</p><p>呼出方式：右键查找（点乘积）</p><p>具体作用：计算向量点乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/23.png" alt="23"></p><p>节点名：（cross）</p><p>呼出方式：右键查找（叉乘积）</p><p>具体作用：计算向量叉乘</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/24.png" alt="24"></p><p>节点名：范围内随机浮点（其他数据类型也可）</p><p>呼出方式：右键查找（使用节点名或random float）</p><p>具体作用：生成随机浮点数</p><p>接口：min——最小值</p><p>max——最大值</p><p>return value——范围内的随机数</p><h1 id="选择节点："><a href="#选择节点：" class="headerlink" title="选择节点："></a>选择节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/7.png" alt="7"></p><p>节点名：切换整型</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：利用整数切换引脚流程</p><p>接口：Selection——作为切换标准的整型</p><p>Default——不满足其他引脚时的默认执行引脚</p><p>注：除切换为整型以外，其他类型的数据也可使用switch查找对应类型的切换</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/9.png" alt="9"></p><p>节点名：开启字符串【翻译可能有误】</p><p>呼出方式：右键查询（使用节点名或switch）</p><p>具体作用：输入指定字符串选择完全相同的引脚执行</p><p>接口：Selection——输入作为判断依据的字符</p><p>Default——不满足其他引脚时的默认执行引脚</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/8.png" alt="8"></p><p>节点名：选择</p><p>呼出方式：右键查询（使用节点名或select）</p><p>具体作用：通过输入的内容得到已设定的返回值</p><p>接口：Option 0，Option 1——设置给出的index值得到的返回值</p><p>Index——可以接入任何类型的通配符</p><p>Return value——返回值的出口</p><h1 id="控制器节点："><a href="#控制器节点：" class="headerlink" title="控制器节点："></a>控制器节点：</h1><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/26.png" alt="26"></p><p>节点名：设置仅输入模式游戏</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在游戏界面中心</p><p>接口：Player Controller——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/25.png" alt="25"></p><p>节点名：设置仅输入模式UI</p><p>呼出方式：右键查询（使用节点名或input only）</p><p>具体作用：设置鼠标的输入模式，将光标锁定在某个UI上</p><p>接口：Player Controller——接玩家控制器</p><p>In Widget to Focus——将光标锁定在该接口指定的UI上</p><p>In Mouse Lock Mode——设置系统光标状态</p><p>注：In Mouse Lock Mode接口分不锁定、捕获时锁定、固定锁定、锁定为全屏；捕获时锁定指运行窗口在最前端时将系统光标锁定在程序窗口内，直到win键强行解锁；固定锁定指一直将系统光标锁定在程序窗口内，直到win键强行解锁；锁定为全屏指仅全屏时锁定光标。</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/31.png" alt="31"></p><p>节点名：获取玩家控制器/角色/pawn</p><p>呼出方式：右键查询（使用节点名或蓝色引脚牵出搜索get player）</p><p>具体作用：得到一个玩家控制器的返回值</p><p>接口：Player Index——玩家控制器的序号</p><p>Return Value——返回玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/33.png" alt="33"></p><p>节点名：（set）</p><p>呼出方式：右键查询（show mouse）[需要取消情境关联]</p><p>具体作用：设置鼠标的显示</p><p>接口：Show Mouse Cursor——是否显示鼠标</p><p>目标——接玩家控制器</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/32.png" alt="32"></p><p>节点名：生成Actor</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：凭空创建一个actor</p><p>接口：Class——生成的actor类型</p><p>Spawn Transform——指定actor初始变换（生成位置、缩放、旋转度）</p><p>Collision Handing Override——判断生成的条件（和碰撞体积有关）</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/27.png" alt="27"></p><p>节点名：销毁Actor</p><p>呼出方式：右键查询（使用节点名或destroy）</p><p>具体作用：销毁目标Actor</p><p>接口：目标——被销毁的对象</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/30.png" alt="30"></p><p>节点名：构建</p><p>呼出方式：右键查询（使用节点名或create）</p><p>具体作用：创建一个UI</p><p>接口：Class——UI的类型</p><p>Owning Player——指定UI属于哪一个玩家</p><p>Return Value——生成的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/29.png" alt="29"></p><p>节点名：添加到视口</p><p>呼出方式：右键查询（使用节点名或牵引构建ui的返回值引脚，输入add to）</p><p>具体作用：让创建的UI显示到用户界面</p><p>接口：目标——接已创建的UI</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/28.png" alt="28"></p><p>节点名：从父项中移除</p><p>呼出方式：右键查询（使用节点名或remove from parent）</p><p>具体作用：移除目标控件</p><p>接口：目标——需要移除的控件</p><h1 id="数组节点"><a href="#数组节点" class="headerlink" title="数组节点"></a>数组节点</h1><p>创建数组：在创建好的变量左侧图标上右键，能够创建一个同类型变量的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/34.png" alt="34"></p><p>节点名：获取数组元素（上为复制，下为引用）</p><p>呼出方式：右键查询（使用节点名或数组引线查询get）</p><p>具体作用：获取数组中指定下标的元素</p><p>接口：（数组接口）——该元素所在数组</p><p>（整数型接口）——需要获取的数组元素下标</p><p>（右值）——返回值（复制返回值，引用返回地址）</p><p>注：该节点分为复制和引用两种方式，同c/c++中函数的传值和引用传址，复制会生成副本，引起的变化不改变数组本身，而引用则可以改变数组内元素的值，但操作不当易使数据受损</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/35.png" alt="35"></p><p>节点名：创建数组</p><p>呼出方式：右键查询（使用节点名或从set左值牵引查询make）</p><p>具体作用：创建一个数组</p><p>接口：左侧——设置序号下的数组值</p><p>右侧——得到数组变量</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/36.png" alt="36"></p><p>节点名：（set）</p><p>呼出方式：有引出变量的情况下，输入set查询</p><p>具体作用：设置数组</p><p>接口：左侧——被设置的对象变量数组</p><p>右侧——接已经创建的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/37.png" alt="37"></p><p>节点名：设置阵列元素</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询set）</p><p>具体作用：设置数组单个元素的值</p><p>接口：Target Array——接该元素所在数组</p><p>Index——指定的数组元素的序号</p><p>Item——为该数组元素所赋的值</p><p>Size to Fit——当index大于数组大小时，数组将扩展</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/38.png" alt="38"></p><p>节点名：查找项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：查找与给定值相等的数组下标</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/39.png" alt="39"></p><p>节点名：为有效索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：判断能否查找到指定元素</p><p>接口：左侧——数组与需要查找的给定值</p><p>右侧——能否找到的bool值返回</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/40.png" alt="40"></p><p>节点名：添加</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在数组最后添加一个元素</p><p>接口：左侧——数组与需要添加的值</p><p>右侧——数组序号返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/41.png" alt="41"></p><p>节点名：插入</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：在指定下标处插入一个元素，其他元素自动后移</p><p>接口：左侧——数组与需要查找的给定值，以及需要插入的位置序号</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/42.png" alt="42"></p><p>节点名：长度</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：返回数组长度</p><p>接口：左侧——数组</p><p>右侧——数组长度返回值</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/43.png" alt="43"></p><p>节点名：清空</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：清空整个数组</p><p>接口：左侧——需要清空的数组</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/44.png" alt="44"></p><p>节点名：移除项目</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除等于这个值的元素</p><p>接口：左侧——数组与需要移除的给定值</p><p>右侧——返回是否成功移除</p><p><img src="/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E-1/45.png" alt="45"></p><p>节点名：移除索引</p><p>呼出方式：右键查询（使用节点名或牵引数组接口查询array）</p><p>具体作用：移除这个下标的元素</p><p>接口：左侧——数组和元素下标</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快捷键节点：&quot;&gt;&lt;a href=&quot;#快捷键节点：&quot; class=&quot;headerlink&quot; title=&quot;快捷键节点：&quot;&gt;&lt;/a&gt;快捷键节点：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/02/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%9</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="虚幻引擎学习" scheme="http://example.com/tags/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-2</title>
    <link href="http://example.com/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/"/>
    <id>http://example.com/2021/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</id>
    <published>2021-03-30T06:14:43.000Z</published>
    <updated>2021-04-21T08:34:44.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-单链表"><a href="#线性表-单链表" class="headerlink" title="线性表-单链表"></a>线性表-单链表</h1><p>【Elemtype为数据类型】</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="链表结点结构体创建"><a href="#链表结点结构体创建" class="headerlink" title="链表结点结构体创建"></a>链表结点结构体创建</h3><pre><code>typedef struct LNode        //创建结点类型&#123;    elemtype data;         //结点中包含数据域    struct LNode *next;    //结点中包含指向下一个结点的指针&#125;*Linklist                 //将该类型定义为一个链表（常使用指针方式价）</code></pre><h3 id="尾插法创建"><a href="#尾插法创建" class="headerlink" title="尾插法创建"></a>尾插法创建</h3><pre><code class="c++">void create(Linklist &amp;L,int n)//传址需要创建的表L，以及初始表长n&#123;    L=new Lnode;        //为L新分配一个地址    L-&gt;next=NULL;        //将L的next设为空（前两步为初始化）    Lnode *E=L;            //令新指针指向L指向的头结点    int i,a;    Lnode *p;            //定义另一个指向结点的指针p    for(i=1;i&lt;=n;i++)        &#123;     cin&gt;&gt;a;            //输入数据a     p=new Lnode;        //令p指向新建结点     p-&gt;data=a;            //将新建结点的数据域赋值为a     E-&gt;next=p;            //令E的next指向p指向的结点     p-&gt;next=NULL;        //p的next指向空     E=p;                //指针E后移，指向p指向的结点    &#125;&#125;</code></pre><h3 id="头插法创建"><a href="#头插法创建" class="headerlink" title="头插法创建"></a>头插法创建</h3><pre><code>void create(Linklist &amp;L，int n)//传址需要创建的表L，以及初始表长n&#123;    L=new LNode;    L-&gt;next=NULL;    int i,a;    struct LNode *p;    cin&gt;&gt;a;    for(i=1;a!=-1;i++)    &#123;    p=new LNode;    p-&gt;data=a;    p-&gt;next=L-&gt;next;    L-&gt;next=p;    cin&gt;&gt;a;    &#125;&#125;</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>注：初始化应当在尾插和头插法前使用，或者不使用</p><pre><code class="c++">bool init(Linklist &amp;L)       //传址创建的链表&#123;    L=new LNode;            //新生成一个结点，让头指针指向头结点    L-&gt;next=NULL;          //为统一操作，头结点仅作为首元结点的前驱，数据域不放入数据，且指针域指向空    return true;           //返回值提示完成初始化&#125;</code></pre><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>单链表的取值需要顺序遍历，耗时较长，故而不适合频繁获取特定位置的值</p><pre><code class="c++">bool getelem(Linklist &amp;L,int i,elemtype &amp;e)//传址数据所在的表，并且传值需要取值的元素序号i，将得到的值传给e&#123;    int j;    LNode *p=L-&gt;next;               //令p指向首元结点    for(j=1;j&lt;i&amp;&amp;p!=NULL;j++)       //j作为计数器，确定遍历到的位置，当p指针指向空或j==i时结束循环    &#123;        p=p-&gt;next;                  //让p指向p的下一个结点，实现p后移    &#125;                               //结束循环时，j==i，p指向的结点为第i-1个结点     if(p==NULL) return false;       //如果p指针指向空，则返回取值失败    e=p-&gt;next-&gt;data;                //否则，将p指向结点的下一个结点的数据域赋给e    return true;                   //返回取值完成&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>单链表的查找同顺序表一样，需要遍历整个表，比较每个数据域和待查找值，若相同则返回其序号，若始终不相同则返回查找失败</p><pre><code class="c++">bool find(Linklist &amp;L,LNode *&amp;p,elemtype a)//传址需要查找的表，查找成功时用于指向查找结果的指针p，同时传值需要查找的数据a&#123;    int j;    p=L-&gt;next;    for(j=1;p-&gt;next!=NULL;j++)      //j作为计数器，确定遍历到的位置，当p指针指向为空时结束循环    &#123;        if(p-&gt;data==a) break;       //查找到与数据a相同的数据域，提前退出循环        p=p-&gt;next;                  //p指针继续后移，继续遍历整个链表    &#125;    if(p-&gt;next==NULL&amp;&amp;p-&gt;data!=a)   return false;      //如果p指针已经指向尾结点，且尾结点数据域域不等于a，则查找失败    //p指针直接能够返回需要查找的节点，不需要另外设置返回    return true;                   //返回查找成功&#125;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时，需要先让新结点连接需要插入位置前驱的后一个结点，再让前驱的next指针指向新结点，否则会直接丢失后面数据的地址</p><pre><code class="c++">bool insert(Linklist &amp;L,int i，elem e)//传址链表，需要插入的位置i，需要插入的元素值e&#123;    int j;    Lnode *p=L-&gt;next;                //使p指针指向首元结点    Lnode *s=new Lnode;              //新建一个结点，并用s指针指向它    s-&gt;data=e;                       //将新建结点的数据域赋为e    for(j=0;j&lt;i-1&amp;&amp;p!=NULL;j++)          //当j移动到需要插入位置的前驱时或者链表结束时结束循环    &#123;        p=p-&gt;next;                   //让p指向下一个结点    &#125;    if(p==NULL) return false;        //如果p指向不合法位置则返回插入失败    s-&gt;next=p-&gt;next;                 //否则让s的next指针指向p的下一个结点    p-&gt;next=s;                       //并让p的next指针指向s    return true;                     //返回成功插入&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="c++">bool del(Linklist &amp;L,int i)&#123;    int j;    Lnode *p=L-&gt;next;                //使p指向首元结点    for(j=0;j&lt;i-1&amp;&amp;p!=NULL)               //当j移动到需要删除位置的前驱或链表结束时结束循环    &#123;        p=p-&gt;next;                  //让p指向p的下一个结点    &#125;    if(p=NULL) return false;        //p指向不合法位置时，返回删除失败    p-&gt;next=p-&gt;next-&gt;next;          //让p的next指针等于p下一个结点的next    return true;                    //返回删除成功&#125;</code></pre><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-3-单链表的创建及遍历-20-分"><a href="#R7-3-单链表的创建及遍历-20-分" class="headerlink" title="R7-3 单链表的创建及遍历 (20 分)"></a>R7-3 单链表的创建及遍历 (20 分)</h3><p>读入n值及n个整数，建立单链表并遍历输出。</p><p>输入格式:<br>读入n及n个整数。</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><pre><code>210 5</code></pre><p>输出样例:<br>在这里给出相应的输出。例如：</p><pre><code>10 5</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode *next;&#125;*Linklist;void create(Linklist &amp;L,int n)&#123;    L=new Lnode;    L-&gt;next=NULL;    if(n&gt;0)     &#123;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;i&lt;=n;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;    &#125;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;        if(L-&gt;next==NULL) return 0;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist list;    int n;    cin&gt;&gt;n;    create(list,n);    putout(list);    return 0;&#125;</code></pre><h3 id="R7-1-两个有序链表序列的合并-20-分"><a href="#R7-1-两个有序链表序列的合并-20-分" class="headerlink" title="R7-1 两个有序链表序列的合并 (20 分)"></a>R7-1 两个有序链表序列的合并 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><pre><code>1 3 5 -12 4 6 8 10 -1</code></pre><p>输出样例:</p><pre><code>1 2 3 4 5 6 8 10</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode* next;&#125;*Linklist;bool init(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;    return true;&#125;void create(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;a!=-1;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;&#125;bool addit(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)&#123;    struct Lnode *p1=l1-&gt;next,*p2=l2-&gt;next, *p3;    l3=l1;    p3=l3;    while(p1&amp;&amp;p2)    &#123;            if(p1-&gt;data&lt;=p2-&gt;data)            &#123;                p3-&gt;next=p1;                p3=p1;                p1=p1-&gt;next;            &#125;            else &#123;                p3-&gt;next=p2;                p3=p2;                p2=p2-&gt;next;            &#125;    &#125;    p3-&gt;next=p1?p1:p2;    return true;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;                if(L-&gt;next==NULL) &#123;        cout&lt;&lt;&quot;NULL&quot;; return 0;&#125;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist L1,L2,L3;    create(L1);    create(L2);    init(L3);    addit(L1,L2,L3);    putout(L3);    return 0;&#125;</code></pre><h3 id="R7-2-两个有序链表序列的交集-20-分"><a href="#R7-2-两个有序链表序列的交集-20-分" class="headerlink" title="R7-2 两个有序链表序列的交集 (20 分)"></a>R7-2 两个有序链表序列的交集 (20 分)</h3><p>已知两个非降序链表序列S1与S2，设计函数构造出S1与S2的交集新链表S3。</p><p>输入格式:<br>输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。</p><p>输出格式:<br>在一行中输出两个输入序列的交集序列，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。</p><p>输入样例:</p><pre><code>1 2 5 -12 4 5 8 10 -1</code></pre><p>输出样例:</p><pre><code>2 5</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct Lnode&#123;    int data;    struct Lnode* next;&#125;*Linklist;bool init(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;    return true;&#125;void create(Linklist &amp;L)&#123;    L=new Lnode;    L-&gt;next=NULL;        Lnode *E=L;        int i,a;        struct Lnode *p;        cin&gt;&gt;a;        for(i=1;a!=-1;i++)        &#123;        p=new Lnode;        p-&gt;data=a;        E-&gt;next=p;        p-&gt;next=NULL;        E=p;        cin&gt;&gt;a;        &#125;&#125;bool find(Linklist &amp;L,int a)&#123;    int j;    struct Lnode *p;    p=L-&gt;next;    for(j=1;p-&gt;next!=NULL;j++)          &#123;        if(p-&gt;data==a) break;               p=p-&gt;next;                     &#125;    if(p-&gt;next==NULL&amp;&amp;p-&gt;data!=a)   return false;                  return true;  &#125;bool cutit(Linklist &amp;l1,Linklist &amp;l2,Linklist &amp;l3)&#123;    struct Lnode *p1=l1-&gt;next,*p2=l2-&gt;next,*p3=l3;    while(p1&amp;&amp;p2)    &#123;        if(p1-&gt;data&lt;p2-&gt;data)        &#123;            p1=p1-&gt;next;        &#125;        else        if(p1-&gt;data==p2-&gt;data)        &#123;            p3-&gt;next=p1;            p3=p3-&gt;next;            p1=p1-&gt;next;            p2=p2-&gt;next;        &#125;        else        if(p1-&gt;data&gt;p2-&gt;data)        &#123;            p2=p2-&gt;next;        &#125;    &#125;    if(p3-&gt;next!=NULL) p3-&gt;next=NULL;    return true;&#125;int putout(Linklist &amp;L)&#123;    int i;        struct Lnode *p=L;        if(L-&gt;next==NULL) &#123;        cout&lt;&lt;&quot;NULL&quot;; return 0;&#125;    for(i=0;p-&gt;next-&gt;next!=NULL;i++)    &#123;        cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot; &quot;;        p=p-&gt;next;    &#125;    cout&lt;&lt;p-&gt;next-&gt;data;    return 0;&#125;int main()&#123;    Linklist L1,L2,L3;    create(L1);    create(L2);    init(L3);    cutit(L1,L2,L3);    putout(L3);    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表-单链表&quot;&gt;&lt;a href=&quot;#线性表-单链表&quot; class=&quot;headerlink&quot; title=&quot;线性表-单链表&quot;&gt;&lt;/a&gt;线性表-单链表&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;h2 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; clas</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-1</title>
    <link href="http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
    <id>http://example.com/2021/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</id>
    <published>2021-03-24T11:02:30.000Z</published>
    <updated>2021-04-08T12:22:00.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表-顺序表"><a href="#线性表-顺序表" class="headerlink" title="线性表-顺序表"></a>线性表-顺序表</h1><p>【Elemtype为数据类型】</p><h2 id="创建（初始化）"><a href="#创建（初始化）" class="headerlink" title="创建（初始化）"></a>创建（初始化）</h2><p>以数组的形式创建顺序表</p><pre><code>typedef struct      //理解为将定义的结构体改称为&#123;&#125;后的名字，如SQlist&#123;    Elemtype *elem； //定义顺序表具有首元素地址    int length;     //定义顺序表具有表长这一属性&#125;SQlist;</code></pre><p>初始化设置顺序表的最大存储空间，以及初始化其表长为0</p><pre><code>bool initList(SQlist &amp;sq)     //将需要初始化的表传址&#123;    sq.elem=new maxsize;        //为顺序表分配maxsize的空间作为最大上限    if(!sq.elem) return false;      //如果空间分配失败，直接返回提示错误    sq.length=0;                    //如果分配空间成功，则继续初始化表长为0    return true;                    //返回参数提示顺序表初始化成功&#125;</code></pre><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>顺序表能够随机存取，故而方便存取指定位置的值，即可以随机存取</p><pre><code>bool getelem(SQlist &amp;sq,int i，elemtype &amp;a)  //将需要初始化的表传址，并且传值需要获取的是第i个值，返回的值传给a&#123;    if(i&lt;1||i&gt;sq.length) return false;    //如果i为非法位置，返回提示错误    a=sq.elem[i];                 //否则返回第i个元素给a    return true;                  //返回提示执行正常&#125;</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>顺序表的查找就是顺序比较表内元素和待查找元素，相同查找成功，始终不同查找失败</p><pre><code>int find(SQlist &amp;sq,elemtype a)//传址需要查找的表，并传值需要查找的数值a,返回查找到的序号为int类型&#123;    int i;    for(i=0;i&lt;sq.length;i++)    &#123;    if(sq.elem[i]==a) return i;    //如果查找到了，返回该值在表中的序号，此处为数组下标，若返回第几个元素序号，则需要i+1    &#125;    return -1;            //查找失败，返回负数&#125;</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>顺序表为紧邻的线性表，故而插入时需要向后移动较多元素，并且需要从最后一个元素开始向后移动，以免数据被覆盖</p><pre><code>bool insert(SQlist &amp;sq,elemtype a,int i)//将元素a的值插入表中第i个位置，传址需要做插入的表，以及传值a，i&#123;    int j;    if(i&lt;1||i&gt;sq.length+1) return false;//如果i值不合法，则不作插入    if(sq.length==maxsize) return false;//如果表长已经达到最大，则判断表满，不作插入    for(j=sq.length-1;j&gt;=i-1;j--)    //让j为最后一个元素的角标，循环递减，并且当j等于插入位置i的前驱时，停止循环    &#123;        sq.elem[j+1]=sq.elem[j];        //给j+1角标的空间赋值当前j角标的值，实现后移    &#125;    sq.elem[i-1]=a;                     //赋值第i个位置，即角标为i-1的空间为a    sq.length++;                        //表长增加    return true;                        //返回插入成功&#125;</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>顺序表的删除是将待删除位置后面的全部往前覆盖，向前移动较多元素，并且需要从待删除位置的后一个开始移动，以免覆盖数据</p><pre><code>bool delete(SQlist &amp;sq,int i)//传址需要删除元素的顺序表，并且传值需要删除的元素位置&#123;    int j;    if(i&lt;1||i&gt;sq.length) return false;   //如果i值不合法，则不作插入    for(j=i;j&lt;=sq.length-1;j++)    //将i位置之后的所有元素都向前移，并且循环在将最后一个元素移动到表长减一后的位置停止    &#123;        sq.elem[j-1]=sq.elem[j];        //被删位置后的元素全部前移    &#125;    sq.length--;                        //表长减少    return true;&#125;</code></pre><h2 id="实际题目"><a href="#实际题目" class="headerlink" title="实际题目"></a>实际题目</h2><h3 id="R7-1-顺序表的建立及遍历-20-分"><a href="#R7-1-顺序表的建立及遍历-20-分" class="headerlink" title="R7-1 顺序表的建立及遍历 (20 分)"></a>R7-1 顺序表的建立及遍历 (20 分)</h3><p>读入n值及n个整数，建立顺序表并遍历输出。</p><p>输入格式:<br>读入n及n个整数</p><p>输出格式:<br>输出n个整数，以空格分隔（最后一个数的后面没有空格）。</p><p>输入样例:<br>在这里给出一组输入。例如：</p><pre><code>4-3 10 20 78</code></pre><p>输出样例:<br>在这里给出相应的输出。例如：</p><pre><code>-3 10 20 78</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *a;    int length;&#125;List;int create(List &amp;sq)&#123;    sq.a= new int[100];    if(!sq.a) return 0;    sq.length=0;    return 1;&#125;int output(List &amp;sq)&#123;    int j;    cout&lt;&lt;sq.a[0];    for(j=1;j&lt;sq.length;j++)    &#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;sq.a[j];    &#125;&#125;int main()&#123;    List sqlist;    int i,n;    cin&gt;&gt;n;    create(sqlist);    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;sqlist.a[i];        sqlist.length++;    &#125;    if(sqlist.length!=0)         output(sqlist);    return 0;&#125;</code></pre><h3 id="R7-2-jmu-ds-顺序表区间元素删除-20-分"><a href="#R7-2-jmu-ds-顺序表区间元素删除-20-分" class="headerlink" title="R7-2 jmu-ds-顺序表区间元素删除 (20 分)"></a>R7-2 jmu-ds-顺序表区间元素删除 (20 分)</h3><p>若一个线性表L采用顺序存储结构存储，其中所有的元素为整数。设计一个算法，删除元素值在[x,y]之间的所有元素，要求算法的时间复杂度为O(n)，空间复杂度为O(1)。</p><p>输入格式:<br>三行数据，第一行是顺序表的元素个数，第二行是顺序表的元素，第三行是x和y。</p><p>输出格式:<br>删除元素值在[x,y]之间的所有元素后的顺序表。</p><p>输入样例:</p><pre><code>105 1 9 10 67 12 8 33 6 23 10</code></pre><p>输出样例:</p><pre><code>1 67 12 33 2</code></pre><p><strong>解法：</strong></p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;typedef struct&#123;    int *a;    int length;&#125;sqlist;bool create(sqlist &amp;sq)&#123;    sq.a= new int[100];    if(!sq.a) return false;    sq.length=0;    return true;&#125;bool del(sqlist &amp;sq,int x,int y)&#123;    int j,i;    for(j=0;j&lt;sq.length;j++)    &#123;        if(sq.a[j]&gt;=x&amp;&amp;sq.a[j]&lt;=y)        &#123;            for(i=j;i&lt;sq.length;i++)            &#123;                sq.a[i]=sq.a[i+1];            &#125;            sq.length--;            j--;        &#125;    &#125;&#125;int main()&#123;    sqlist List;    int n,i,x,y;    cin&gt;&gt;n;    create(List);    for(i=0;i&lt;n;i++)    &#123;        cin&gt;&gt;List.a[i];        List.length++;    &#125;    cin&gt;&gt;x&gt;&gt;y;    del(List,x,y);    cout&lt;&lt;List.a[0];    for(i=1;i&lt;List.length;i++)    &#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;List.a[i];    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性表-顺序表&quot;&gt;&lt;a href=&quot;#线性表-顺序表&quot; class=&quot;headerlink&quot; title=&quot;线性表-顺序表&quot;&gt;&lt;/a&gt;线性表-顺序表&lt;/h1&gt;&lt;p&gt;【Elemtype为数据类型】&lt;/p&gt;
&lt;h2 id=&quot;创建（初始化）&quot;&gt;&lt;a href=&quot;#创建（</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构学习" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习-5：string头文件</title>
    <link href="http://example.com/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/"/>
    <id>http://example.com/2021/03/23/c++%E5%AD%A6%E4%B9%A0-5/</id>
    <published>2021-03-22T23:41:02.000Z</published>
    <updated>2021-04-16T10:29:01.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：string"><a href="#头文件：string" class="headerlink" title="头文件：string"></a>头文件：string</h1><h2 id="用于简化操作的常用函数"><a href="#用于简化操作的常用函数" class="headerlink" title="用于简化操作的常用函数"></a>用于简化操作的常用函数</h2><ul><li><p>string变量读取单个字符用s[i]可以读出</p></li><li><p>输入带空格的字符串，用getline(cin,a)；(a为字符串类型变量)</p></li><li><p>str.=“”——清空</p></li><li><p>str.empty()——是否为空</p></li><li><p>str.size()——str长度</p></li><li><p>swap(s1，s2)——交换s1，s2</p></li><li><p>str. insert(x,“aaa”)——在下标x处插入aaa</p></li><li><p>str.substr(x,y)——读出下标为x开始长度为y的字符串</p></li><li><p>str.erase(x,y)——移除下标x长度为y的字符</p></li><li><p>str.find(“字符或字符串”)——找str中第一次出现的下标，找不到就是-1</p></li><li><p>while((i=str.find(“a”,i))!=-1) { i++; cout&lt;&lt;i&lt;&lt;endl; }  ——读出所有a字符出现的下标</p><p>  (基本思路是找到一个就从那个下标+1继续找)</p></li><li><p>str.replace(x，y，“aa”)——用aa替换(x，y)(删掉下标x开始长度为y个，在下标为x处插入aa)</p></li></ul><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>string s——生成一个空字符串s</p><p>string s(str) ——拷贝构造函数 生成str的复制品</p><p>string s(str,stridx)——将字符串str内“始于位置stridx”的部分当作字符串的初值</p><p>string s(str,stridx,strlen) ——将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</p><p>string s(cstr) ——将C字符串作为s的初值</p><p>string s(chars,chars_len) ——将C字符串前chars_len个字符作为字符串s的初值。</p><p> string s(num,c) ——生成一个字符串，包含num个c字符</p><p> string s(beg,end) ——以区间beg;end(不包含end)内的字符作为字符串s的初值</p><p>s.~string() ——销毁所有字符，释放内存</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p> =，assign()——赋以新值</p></li><li><p>swap()——交换两个字符串的内容</p></li><li><p>+=，append()，push_back()——在尾部添加字符</p></li><li><p>insert()——插入字符</p></li><li><p>erase()——删除字符</p></li><li><p>clear()——删除全部字符</p></li><li><p>replace()——替换字符</p></li><li><p>+——串联字符串</p></li><li><p>==，!=，&lt;，&lt;=，&gt;，&gt;=，compare()——比较字符串</p></li><li><p>size(),length()——返回字符数量</p></li><li><p>max_size()——返回字符的可能最大个数</p></li><li><p>empty()——判断字符串是否为空</p></li><li><p>capacity()——返回重新分配之前的字符容量</p></li><li><p>reserve()——保留一定量内存以容纳一定数量的字符</p></li><li><p> [ ], at()——存取单一字符</p></li><li><p>“&gt;&gt;”,getline()——从stream读取某值</p></li><li><p>” &lt;&lt;“ ——将谋值写入stream</p></li><li><p>copy()——将某值赋值为一个C_string</p></li><li><p>c_str()——将内容以C_string返回</p></li><li><p> data()——将内容以字符数组形式返回</p></li><li><p>substr()——返回某个子字符串</p></li><li><p>begin() end()——提供类似STL的迭代器支持</p></li><li><p> rbegin() rend()——逆向迭代器</p></li><li><p>get_allocator()——返回配置器</p></li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>find()<br>rfind()<br>find_first_of()<br>find_last_of()<br>find_first_not_of()<br>find_last_not_of()</p><p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下：<br>第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;头文件：string&quot;&gt;&lt;a href=&quot;#头文件：string&quot; class=&quot;headerlink&quot; title=&quot;头文件：string&quot;&gt;&lt;/a&gt;头文件：string&lt;/h1&gt;&lt;h2 id=&quot;用于简化操作的常用函数&quot;&gt;&lt;a href=&quot;#用于简化操作的常用函</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c++学习" scheme="http://example.com/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>c++学习-4：algorithm头文件</title>
    <link href="http://example.com/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://example.com/2021/03/19/c++%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-03-19T12:41:02.000Z</published>
    <updated>2021-04-16T10:28:49.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="头文件：algorithm"><a href="#头文件：algorithm" class="headerlink" title="头文件：algorithm"></a>头文件：algorithm</h1><p>algorithm意为”算法”,是C++的标准模版库（STL）中最重要的头文件之一，提供了大量基于迭代器的非成员模版函数。</p><h2 id="相关概念说明"><a href="#相关概念说明" class="headerlink" title="相关概念说明"></a>相关概念说明</h2><ol><li><strong>容器</strong> 容器是用来存放各种数据的一个东西，<code>&lt;algorithm&gt;</code>中的算法是针对容器设计的。因此，不论数据是一些<code>int</code>，<code>char</code>还是自定义的<code>class</code>，<code>&lt;algorithm&gt;</code>中的函数都可以正确应对。<code>vector</code>是最常用的容器。</li><li><strong>迭代器</strong> 迭代器是与容器进行配套使用的。它的作用是对容器中的元素进行遍历，比如数组的指针就可以看作一种迭代器。迭代器一般支持解引用（<code>operator*()</code>）、自加（<code>operator++()</code>）、相等（<code>operator==()</code>）等操作。</li><li><strong>谓词</strong> 谓词是用来对<code>&lt;algorithm&gt;</code>中的函数进行定制操作的。谓词可以是lambda表达式或是函数/函数指针，并且<code>&lt;algorithm&gt;</code>中只有一元谓词和二元谓词，即函数只能接收一个或两个参数。对于需要额外参数的谓词可以使用lambda表达式的捕获功能。</li><li><strong><code>pair</code></strong> 部分算法会有两个返回值，<code>pair</code>有两个成员<code>first</code>和<code>second</code>，用来将两个值进行打包返回。</li></ol><h2 id="用到的主要参数说明"><a href="#用到的主要参数说明" class="headerlink" title="用到的主要参数说明"></a>用到的主要参数说明</h2><ul><li><code>beg</code>和<code>end</code>是表示元素范围的迭代器。</li><li><code>beg2</code>是第二个输入序列开始位置的迭代器，<code>end2</code>表示第二个序列末尾位置（如果有的话）。如果没有<code>end2</code>，则假定<code>beg2</code>表示的序列与<code>beg</code>和<code>end</code>表示的序列一样大。<code>beg</code>和<code>beg2</code>不必是相同的类型，但两个序列中的元素都要能调用给定的可调用对像。比如<code>beg</code>是一个<code>std::vector&lt;int&gt;::iterator</code>，而<code>beg2</code>可以是一个<code>std::deque&lt;int&gt;::iterator</code>。</li><li><code>dest</code>是表示目的序列的迭代器，目的序列必须保证能够存储算法生成的所有元素。若无法确定大小，可以调用<code>std::back_inserter()</code>函数获取目的序列的插入迭代器。</li><li><code>unaryPred</code>和<code>binayPred</code>是一元和二元谓词，其实参都是序列中的元素。</li><li><code>comp</code>是一个二元谓词，用于比较两个元素。</li><li><code>unaryOp</code>和<code>binaryOp</code>是可调用对象。</li></ul><p>此外，部分算法要求序列是有序的，默认是使用小于运算符（<code>&lt;</code>）定义的升序。若使用谓词版本，则有序是按<code>comp</code>升序。</p><h2 id="常用函数及用法"><a href="#常用函数及用法" class="headerlink" title="常用函数及用法"></a>常用函数及用法</h2><h3 id="非修改性序列操作（12个）"><a href="#非修改性序列操作（12个）" class="headerlink" title="非修改性序列操作（12个）"></a>非修改性序列操作（12个）</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul><li>对序列中的每个元素执行某操作 for_each()</li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>在序列中找出某个值的第一次出现的位置 find()   利用底层元素的等于操作符，对范围内的元素与输入的值进行比较。当匹配时，结束搜索，返回该元素的一个 InputIterator 。</li><li>在序列中找出符合某谓词的第一个元素 find_if()</li><li>在序列中找出一子序列的最后一次出现的位置 find_end()</li><li>在序列中找出第一次出现指定值集中之值的位置 find_first_of()</li><li>在序列中找出相邻的一对值 adjacent_find()</li></ul><h4 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h4><ul><li>在序列中统计某个值出现的次数 count()</li><li>在序列中统计与某谓词匹配的次数 count_if()</li></ul><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ul><li>找出两个序列相异的第一个元素 mismatch()</li><li>两个序列中的对应元素都相同时为真 equal()</li></ul><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ul><li>在序列中找出一子序列的第一次出现的位置 search()</li><li>在序列中找出一值的连续n次出现的位置 search_n()</li></ul><h3 id="修改性序列操作（27个）"><a href="#修改性序列操作（27个）" class="headerlink" title="修改性序列操作（27个）"></a>修改性序列操作（27个）</h3><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>从序列的第一个元素起进行复制 copy()</li><li>从序列的最后一个元素起进行复制 copy_backward()</li></ul><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul><li>交换两个元素 swap()</li><li>交换指定范围的元素 swap_ranges()</li><li>交换由迭代器所指的两个元素 iter_swap()</li></ul><h4 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h4><ul><li>将某操作应用于指定范围的每个元素 transform()</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li>用一个给定值替换一些值 replace()</li><li>替换满足谓词的一些元素 replace_if()</li><li>复制序列时用一给定值替换元素 replace_copy()</li><li>复制序列时替换满足谓词的元素 replace_copy_if()</li></ul><h4 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h4><ul><li>用一给定值取代所有元素 fill()</li><li>用一给定值取代前n个元素 fill_n()</li></ul><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><ul><li>用一操作的结果取代所有元素 generate()</li><li>用一操作的结果取代前n个元素 generate_n()</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li>删除具有给定值的元素 remove()</li><li>删除满足谓词的元素 remove_if()</li><li>复制序列时删除具有给定值的元素 remove_copy()</li><li>复制序列时删除满足谓词的元素 remove_copy_if()</li></ul><h4 id="唯一"><a href="#唯一" class="headerlink" title="唯一"></a>唯一</h4><ul><li>删除相邻的重复元素 unique()</li><li>复制序列时删除相邻的重复元素 unique_copy()</li></ul><h4 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h4><ul><li>反转元素的次序 reverse()</li><li>复制序列时反转元素的次序 reverse_copy()</li></ul><h4 id="环移"><a href="#环移" class="headerlink" title="环移"></a>环移</h4><ul><li>循环移动元素 rotate()</li><li>复制序列时循环移动元素 rotate_copy()</li></ul><h4 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h4><ul><li>采用均匀分布来随机移动元素 random_shuffle()</li></ul><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul><li>将满足某谓词的元素都放到前面 partition()</li><li>将满足某谓词的元素都放到前面并维持原顺序 stable_partition()</li></ul><h3 id="序列排序及相关操作（27个）"><a href="#序列排序及相关操作（27个）" class="headerlink" title="序列排序及相关操作（27个）"></a>序列排序及相关操作（27个）</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>以很好的平均效率排序 sort()</li><li>并维持相同元素的原有顺序 stable_sort()</li><li>将序列的前一部分排好序 partial_sort()</li><li>复制的同时将序列的前一部分排好序 partial_sort_copy()</li><li>将第n各元素放到它的正确位置 nth_element()</li></ul><h4 id="二分检索"><a href="#二分检索" class="headerlink" title="二分检索"></a>二分检索</h4><ul><li>找到大于等于某值的第一次出现 lower_bound()</li><li>找到大于某值的第一次出现 upper_bound()</li><li>找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()</li><li>在有序序列中确定给定元素是否存在 binary_search()</li></ul><h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><ul><li>归并两个有序序列 merge()</li><li>归并两个接续的有序序列 inplace_merge()</li></ul><h4 id="有序结构上的集合操作"><a href="#有序结构上的集合操作" class="headerlink" title="有序结构上的集合操作"></a>有序结构上的集合操作</h4><ul><li>一序列为另一序列的子序列时为真 includes()</li><li>构造两个集合的有序并集 set_union()</li><li>构造两个集合的有序交集 set_intersection()</li><li>构造两个集合的有序差集 set_difference()</li><li>构造两个集合的有序对称差集（并-交） set_symmetric_difference()</li></ul><h4 id="堆操作"><a href="#堆操作" class="headerlink" title="堆操作"></a>堆操作</h4><ul><li>向堆中加入元素 push_heap()</li><li>从堆中弹出元素 pop_heap()</li><li>从序列构造堆 make_heap()</li><li>给堆排序 sort_heap()</li></ul><h4 id="最大和最小"><a href="#最大和最小" class="headerlink" title="最大和最小"></a>最大和最小</h4><ul><li>两个值中较小的 min()</li><li>两个值中较大的 max()</li><li>序列中的最小元素 min_element()</li><li>序列中的最大元素 max_element()</li></ul><h4 id="词典比较"><a href="#词典比较" class="headerlink" title="词典比较"></a>词典比较</h4><ul><li>两个序列按字典序的第一个在前 lexicographical_compare()</li></ul><h4 id="排列生成器"><a href="#排列生成器" class="headerlink" title="排列生成器"></a>排列生成器</h4><ul><li>按字典序的下一个排列 next_permutation()</li><li>按字典序的前一个排列 prev_permutation() </li></ul><p>其他详细内容：<a href="https://www.lagou.com/lgeduarticle/9665.html">https://www.lagou.com/lgeduarticle/9665.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;头文件：algorithm&quot;&gt;&lt;a href=&quot;#头文件：algorithm&quot; class=&quot;headerlink&quot; title=&quot;头文件：algorithm&quot;&gt;&lt;/a&gt;头文件：algorithm&lt;/h1&gt;&lt;p&gt;algorithm意为”算法”,是C++的标准模版库</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="c++学习" scheme="http://example.com/tags/c-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>网页设计-1</title>
    <link href="http://example.com/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/"/>
    <id>http://example.com/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/</id>
    <published>2021-03-19T03:02:30.000Z</published>
    <updated>2021-04-27T14:11:14.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h1><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;             //编码方式为utf-8        &lt;title&gt;第一个HTML&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;p&gt;            这是我的第一个html文件        &lt;/p&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>以上为基本应该存在的结构框架，效果图如下：</p><p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/2.png" alt="2"></p><h1 id="文字段落标签"><a href="#文字段落标签" class="headerlink" title="文字段落标签"></a>文字段落标签</h1><h2 id="标题与段落标签"><a href="#标题与段落标签" class="headerlink" title="标题与段落标签"></a>标题与段落标签</h2><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><pre><code class="html">&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt; //从左到右重要性递减    &lt;hn align=&quot;对齐方式&quot;&gt;标题内容&lt;/hn&gt;</code></pre><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><pre><code class="html">&lt;p align=&quot;对齐方式&quot;&gt;段落文本&lt;/p&gt;</code></pre><h3 id="水平分割线标签"><a href="#水平分割线标签" class="headerlink" title="水平分割线标签"></a>水平分割线标签</h3><pre><code class="html">&lt;hr 属性=&quot;属性值&quot;/&gt;//size设置粗细，align对齐方式，width设置宽度，color设置颜色，noshade设置3d阴影</code></pre><h3 id="换行缩进标签"><a href="#换行缩进标签" class="headerlink" title="换行缩进标签"></a>换行缩进标签</h3><pre><code class="html">&lt;br/&gt;                        //强制换行&lt;blockquote&gt;&lt;/blockquote&gt;   //缩进</code></pre><h2 id="文本的格式化标签"><a href="#文本的格式化标签" class="headerlink" title="文本的格式化标签"></a>文本的格式化标签</h2><pre><code class="html">&lt;b&gt;&lt;/b&gt;                        //粗体&lt;strong&gt;&lt;/strong&gt;            //强调，一般为粗体&lt;i&gt;&lt;/i&gt;                        //斜体&lt;em&gt;&lt;/em&gt;                    //强调，一般为斜体&lt;del&gt;&lt;/del&gt;                    //删除线&lt;ins&gt;&lt;/ins&gt;                    //加下划线&lt;sup&gt;&lt;/sup&gt;                    //上标&lt;sub&gt;&lt;/sub&gt;                    //下标</code></pre><h2 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h2><table><thead><tr><th>特殊字符</th><th>字符代码</th><th>特殊字符</th><th>字符代码</th></tr></thead><tbody><tr><td>空格</td><td>&amp;nbsp；</td><td>“</td><td>&amp;quot；</td></tr><tr><td>&lt;</td><td>&amp;lt；</td><td>©</td><td>&amp;copy；</td></tr><tr><td>&gt;</td><td>&amp;gt；</td><td>®</td><td>&amp;reg；</td></tr><tr><td>&amp;</td><td>&amp;amp；</td><td>×</td><td>&amp;times；</td></tr></tbody></table><h1 id="图像与超链接标签"><a href="#图像与超链接标签" class="headerlink" title="图像与超链接标签"></a>图像与超链接标签</h1><h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><pre><code class="html">&lt;img src=&quot;图像URL&quot;/&gt;</code></pre><h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><h3 id="创建超链接"><a href="#创建超链接" class="headerlink" title="创建超链接"></a>创建超链接</h3><pre><code class="html">&lt;a href=&quot;资源地址&quot; target=&quot;窗口名称&quot; title=&quot;链接提示&quot;&gt;链接对象&lt;/a&gt;</code></pre><h3 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h3><ol><li>绝对路径：网络主页上所存在的，或是文件在硬盘上的真实路径。</li><li>相对路径：以当前文件为起点，进行相对文件的查找。</li></ol><pre><code class="html">./          //指当前文件所在目录下（可省略）../         //指当前文件所在目录的上一目录下</code></pre><h3 id="锚点链接"><a href="#锚点链接" class="headerlink" title="锚点链接"></a>锚点链接</h3><p>锚点定义：</p><pre><code class="html">&lt;a name=&quot;锚点名称&quot;&gt;文字&lt;/a&gt;//或将name改做id</code></pre><p>跳转锚点：</p><pre><code class="html">&lt;a href=&quot;锚点名称&quot;&gt;链接的文字&lt;/a&gt;</code></pre><h3 id="影像地图"><a href="#影像地图" class="headerlink" title="影像地图"></a>影像地图</h3><pre><code class="html">&lt;img src=&quot;图像地址&quot; usemap=&quot;#影像地图名称&quot;&gt;   //使用影像地图&lt;map name=&quot;影像地图名称&quot;&gt;                      //定义影像地图    &lt;area shape=&quot;热区形状&quot; coords=&quot;热区坐标&quot; href=&quot;链接地址&quot;&gt;    &lt;!--此处可以添加多个area--&gt;&lt;/map&gt;</code></pre><p><strong>shape与coords的附加说明：</strong></p><ul><li>shape=”circle“，coords=”x,y,z“（x,y定义圆心位置，z为半径)</li><li>shape=“polygon”，coords=“x1,y1,x2,y2……”（每个顶点的坐标都要写入）</li><li>shape=“rectangle”，coords=“x1,y1,x2,y2”（一个顶点的坐标和其对角顶点坐标）</li></ul><h1 id="表格与列表标签"><a href="#表格与列表标签" class="headerlink" title="表格与列表标签"></a>表格与列表标签</h1><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格的定义范例"><a href="#表格的定义范例" class="headerlink" title="表格的定义范例"></a><strong>表格的定义范例</strong></h3><pre><code class="html">&lt;table&gt;    &lt;tr&gt;                                //表格的第一个横行        &lt;th&gt;此处表头字体自动加粗&lt;/th&gt;         //具体到行内的一个单元格        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;                                //表格的第二个横行        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;        &lt;td&gt;&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><pre><code class="html">&lt;caption&gt;定义表格的标题&lt;/caption&gt;&lt;thead&gt;定义表格的表头&lt;/thead&gt;&lt;tbody&gt;对表格中的主体内容进行分组&lt;/tbody&gt;&lt;tfoot&gt;对表格中的页脚内容进行分组&lt;/tfoot&gt;// 后三个标签应该结合使用</code></pre><h3 id="表格标签”table”的属性："><a href="#表格标签”table”的属性：" class="headerlink" title="表格标签”table”的属性："></a><strong>表格标签”table”的属性：</strong></h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>width/height</td><td>表格的宽度（高度），值可以是数值或百分比，数值表示像素点数，百分比是占浏览器宽度（高度）的比例</td></tr><tr><td>align</td><td>表格相对周围元素的对齐方式</td></tr><tr><td>background</td><td>表格的背景图片</td></tr><tr><td>bgcolor</td><td>表格的背景颜色，一般后期通过样式控制，不建议使用</td></tr><tr><td>border</td><td>表格边框宽度（像素为单位）</td></tr><tr><td>bordercolor</td><td>表格边框的颜色</td></tr><tr><td>cellspacing</td><td>单元格之间的间距</td></tr><tr><td>cellpadding</td><td>单元格内容与边界之间空白距离的大小</td></tr></tbody></table><h3 id="表格设置border时，可以设置显示隐藏边框"><a href="#表格设置border时，可以设置显示隐藏边框" class="headerlink" title="表格设置border时，可以设置显示隐藏边框"></a><strong>表格设置border时，可以设置显示隐藏边框</strong></h3><table><thead><tr><th>frame</th><th>描述</th><th>frame</th><th>描述</th></tr></thead><tbody><tr><td>box</td><td>显示所有边框</td><td>alove</td><td>只显示上边框</td></tr><tr><td>void</td><td>不显示边框</td><td>below</td><td>只显示下边框</td></tr><tr><td>hsides</td><td>只显示上下边框</td><td>lhs</td><td>只显示左边框</td></tr><tr><td>vsides</td><td>只显示左右边框</td><td>rhs</td><td>只显示右边框</td></tr></tbody></table><h3 id="单元格td的设置"><a href="#单元格td的设置" class="headerlink" title="单元格td的设置"></a><strong>单元格td的设置</strong></h3><table><thead><tr><th>属性</th><th>描述</th><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>width/height</td><td>单元格的宽和高，接受绝对值和相对值</td><td>align</td><td>单元格内容的水平对齐方式（left、right、center等）</td></tr><tr><td>colspan</td><td>规定单元格横跨列数（纵向合并单元格）</td><td>valign</td><td>单元格内容的垂直对齐方式（top、middle、bottom等）</td></tr><tr><td>rowspan</td><td>规定单元格横跨行数（横向合并单元格）</td><td>bgcolor</td><td>单元格的背景色</td></tr></tbody></table><h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><ul><li><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><pre><code class="html">&lt;ul type=编号类型&gt;    &lt;li&gt;第一项&lt;/li&gt;    &lt;li&gt;第二项&lt;/li&gt;    &lt;li&gt;第三项&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>type决定列表图标类型：</strong></p><ul><li><p>disc为实心圆（默认）</p></li><li><p>circle为空心圆</p></li><li><p>square为方块</p></li></ul></li></ul><ul><li><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><pre><code class="html">&lt;ol type=&quot;编号类型&quot; start=value&gt;    &lt;li&gt;第一项&lt;/li&gt;    &lt;li&gt;第二项&lt;/li&gt;    &lt;li&gt;第三项&lt;/li&gt;&lt;/ol&gt;</code></pre><p><strong>type决定列表序号样式：</strong></p><ul><li><strong>type=1：</strong>1,2,3,4,5……</li><li><strong>type=A：</strong>A,B,C,D,E……</li><li><strong>type=a：</strong>a,b,c,d,e……</li><li><strong>type=I：</strong>I,II,III,IV,V……</li><li><strong>type=i：</strong>i,ii,iii,iv,v……</li></ul><p><strong>reversed属性为true时，可以实现倒序排列，start指定第一项的序号</strong></p></li></ul><ul><li><h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3></li></ul><pre><code class="html">&lt;dl&gt;    &lt;dt&gt;第一项&lt;/dt&gt;&lt;dd&gt;注释一&lt;/dd&gt;    &lt;dt&gt;第二项&lt;/dt&gt;&lt;dd&gt;注释二&lt;/dd&gt;    &lt;dt&gt;第三项&lt;/dt&gt;&lt;dd&gt;注释三&lt;/dd&gt;&lt;/dl&gt;</code></pre><ul><li><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3></li></ul><pre><code class="html">&lt;ul type=&quot;circle&quot;&gt;    &lt;li&gt;北京&lt;/li&gt;    &lt;li&gt;上海        &lt;ol start=&quot;6&quot; type=&quot;1&quot; reversed=&quot;true&quot;&gt;        &lt;li&gt;浦东新区&lt;/li&gt;        &lt;li&gt;徐汇区&lt;/li&gt;        &lt;li&gt;长宁区&lt;/li&gt;        &lt;li&gt;普陀区&lt;/li&gt;        &lt;/ol&gt;    &lt;/li&gt;    &lt;li&gt;广州&lt;/li&gt;    &lt;li&gt;深圳&lt;/li&gt;&lt;/ul&gt;</code></pre><p>以上代码为无序列表嵌套有序列表，效果图如下</p><p><img src="/2021/03/19/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1-1/1.png" alt="1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构标签&quot;&gt;&lt;a href=&quot;#结构标签&quot; class=&quot;headerlink&quot; title=&quot;结构标签&quot;&gt;&lt;/a&gt;结构标签&lt;/h1&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;l</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="网页设计" scheme="http://example.com/tags/%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-4</title>
    <link href="http://example.com/2021/02/19/Linux%E5%AD%A6%E4%B9%A0-4/"/>
    <id>http://example.com/2021/02/19/Linux%E5%AD%A6%E4%B9%A0-4/</id>
    <published>2021-02-19T11:33:01.000Z</published>
    <updated>2021-04-16T10:32:15.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令大全："><a href="#常用命令大全：" class="headerlink" title="常用命令大全："></a>常用命令大全：</h1><h2 id="日常使用命令"><a href="#日常使用命令" class="headerlink" title="日常使用命令"></a>日常使用命令</h2><p>开关机命令<br>1、shutdown –h now：立刻进行关机</p><p>2、shutdown –r now：现在重新启动计算机</p><p>3、reboot：现在重新启动计算机</p><p>4、su -：切换用户；passwd：修改用户密码</p><p>5、logout：用户注销</p><h2 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h2><p>1、tab = 补全</p><p>2、ctrl + l -：清屏，类似clear命令</p><p>3、ctrl + r -：查找历史命令（history）；ctrl+c = 终止</p><p>4、ctrl+k = 删除此处至末尾所有内容</p><p>5、ctrl+u = 删除此处至开始所有内容</p><p>6、linux中的帮助命令：man、info、–help【[root@localhost ~]# man ls；[root@localhost ~]# info ls；[root@localhost ~]# ls –help】。退出帮助的话，按快捷键q</p><h2 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h2><p>1、ls</p><p>ls命令是列出目录内容的意思（List Directtory Contents）。运行它就是列出文件夹的内容，可能是文件也可能是文件夹。</p><p>  ls -l命令以详情模式(long listing fashion)列出文件夹的内容。</p><p>  ls -a命令会列出文件夹里的所有内容，包括以”.”开头的隐藏文件。</p><p>  注意：在Linux中，文件以“.”开头就是隐藏文件，并且每个文件，文件夹，设备或者命令都是以文件对待。</p><p>  2、lsblk</p><p>  lsblk就是列出块设备。除了RAM外，以标准的树状输出格式，整齐地显示块设备。</p><p>  lsblk -l命令以列表格式显示块设备(而不是树状格式)。</p><p>  注意：lsblk是最有用和最简单的方式来了解新插入的USB设备的名字，特别是当你在终端上处理磁盘/块设备时。</p><p>  3、uname</p><p>  “uname”命令就是Unix Name的简写。显示机器名，操作系统和内核的详细信息。</p><p>  注意：uname显示内核类别，uname -a显示详细信息。</p><p>  4、history</p><p>  “history”命令就是历史记录。它显示了在终端中所执行过的所有命令的历史。</p><p>  5、sudo</p><p>  “sudo”(super userdo)命令允许授权用户执行超级用户或者其它用户的命令。通过在sudoers列表的安全策略来指定。</p><p>  注意：sudo允许用户借用超级用户的权限，然而”su”命令实际上是允许用户以超级用户登录。所以sudo比su更安全。</p><p>  并不建议使用sudo或者su来处理日常用途，因为它可能导致严重的错误如果你意外的做错了事。</p><p>  6、chmod</p><p>  “chmod”命令就是改变文件的模式位。chmod会根据要求的模式来改变每个所给的文件，文件夹，脚本等等的文件模式（权限）。</p><p>  7、chown</p><p>  “chown”命令就是改变文件拥有者和所在用户组。每个文件都属于一个用户组和一个用户。在你的目录下，使用”ls -l”,你就会看到像这样的东西。</p><p>  8、apt</p><p>  Debian系列以“apt”命令为基础，“apt”代表了Advanced Package Tool。APT是一个为Debian系列系统（Ubuntu，Kubuntu等等）开发的高级包管理器，在Gnu/Linux系统上，它会为包自动地，智能地搜索，安装，升级以及解决依赖。例如：apt-get install mplayer</p><p>  9、cal</p><p>  “cal”（Calender），它用来显示当前月份或者未来或者过去任何年份中的月份。</p><p>  10、date</p><p>  “date”命令使用标准的输出打印当前的日期和时间，也可以深入设置。</p><h3 id="系统常用操作命令"><a href="#系统常用操作命令" class="headerlink" title="系统常用操作命令"></a>系统常用操作命令</h3><h4 id="1、指定运行级别"><a href="#1、指定运行级别" class="headerlink" title="1、指定运行级别"></a>1、指定运行级别</h4><p>命令：init[0123456]</p><p>运行级别：（0：关机；1：单用户；2：多用户状态没有网络服务；3：多用户状态有网络服务；4：系统未使用保留给用户；5：图形界面；6：系统重启）。</p><p> 常用运行级别是3和5，要修改默认的运行级别可修改文件/etc/inittab的id:5:inittab：这一行的数字。</p><p> 在启动引导界面的时候按e进入编辑，在进入grub引界面时，请输入e再选中第二个选项按e，再最后输入1[单用户级别]，然后按b进入单用户模式。</p><p> *：可通过此方法进行linux用户密码的修改。</p><h4 id="2、文件显示命令"><a href="#2、文件显示命令" class="headerlink" title="2、文件显示命令"></a>2、文件显示命令</h4><p>more：显示文件内容，带分页；</p><p>less：显示文件内容带分页；</p><p> grep：在文件中查询内容，grep –n “查找内容” 文件名；</p><p> | [管道命令]：在linux和unix系统中 | 就是管道命令，把上一个命令的结果交给 | 的后面的命令进行处理。</p><p> 例：grep –n “查找内容” 文件名 | more</p><p> cat：把文件串连接后输出到屏幕或加 &gt; fileName 到另一个档案。</p><p> head：格式：head [-n|c num]fileName，说明：显示文件头部内容。没有参数时，显示最前10行。</p><p> tail：格式：tail [-n|c num]fileName，说明：显示文件尾部内容。没有参数时，显示最后10行。</p><p> cut：格式：cut -cnum1-num2 filename，说明：显示每行从开头算起第 num1 到 num2 的字符。</p><h4 id="3、文件搜索命令find"><a href="#3、文件搜索命令find" class="headerlink" title="3、文件搜索命令find"></a>3、文件搜索命令find</h4><p>find：搜索文件及目录</p><p>在linux中，因为文件系统是以级别式的结构来组成的，所以要在整个系统中找到特定的文件和目录并不是件容易的事。而find命令可以解决上述问题。</p><p>  1、在特定的目录下搜索并显示指定名称的文件和目录。</p><p>  find / -name man：意思是说从根目录开始搜索名称为man的文件或目录。</p><p>  2、搜索一段时间内被存取/变更的文件或目录</p><p>  find / home–amin -10：十分钟内存取的文件或目录</p><p>  find / home–atime -10：十小时内存取的文件或目录</p><p>  find / home–cmin -10：十分钟内更改过的文件或目录</p><p>  find / home–ctime -10：十小时内更改过的文件或目录</p><p>  3、搜索指定大小的文件</p><p>  find / home–size +10k：意思是说查找/home目录下大小为10K的文件。</p><h4 id="4、重定向命令"><a href="#4、重定向命令" class="headerlink" title="4、重定向命令"></a>4、重定向命令</h4><p>重定向命令：管道定向命令“&gt;”为覆盖，“&gt;&gt;”追加写在原文件内容后面。</p><p>ls –l &gt;a.txt 列表的内容写入文件a.txt中（覆盖写）。</p><p>  ls –al&gt;&gt; aa.txt 列表的内容追加到文件aa.txt的末尾。</p><h4 id="5、其他命令"><a href="#5、其他命令" class="headerlink" title="5、其他命令"></a>5、其他命令</h4><p>who：格式：who - [husfV] [user]。说明：显示有哪些用户登录到系统中，显示的信息包含用户ID，使用的终端，上线时间，呆滞时间，CPU使用量，动作等等。相关命令 : who am i：显示当前用户是谁。</p><p>sleep：格式：sleep [–help] [–version] number[smhd]。说明 : sleep 可以用来将当前动作延迟一段时间。</p><p>  kill：格式：kill [ -s signal ] pid … 或 kill -l [ signal ]。说明：kill送出一个特定的信号 (signal) 给进程号为 pid 的进程。根据该信号而做特定的动作，若没有指定，默认是送出终止(TERM)信号。</p><p>  ps：格式：ps [options] [–help]。说明：显示进程的名称、占用资源、状态等。</p><p>  top：说明：显示CPU的使用率、内存大小、内存使用率、进程状态等。</p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>arch 显示机器的处理器架构(1)<br>uname -m 显示机器的处理器架构(2)<br>uname -r 显示正在使用的内核版本<br>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)<br>hdparm -i /dev/hda 罗列一个磁盘的架构特性<br>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作<br>cat /proc/cpuinfo 显示CPU info的信息<br>cat /proc/interrupts 显示中断<br>cat /proc/meminfo 校验内存使用<br>cat /proc/swaps 显示哪些swap被使用<br>cat /proc/version 显示内核的版本<br>cat /proc/net/dev 显示网络适配器及统计<br>cat /proc/mounts 显示已加载的文件系统<br>lspci -tv 罗列 PCI 设备<br>lsusb -tv 显示 USB 设备<br>date 显示系统日期<br>cal 2007 显示2007年的日历表<br>date 041217002007.00 设置日期和时间 - 月日时分年.秒<br>clock -w 将时间修改保存到 BIOS</p><h3 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h3><p>shutdown -h now 关闭系统(1)<br>init 0 关闭系统(2)<br>telinit 0 关闭系统(3)<br>shutdown -h hours:minutes &amp; 按预定时间关闭系统<br>shutdown -c 取消按预定时间关闭系统<br>shutdown -r now 重启(1)<br>reboot 重启(2)<br>logout 注销</p><h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>cd /home 进入 ‘/ home’ 目录’<br>cd … 返回上一级目录<br>cd …/… 返回上两级目录<br>cd 进入个人的主目录<br>cd ~user1 进入个人的主目录<br>cd - 返回上次所在的目录<br>pwd 显示工作路径<br>ls 查看目录中的文件<br>ls -F 查看目录中的文件<br>ls -l 显示文件和目录的详细资料<br>ls -a 显示隐藏文件<br>ls <em>[0-9]</em> 显示包含数字的文件名和目录名<br>tree 显示文件和目录由根目录开始的树形结构(1)<br>lstree 显示文件和目录由根目录开始的树形结构(2)<br>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’<br>mkdir dir1 dir2 同时创建两个目录<br>mkdir -p /tmp/dir1/dir2 创建一个目录树<br>rm -f file1 删除一个叫做 ‘file1’ 的文件’<br>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’<br>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容<br>rm -rf dir1 dir2 同时删除两个目录及它们的内容<br>mv dir1 new_dir 重命名/移动 一个目录<br>cp file1 file2 复制一个文件<br>cp dir/* . 复制一个目录下的所有文件到当前工作目录<br>cp -a /tmp/dir1 . 复制一个目录到当前工作目录<br>cp -a dir1 dir2 复制一个目录<br>ln -s file1 lnk1 创建一个指向文件或目录的软链接<br>ln file1 lnk1 创建一个指向文件或目录的物理链接<br>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)<br>file file1 outputs the mime type of the file as text<br>iconv -l 列出已知的编码<br>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.<br>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录<br>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录<br>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件<br>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件<br>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件<br>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限<br>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备<br>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令<br>whereis halt 显示一个二进制文件、源码或man的位置<br>which halt 显示一个二进制文件或可执行文件的完整路径</p><h3 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h3><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在<br>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出<br>fuser -km /mnt/hda2 当设备繁忙时强制卸载<br>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用<br>mount /dev/fd0 /mnt/floppy 挂载一个软盘<br>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom<br>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom<br>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件<br>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统<br>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备<br>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p><h3 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h3><p>df -h 显示已经挂载的分区列表<br>ls -lSr |more 以尺寸大小排列文件和目录<br>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’<br>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小<br>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)<br>dpkg-query -W -f=’ I n s t a l l e d − S i z e ; 10 t {Installed-Size;10}t Installed−Size;10t{Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p><h3 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h3><p>groupadd group_name 创建一个新用户组<br>groupdel group_name 删除一个用户组<br>groupmod -n new_group_name old_group_name 重命名一个用户组<br>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户<br>useradd user1 创建一个新用户<br>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)<br>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性<br>passwd 修改口令<br>passwd user1 修改一个用户的口令 (只允许root执行)<br>chage -E 2005-12-31 user1 设置用户口令的失效期限<br>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户<br>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组<br>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</p><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><p><strong>使用 “+” 设置权限，使用 “-” 用于取消</strong></p><p>ls -lh 显示权限<br>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示<br>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限<br>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限<br>chown user1 file1 改变一个文件的所有人属性<br>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性<br>chgrp group1 file1 改变文件的群组<br>chown user1:group1 file1 改变一个文件的所有人和群组属性<br>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件<br>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限<br>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位<br>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的<br>chmod g-s /home/public 禁用一个目录的 SGID 位<br>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件<br>chmod o-t /home/public 禁用一个目录的 STIKY 位</p><p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-” 用于取消<br>chattr +a file1 只允许以追加方式读写文件<br>chattr +c file1 允许这个文件能被内核自动压缩/解压<br>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件<br>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接<br>chattr +s file1 允许一个文件被安全地删除<br>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘<br>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件<br>lsattr 显示特殊的属性</p><h3 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h3><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件<br>bzip2 file1 压缩一个叫做 ‘file1’ 的文件<br>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件<br>gzip file1 压缩一个叫做 ‘file1’的文件<br>gzip -9 file1 最大程度压缩<br>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包<br>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’<br>rar x file1.rar 解压rar包<br>unrar x file1.rar 解压rar包<br>tar -cvf archive.tar file1 创建一个非压缩的 tarball<br>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件<br>tar -tf archive.tar 显示一个包中的内容<br>tar -xvf archive.tar 释放一个包<br>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下<br>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包<br>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包<br>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包<br>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包<br>zip file1.zip file1 创建一个zip格式的压缩包<br>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包<br>unzip file1.zip 解压一个zip格式压缩包</p><h3 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h3><p>rpm -ivh package.rpm 安装一个rpm包<br>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告<br>rpm -U package.rpm 更新一个rpm包但不改变其配置文件<br>rpm -F package.rpm 更新一个确定已经安装的rpm包<br>rpm -e package_name.rpm 删除一个rpm包<br>rpm -qa 显示系统中所有已经安装的rpm包<br>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包<br>rpm -qi package_name 获取一个已安装包的特殊信息<br>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包<br>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表<br>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表<br>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表<br>rpm -q package_name –whatprovides 显示一个rpm包所占的体积<br>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l<br>rpm -q package_name –changelog 显示一个rpm包的修改历史<br>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供<br>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表<br>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书<br>rpm –checksig package.rpm 确认一个rpm包的完整性<br>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性<br>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间<br>rpm -Va 检查系统中所有已安装的rpm包- 小心使用<br>rpm -Vp package.rpm 确认一个rpm包还未安装<br>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件<br>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包<br>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p><h3 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h3><p>yum install package_name 下载并安装一个rpm包<br>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系<br>yum update package_name.rpm 更新当前系统中所有安装的rpm包<br>yum update package_name 更新一个rpm包<br>yum remove package_name 删除一个rpm包<br>yum list 列出当前系统中安装的所有包<br>yum search package_name 在rpm仓库中搜寻软件包<br>yum clean packages 清理rpm缓存删除下载的包<br>yum clean headers 删除所有头文件<br>yum clean all 删除所有缓存的包和头文件</p><h3 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h3><p>dpkg -i package.deb 安装/更新一个 deb 包<br>dpkg -r package_name 从系统删除一个 deb 包<br>dpkg -l 显示系统中所有已经安装的 deb 包<br>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包<br>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息<br>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表<br>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表<br>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</p><h3 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h3><p>apt-get install package_name 安装/更新一个 deb 包<br>apt-cdrom install package_name 从光盘安装/更新一个 deb 包<br>apt-get update 升级列表中的软件包<br>apt-get upgrade 升级所有已安装的软件<br>apt-get remove package_name 从系统删除一个deb包<br>apt-get check 确认依赖的软件仓库正确<br>apt-get clean 从下载的软件包中清理缓存<br>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</p><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat file1 从第一个字节开始正向查看文件的内容<br>tac file1 从最后一行开始反向查看一个文件的内容<br>more file1 查看一个长文件的内容<br>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作<br>head -2 file1 查看一个文件的前两行<br>tail -2 file1 查看一个文件的最后两行<br>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</p><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中<br>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中<br>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”<br>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇<br>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行<br>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”<br>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”<br>sed ‘/^KaTeX parse error: Expected ‘EOF’, got ‘#’ at position 49: …所有空白行 sed ‘/ *#̲/d; /^/d’ example.txt 从example.txt文件中删除所有注释和空白行<br>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容<br>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行<br>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行<br>sed -e ‘s/ <em>$//‘ example.txt 删除每一行最后的空白字符<br>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部<br>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容<br>sed -n ‘5p;5q’ example.txt 查看第5行<br>sed -e ‘s/00</em>/0/g’ example.txt 用单个零替换多个零<br>cat -n file1 标示文件的行数<br>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行<br>echo a b c | awk ‘{print $1}’ 查看一行第一栏<br>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏<br>paste file1 file2 合并两个文件或两栏的内容<br>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分<br>sort file1 file2 排序两个文件的内容<br>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)<br>sort file1 file2 | uniq -u 删除交集，留下其他的行<br>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)<br>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容<br>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容<br>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</p><h3 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h3><p>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX<br>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS<br>recode …HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html<br>recode -l | more 显示所有允许的转换格式</p><h3 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h3><p>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块<br>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性<br>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性<br>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性<br>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性<br>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性<br>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</p><h3 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h3><p>mkfs /dev/hda1 在hda1分区创建一个文件系统<br>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统<br>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统<br>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统<br>fdformat -n /dev/fd0 格式化一个软盘<br>mkswap /dev/hda3 创建一个swap文件系统</p><h3 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h3><p>mkswap /dev/hda3 创建一个swap文件系统<br>swapon /dev/hda3 启用一个新的swap文件系统<br>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份<br>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份<br>restore -if /tmp/home0.bak 还原一个交互式备份<br>rsync -rogpav –delete /home /tmp 同步两边的目录<br>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync<br>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录<br>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录<br>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作<br>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件<br>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作<br>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容<br>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录<br>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接<br>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录<br>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包<br>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作<br>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</p><h3 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h3><p>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容<br>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件<br>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件<br>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件<br>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件<br>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件<br>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件<br>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中<br>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）<br>cdrecord –scanbus 扫描总线以识别scsi通道<br>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</p><h3 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h3><p>ifconfig eth0 显示一个以太网卡的配置<br>ifup eth0 启用一个 ‘eth0’ 网络设备<br>ifdown eth0 禁用一个 ‘eth0’ 网络设备<br>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址<br>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)<br>dhclient eth0 以dhcp模式启用 ‘eth0’</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令大全：&quot;&gt;&lt;a href=&quot;#常用命令大全：&quot; class=&quot;headerlink&quot; title=&quot;常用命令大全：&quot;&gt;&lt;/a&gt;常用命令大全：&lt;/h1&gt;&lt;h2 id=&quot;日常使用命令&quot;&gt;&lt;a href=&quot;#日常使用命令&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习-3</title>
    <link href="http://example.com/2021/02/10/Linux%E5%AD%A6%E4%B9%A0-3/"/>
    <id>http://example.com/2021/02/10/Linux%E5%AD%A6%E4%B9%A0-3/</id>
    <published>2021-02-10T10:29:59.000Z</published>
    <updated>2021-04-16T10:32:00.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-文件与目录管理"><a href="#Linux-文件与目录管理" class="headerlink" title="Linux 文件与目录管理"></a>Linux 文件与目录管理</h1><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><p><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>/</strong> 写起，例如： /usr/share/doc 这个目录。</p></li><li><p><strong>相对路径：</strong><br>路径的写法，不是由 <strong>/</strong> 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： <strong>cd ../man</strong> 这就是相对路径的写法。</p></li></ul><hr><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将家目录下的所有文件列出来(含属性与隐藏档)</p><pre><code>[root@www ~]# ls -al ~</code></pre><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code> cd [相对路径或绝对路径]#使用 mkdir 命令创建 runoob 目录[root@www ~]# mkdir runoob#使用绝对路径切换到 runoob 目录[root@www ~]# cd /root/runoob/#使用相对路径切换到 runoob 目录[root@www ~]# cd ./runoob/# 表示回到自己的家目录，亦即是 /root 这个目录[root@www runoob]# cd ~# 表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；[root@www ~]# cd ..</code></pre><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@www ~]# pwd [-P]</code></pre><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><pre><code>[root@www ~]# pwd/root   &lt;== 显示出目录啦～</code></pre><p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p><pre><code>[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个连结档[root@www mail]# pwd/var/mail         &lt;==列出目前的工作目录[root@www mail]# pwd -P/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～[root@www mail]# ls -ld /var/maillrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail# 看到这里应该知道为啥了吧？因为 /var/mail 是连结档，连结到 /var/spool/mail # 所以，加上 pwd -P 的选项后，会不以连结档的数据显示，而是显示正确的完整路径啊！</code></pre><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到/tmp底下尝试创建数个新目录看看：</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#39;: No such file or directory       &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4</code></pre><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><pre><code>[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><pre><code> rmdir [-p] 目录名称</code></pre><p>选项与参数：</p><ul><li><strong>-p ：</strong>连同上一级『空的』目录也一起删除</li></ul><p>删除 runoob 目录</p><pre><code>[root@www tmp]# rmdir runoob/</code></pre><p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p><pre><code>[root@www tmp]# ls -l   &lt;==看看有多少目录存在？drwxr-xr-x  3 root  root 4096 Jul 18 12:50 testdrwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1drwx--x--x  2 root  root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#39;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</code></pre><p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc</p><pre><code>[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#39;? n  &lt;==n不覆盖，y为覆盖</code></pre><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><pre><code> rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><pre><code>[root@www tmp]# rm -i bashrcrm: remove regular file `bashrc&#39;? y</code></pre><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><pre><code>[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><pre><code>[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest</code></pre><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><pre><code>[root@www tmp]# mv mvtest mvtest2</code></pre><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><pre><code>cat [-AbEnTv]</code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 /etc/issue 这个文件的内容：</p><pre><code>[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \r on an \m</code></pre><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre><code>[root@www ~]# tac /etc/issueKernel \r on an \mCentOS release 6.4 (Final)</code></pre><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><pre><code>nl [-bnw] 文件</code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 /etc/issue 的内容</p><pre><code>[root@www ~]# nl /etc/issue     1  CentOS release 6.4 (Final)     2  Kernel \r on an \m</code></pre><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><pre><code>[root@www ~]# more /etc/man_db.config ## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....--More--(28%)  &lt;== </code></pre><p>在 more 这个程序的运行过程中：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p><pre><code>[root@www ~]# less /etc/man.config## Generated automatically from man.conf.in by the# configure script.## man.conf from man-1.6d....(中间省略)....:   &lt;== 这里可以等待你输入命令！</code></pre><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><pre><code>head [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><pre><code>[root@www ~]# head /etc/man.config</code></pre><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre><code>[root@www ~]# head -n 20 /etc/man.config</code></pre><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><pre><code>tail [-n number] 文件 </code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><pre><code>[root@www ~]# tail /etc/man.config# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：[root@www ~]# tail -n 20 /etc/man.config</code></pre><h2 id="Linux-链接概念"><a href="#Linux-链接概念" class="headerlink" title="Linux 链接概念"></a>Linux 链接概念</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，<strong>ln</strong> 命令产生硬链接。</p><h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a><strong>硬连接</strong></h3><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a><strong>软连接</strong></h3><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><h3 id="可以得到以下全部结论："><a href="#可以得到以下全部结论：" class="headerlink" title="可以得到以下全部结论："></a>可以得到以下全部结论：</h3><p>1).删除符号连接f3,对f1,f2无影响</p><p>2).删除硬连接f2，对f1,f3也无影响</p><p>3).删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效</p><p> 4).同时删除原文件f1,硬连接f2，整个文件会真正的被删除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-文件与目录管理&quot;&gt;&lt;a href=&quot;#Linux-文件与目录管理&quot; class=&quot;headerlink&quot; title=&quot;Linux 文件与目录管理&quot;&gt;&lt;/a&gt;Linux 文件与目录管理&lt;/h1&gt;&lt;p&gt;我们知道Linux的目录结构为树状结构，最顶级的目录</summary>
      
    
    
    
    <category term="学习" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Linux学习" scheme="http://example.com/tags/Linux%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
